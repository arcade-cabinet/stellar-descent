{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/WebGL/webGLPipelineContext.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/abstractEngine.functions.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/thinEngine.functions.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/Processors/shaderCodeNode.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/Processors/shaderCodeCursor.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/Processors/shaderCodeConditionNode.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/Processors/shaderCodeTestNode.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/Processors/Expressions/shaderDefineExpression.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineIsDefinedOperator.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineOrOperator.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineAndOperator.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/Processors/Expressions/Operators/shaderDefineArithmeticOperator.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Engines/Processors/shaderProcessor.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Materials/effect.functions.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Materials/effect.ts"],
  "sourcesContent": ["import type { IPipelineContext } from \"../IPipelineContext\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../../Maths/math.like\";\r\nimport type { ThinEngine } from \"../thinEngine\";\r\nimport type { AbstractEngine } from \"../abstractEngine\";\r\n\r\n/** @internal */\r\nexport class WebGLPipelineContext implements IPipelineContext {\r\n    private _valueCache: { [key: string]: any } = {};\r\n    private _uniforms: { [key: string]: Nullable<WebGLUniformLocation> };\r\n\r\n    public engine: ThinEngine;\r\n    public program: Nullable<WebGLProgram>;\r\n    public context?: WebGLRenderingContext;\r\n    public vertexShader?: WebGLShader;\r\n    public fragmentShader?: WebGLShader;\r\n    public isParallelCompiled: boolean;\r\n    public onCompiled?: () => void;\r\n    public transformFeedback?: WebGLTransformFeedback | null;\r\n\r\n    public vertexCompilationError: Nullable<string> = null;\r\n    public fragmentCompilationError: Nullable<string> = null;\r\n    public programLinkError: Nullable<string> = null;\r\n    public programValidationError: Nullable<string> = null;\r\n\r\n    /** @internal */\r\n    public _isDisposed = false;\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public get isAsync() {\r\n        return this.isParallelCompiled;\r\n    }\r\n\r\n    public get isReady(): boolean {\r\n        if (this.program) {\r\n            if (this.isParallelCompiled) {\r\n                return this.engine._isRenderingStateCompiled(this);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public _handlesSpectorRebuildCallback(onCompiled: (program: WebGLProgram) => void): void {\r\n        if (onCompiled && this.program) {\r\n            onCompiled(this.program);\r\n        }\r\n    }\r\n\r\n    public setEngine(engine: AbstractEngine): void {\r\n        this.engine = engine as ThinEngine;\r\n    }\r\n\r\n    public _fillEffectInformation(\r\n        effect: Effect,\r\n        uniformBuffersNames: { [key: string]: number },\r\n        uniformsNames: string[],\r\n        uniforms: { [key: string]: Nullable<WebGLUniformLocation> },\r\n        samplerList: string[],\r\n        samplers: { [key: string]: number },\r\n        attributesNames: string[],\r\n        attributes: number[]\r\n    ) {\r\n        const engine = this.engine;\r\n        if (engine.supportsUniformBuffers) {\r\n            for (const name in uniformBuffersNames) {\r\n                effect.bindUniformBlock(name, uniformBuffersNames[name]);\r\n            }\r\n        }\r\n\r\n        const effectAvailableUniforms = this.engine.getUniforms(this, uniformsNames);\r\n        effectAvailableUniforms.forEach((uniform, index) => {\r\n            uniforms[uniformsNames[index]] = uniform;\r\n        });\r\n        this._uniforms = uniforms;\r\n\r\n        let index: number;\r\n        for (index = 0; index < samplerList.length; index++) {\r\n            const sampler = effect.getUniform(samplerList[index]);\r\n            if (sampler == null) {\r\n                samplerList.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n\r\n        samplerList.forEach((name, index) => {\r\n            samplers[name] = index;\r\n        });\r\n\r\n        for (const attr of engine.getAttributes(this, attributesNames)) {\r\n            attributes.push(attr);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        this._uniforms = {};\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheMatrix(uniformName: string, matrix: IMatrixLike): boolean {\r\n        const cache = this._valueCache[uniformName];\r\n        const flag = matrix.updateFlag;\r\n        if (cache !== undefined && cache === flag) {\r\n            return false;\r\n        }\r\n\r\n        this._valueCache[uniformName] = flag;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat2(uniformName: string, x: number, y: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 2) {\r\n            cache = [x, y];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat3(uniformName: string, x: number, y: number, z: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 3) {\r\n            cache = [x, y, z];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cacheFloat4(uniformName: string, x: number, y: number, z: number, w: number): boolean {\r\n        let cache = this._valueCache[uniformName];\r\n        if (!cache || cache.length !== 4) {\r\n            cache = [x, y, z, w];\r\n            this._valueCache[uniformName] = cache;\r\n            return true;\r\n        }\r\n\r\n        let changed = false;\r\n        if (cache[0] !== x) {\r\n            cache[0] = x;\r\n            changed = true;\r\n        }\r\n        if (cache[1] !== y) {\r\n            cache[1] = y;\r\n            changed = true;\r\n        }\r\n        if (cache[2] !== z) {\r\n            cache[2] = z;\r\n            changed = true;\r\n        }\r\n        if (cache[3] !== w) {\r\n            cache[3] = w;\r\n            changed = true;\r\n        }\r\n\r\n        return changed;\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setInt(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this.engine.setInt(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this.engine.setInt2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this.engine.setInt3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a int4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this.engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray2(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray3(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setIntArray4(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     */\r\n    public setUInt(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this.engine.setUInt(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this.engine.setUInt2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this.engine.setUInt3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this.engine.setUInt4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray2(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray3(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setUIntArray4(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray2(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray3(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setArray4(this._uniforms[uniformName], array);\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array): void {\r\n        if (!matrices) {\r\n            return;\r\n        }\r\n\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setMatrices(this._uniforms[uniformName], matrices);\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): void {\r\n        if (this._cacheMatrix(uniformName, matrix)) {\r\n            if (!this.engine.setMatrices(this._uniforms[uniformName], matrix.asArray())) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setMatrix3x3(this._uniforms[uniformName], matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array): void {\r\n        this._valueCache[uniformName] = null;\r\n        this.engine.setMatrix2x2(this._uniforms[uniformName], matrix);\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     */\r\n    public setFloat(uniformName: string, value: number): void {\r\n        const cache = this._valueCache[uniformName];\r\n        if (cache !== undefined && cache === value) {\r\n            return;\r\n        }\r\n\r\n        if (this.engine.setFloat(this._uniforms[uniformName], value)) {\r\n            this._valueCache[uniformName] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): void {\r\n        if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {\r\n            if (!this.engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): void {\r\n        if (this._cacheFloat2(uniformName, x, y)) {\r\n            if (!this.engine.setFloat2(this._uniforms[uniformName], x, y)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): void {\r\n        if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {\r\n            if (!this.engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): void {\r\n        if (this._cacheFloat3(uniformName, x, y, z)) {\r\n            if (!this.engine.setFloat3(this._uniforms[uniformName], x, y, z)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): void {\r\n        if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): void {\r\n        if (this._cacheFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): void {\r\n        if (this._cacheFloat4(uniformName, x, y, z, w)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): void {\r\n        if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {\r\n            if (!this.engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): void {\r\n        if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): void {\r\n        if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {\r\n            if (!this.engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {\r\n                this._valueCache[uniformName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public _getVertexShaderCode(): string | null {\r\n        return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;\r\n    }\r\n\r\n    public _getFragmentShaderCode(): string | null {\r\n        return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;\r\n    }\r\n}\r\n", "import { _WarnImport } from \"core/Misc/devTools\";\r\nimport { IsDocumentAvailable } from \"core/Misc/domManagement\";\r\nimport type { IFileRequest } from \"core/Misc/fileRequest\";\r\nimport type { LoadFileError } from \"core/Misc/fileTools\";\r\nimport type { IWebRequest } from \"core/Misc/interfaces/iWebRequest\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IOfflineProvider } from \"core/Offline/IOfflineProvider\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Constants } from \"./constants\";\r\n\r\nexport const EngineFunctionContext: {\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    loadFile?: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: Nullable<IOfflineProvider>,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ) => IFileRequest;\r\n} = {};\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _ConcatenateShader(source: string, defines: Nullable<string>, shaderVersion: string = \"\"): string {\r\n    return shaderVersion + (defines ? defines + \"\\n\" : \"\") + source;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _LoadFile(\r\n    url: string,\r\n    onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n    onProgress?: (data: any) => void,\r\n    offlineProvider?: Nullable<IOfflineProvider>,\r\n    useArrayBuffer?: boolean,\r\n    onError?: (request?: IWebRequest, exception?: any) => void,\r\n    injectedLoadFile?: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent<EventTarget>) => void,\r\n        offlineProvider?: Nullable<IOfflineProvider>,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ) => IFileRequest\r\n): IFileRequest {\r\n    const loadFile = injectedLoadFile || EngineFunctionContext.loadFile;\r\n    if (loadFile) {\r\n        const request = loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);\r\n        return request;\r\n    }\r\n    throw _WarnImport(\"FileTools\");\r\n}\r\n\r\n/**\r\n * Gets host document\r\n * @param renderingCanvas if provided, the canvas' owner document will be returned\r\n * @returns the host document object\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getHostDocument(renderingCanvas: Nullable<HTMLCanvasElement> = null): Nullable<Document> {\r\n    if (renderingCanvas && renderingCanvas.ownerDocument) {\r\n        return renderingCanvas.ownerDocument;\r\n    }\r\n\r\n    return IsDocumentAvailable() ? document : null;\r\n}\r\n\r\n/** @internal */\r\nexport function _GetGlobalDefines(\r\n    defines?: { [key: string]: string },\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    isNDCHalfZRange?: boolean,\r\n    useReverseDepthBuffer?: boolean,\r\n    useExactSrgbConversions?: boolean\r\n): string | undefined {\r\n    if (defines) {\r\n        if (isNDCHalfZRange) {\r\n            defines[\"IS_NDC_HALF_ZRANGE\"] = \"\";\r\n        } else {\r\n            delete defines[\"IS_NDC_HALF_ZRANGE\"];\r\n        }\r\n        if (useReverseDepthBuffer) {\r\n            defines[\"USE_REVERSE_DEPTHBUFFER\"] = \"\";\r\n        } else {\r\n            delete defines[\"USE_REVERSE_DEPTHBUFFER\"];\r\n        }\r\n        if (useExactSrgbConversions) {\r\n            defines[\"USE_EXACT_SRGB_CONVERSIONS\"] = \"\";\r\n        } else {\r\n            delete defines[\"USE_EXACT_SRGB_CONVERSIONS\"];\r\n        }\r\n        return;\r\n    } else {\r\n        let s = \"\";\r\n        if (isNDCHalfZRange) {\r\n            s += \"#define IS_NDC_HALF_ZRANGE\";\r\n        }\r\n        if (useReverseDepthBuffer) {\r\n            if (s) {\r\n                s += \"\\n\";\r\n            }\r\n            s += \"#define USE_REVERSE_DEPTHBUFFER\";\r\n        }\r\n        if (useExactSrgbConversions) {\r\n            if (s) {\r\n                s += \"\\n\";\r\n            }\r\n            s += \"#define USE_EXACT_SRGB_CONVERSIONS\";\r\n        }\r\n        return s;\r\n    }\r\n}\r\n\r\n/**\r\n * Allocate a typed array depending on a texture type. Optionally can copy existing data in the buffer.\r\n * @param type type of the texture\r\n * @param sizeOrDstBuffer size of the array OR an existing buffer that will be used as the destination of the copy (if copyBuffer is provided)\r\n * @param sizeInBytes true if the size of the array is given in bytes, false if it is the number of elements of the array\r\n * @param copyBuffer if provided, buffer to copy into the destination buffer (either a newly allocated buffer if sizeOrDstBuffer is a number or use sizeOrDstBuffer as the destination buffer otherwise)\r\n * @returns the allocated buffer or sizeOrDstBuffer if the latter is an ArrayBuffer\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function allocateAndCopyTypedBuffer(type: number, sizeOrDstBuffer: number | ArrayBufferLike, sizeInBytes = false, copyBuffer?: ArrayBuffer): ArrayBufferView {\r\n    switch (type) {\r\n        case Constants.TEXTURETYPE_BYTE: {\r\n            const buffer = new Int8Array(sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int8Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_BYTE: {\r\n            const buffer = new Uint8Array(sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint8Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_SHORT: {\r\n            const buffer = typeof sizeOrDstBuffer !== \"number\" ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int16Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n        case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n            const buffer = typeof sizeOrDstBuffer !== \"number\" ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint16Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_INT: {\r\n            const buffer = typeof sizeOrDstBuffer !== \"number\" ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_INTEGER:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_24_8:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\r\n        case Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV: {\r\n            const buffer = typeof sizeOrDstBuffer !== \"number\" ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_FLOAT: {\r\n            const buffer = typeof sizeOrDstBuffer !== \"number\" ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Float32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    const buffer = new Uint8Array(sizeOrDstBuffer);\r\n    if (copyBuffer) {\r\n        buffer.set(new Uint8Array(copyBuffer));\r\n    }\r\n    return buffer;\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { _IShaderProcessingContext } from \"./Processors/shaderProcessingOptions\";\r\nimport { WebGLPipelineContext } from \"./WebGL/webGLPipelineContext\";\r\nimport type { _LoadFile } from \"./abstractEngine.functions\";\r\nimport { _ConcatenateShader } from \"./abstractEngine.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface IThinEngineStateObject {\r\n    _contextWasLost?: boolean;\r\n    validateShaderPrograms?: boolean;\r\n    _webGLVersion: number;\r\n    parallelShaderCompile?: { COMPLETION_STATUS_KHR: number };\r\n    disableParallelShaderCompile?: boolean;\r\n    _context?: WebGLContext;\r\n    _createShaderProgramInjection?: typeof _createShaderProgram;\r\n    createRawShaderProgramInjection?: typeof createRawShaderProgram;\r\n    createShaderProgramInjection?: typeof createShaderProgram;\r\n    loadFileInjection?: typeof _LoadFile;\r\n    cachedPipelines: { [name: string]: IPipelineContext };\r\n}\r\n\r\nconst StateObject: WeakMap<WebGLContext, IThinEngineStateObject> = new WeakMap();\r\n\r\n/**\r\n * This will be used in cases where the engine doesn't have a context (like the nullengine)\r\n */\r\nconst SingleStateObject: IThinEngineStateObject = {\r\n    _webGLVersion: 2,\r\n    cachedPipelines: {},\r\n};\r\n\r\n/**\r\n * get or create a state object for the given context\r\n * Note - Used in WebGL only at the moment.\r\n * @param context The context to get the state object from\r\n * @returns the state object\r\n * @internal\r\n */\r\nexport function getStateObject(context: WebGLContext): IThinEngineStateObject {\r\n    let state = StateObject.get(context);\r\n    if (!state) {\r\n        if (!context) {\r\n            return SingleStateObject;\r\n        }\r\n        state = {\r\n            // use feature detection. instanceof returns false. This only exists on WebGL2 context\r\n            _webGLVersion: (context as WebGL2RenderingContext).TEXTURE_BINDING_3D ? 2 : 1,\r\n            _context: context,\r\n            // when using the function without an engine we need to set it to enable parallel compilation\r\n            parallelShaderCompile: context.getExtension(\"KHR_parallel_shader_compile\") || undefined,\r\n            cachedPipelines: {},\r\n        };\r\n        StateObject.set(context, state);\r\n    }\r\n    return state;\r\n}\r\n/**\r\n * Remove the state object that belongs to the specific context\r\n * @param context the context that is being\r\n */\r\nexport function deleteStateObject(context: WebGLContext): void {\r\n    StateObject.delete(context);\r\n}\r\n\r\nexport type WebGLContext = WebGLRenderingContext | WebGL2RenderingContext;\r\n/**\r\n * Directly creates a webGL program\r\n * @param pipelineContext  defines the pipeline context to attach to\r\n * @param vertexCode defines the vertex shader code to use\r\n * @param fragmentCode defines the fragment shader code to use\r\n * @param context defines the webGL context to use (if not set, the current one will be used)\r\n * @param transformFeedbackVaryings defines the list of transform feedback varyings to use\r\n * @param _createShaderProgramInjection defines an optional injection to use to create the shader program\r\n * @returns the new webGL program\r\n */\r\nexport function createRawShaderProgram(\r\n    pipelineContext: IPipelineContext,\r\n    vertexCode: string,\r\n    fragmentCode: string,\r\n    context: WebGLContext,\r\n    transformFeedbackVaryings: Nullable<string[]>,\r\n    _createShaderProgramInjection?: typeof _createShaderProgram\r\n): WebGLProgram {\r\n    const stateObject = getStateObject(context);\r\n    if (!_createShaderProgramInjection) {\r\n        _createShaderProgramInjection = stateObject._createShaderProgramInjection ?? _createShaderProgram;\r\n    }\r\n\r\n    const vertexShader = CompileRawShader(vertexCode, \"vertex\", context, stateObject._contextWasLost);\r\n    const fragmentShader = CompileRawShader(fragmentCode, \"fragment\", context, stateObject._contextWasLost);\r\n\r\n    return _createShaderProgramInjection(\r\n        pipelineContext as WebGLPipelineContext,\r\n        vertexShader,\r\n        fragmentShader,\r\n        context,\r\n        transformFeedbackVaryings,\r\n        stateObject.validateShaderPrograms\r\n    );\r\n}\r\n\r\n/**\r\n * Creates a webGL program\r\n * @param pipelineContext  defines the pipeline context to attach to\r\n * @param vertexCode  defines the vertex shader code to use\r\n * @param fragmentCode defines the fragment shader code to use\r\n * @param defines defines the string containing the defines to use to compile the shaders\r\n * @param context defines the webGL context to use (if not set, the current one will be used)\r\n * @param transformFeedbackVaryings defines the list of transform feedback varyings to use\r\n * @param _createShaderProgramInjection defines an optional injection to use to create the shader program\r\n * @returns the new webGL program\r\n */\r\nexport function createShaderProgram(\r\n    pipelineContext: IPipelineContext,\r\n    vertexCode: string,\r\n    fragmentCode: string,\r\n    defines: Nullable<string>,\r\n    context: WebGLContext,\r\n    transformFeedbackVaryings: Nullable<string[]> = null,\r\n    _createShaderProgramInjection?: typeof _createShaderProgram\r\n): WebGLProgram {\r\n    const stateObject = getStateObject(context);\r\n    if (!_createShaderProgramInjection) {\r\n        _createShaderProgramInjection = stateObject._createShaderProgramInjection ?? _createShaderProgram;\r\n    }\r\n    const shaderVersion = stateObject._webGLVersion > 1 ? \"#version 300 es\\n#define WEBGL2 \\n\" : \"\";\r\n    const vertexShader = CompileShader(vertexCode, \"vertex\", defines, shaderVersion, context, stateObject._contextWasLost);\r\n    const fragmentShader = CompileShader(fragmentCode, \"fragment\", defines, shaderVersion, context, stateObject._contextWasLost);\r\n\r\n    return _createShaderProgramInjection(\r\n        pipelineContext as WebGLPipelineContext,\r\n        vertexShader,\r\n        fragmentShader,\r\n        context,\r\n        transformFeedbackVaryings,\r\n        stateObject.validateShaderPrograms\r\n    );\r\n}\r\n\r\n/**\r\n * Creates a new pipeline context. Note, make sure to attach an engine instance to the created context\r\n * @param context defines the webGL context to use (if not set, the current one will be used)\r\n * @param _shaderProcessingContext defines the shader processing context used during the processing if available\r\n * @returns the new pipeline\r\n */\r\nexport function createPipelineContext(context: WebGLContext, _shaderProcessingContext: Nullable<_IShaderProcessingContext>): IPipelineContext {\r\n    const pipelineContext = new WebGLPipelineContext();\r\n    const stateObject = getStateObject(context);\r\n    if (stateObject.parallelShaderCompile && !stateObject.disableParallelShaderCompile) {\r\n        pipelineContext.isParallelCompiled = true;\r\n    }\r\n    pipelineContext.context = stateObject._context;\r\n    return pipelineContext;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _createShaderProgram(\r\n    pipelineContext: WebGLPipelineContext,\r\n    vertexShader: WebGLShader,\r\n    fragmentShader: WebGLShader,\r\n    context: WebGLContext,\r\n    _transformFeedbackVaryings: Nullable<string[]> = null,\r\n    validateShaderPrograms?: boolean\r\n): WebGLProgram {\r\n    const shaderProgram = context.createProgram();\r\n    pipelineContext.program = shaderProgram;\r\n\r\n    if (!shaderProgram) {\r\n        throw new Error(\"Unable to create program\");\r\n    }\r\n\r\n    context.attachShader(shaderProgram, vertexShader);\r\n    context.attachShader(shaderProgram, fragmentShader);\r\n\r\n    context.linkProgram(shaderProgram);\r\n\r\n    pipelineContext.context = context;\r\n    pipelineContext.vertexShader = vertexShader;\r\n    pipelineContext.fragmentShader = fragmentShader;\r\n\r\n    if (!pipelineContext.isParallelCompiled) {\r\n        _finalizePipelineContext(pipelineContext, context, validateShaderPrograms);\r\n    }\r\n\r\n    return shaderProgram;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _isRenderingStateCompiled(pipelineContext: IPipelineContext, gl: WebGLContext, validateShaderPrograms?: boolean): boolean {\r\n    const webGLPipelineContext = pipelineContext as WebGLPipelineContext;\r\n    if (webGLPipelineContext._isDisposed) {\r\n        return false;\r\n    }\r\n    const stateObject = getStateObject(gl);\r\n    if (stateObject && stateObject.parallelShaderCompile && stateObject.parallelShaderCompile.COMPLETION_STATUS_KHR && webGLPipelineContext.program) {\r\n        if (gl.getProgramParameter(webGLPipelineContext.program, stateObject.parallelShaderCompile.COMPLETION_STATUS_KHR)) {\r\n            _finalizePipelineContext(webGLPipelineContext, gl, validateShaderPrograms);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _finalizePipelineContext(pipelineContext: WebGLPipelineContext, gl: WebGLContext, validateShaderPrograms?: boolean) {\r\n    const context = pipelineContext.context!;\r\n    const vertexShader = pipelineContext.vertexShader!;\r\n    const fragmentShader = pipelineContext.fragmentShader!;\r\n    const program = pipelineContext.program!;\r\n\r\n    const linked = context.getProgramParameter(program, context.LINK_STATUS);\r\n    if (!linked) {\r\n        // Get more info\r\n        // Vertex\r\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n            const log = gl.getShaderInfoLog(vertexShader);\r\n            if (log) {\r\n                pipelineContext.vertexCompilationError = log;\r\n                throw new Error(\"VERTEX SHADER \" + log);\r\n            }\r\n        }\r\n\r\n        // Fragment\r\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n            const log = gl.getShaderInfoLog(fragmentShader);\r\n            if (log) {\r\n                pipelineContext.fragmentCompilationError = log;\r\n                throw new Error(\"FRAGMENT SHADER \" + log);\r\n            }\r\n        }\r\n\r\n        const error = context.getProgramInfoLog(program);\r\n        if (error) {\r\n            pipelineContext.programLinkError = error;\r\n            throw new Error(error);\r\n        }\r\n    }\r\n\r\n    if (/*this.*/ validateShaderPrograms) {\r\n        context.validateProgram(program);\r\n        const validated = context.getProgramParameter(program, context.VALIDATE_STATUS);\r\n\r\n        if (!validated) {\r\n            const error = context.getProgramInfoLog(program);\r\n            if (error) {\r\n                pipelineContext.programValidationError = error;\r\n                throw new Error(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    context.deleteShader(vertexShader);\r\n    context.deleteShader(fragmentShader);\r\n\r\n    pipelineContext.vertexShader = undefined;\r\n    pipelineContext.fragmentShader = undefined;\r\n\r\n    if (pipelineContext.onCompiled) {\r\n        pipelineContext.onCompiled();\r\n        pipelineContext.onCompiled = undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _preparePipelineContext(\r\n    pipelineContext: IPipelineContext,\r\n    vertexSourceCode: string,\r\n    fragmentSourceCode: string,\r\n    createAsRaw: boolean,\r\n    _rawVertexSourceCode: string,\r\n    _rawFragmentSourceCode: string,\r\n    rebuildRebind: any,\r\n    defines: Nullable<string>,\r\n    transformFeedbackVaryings: Nullable<string[]>,\r\n    _key: string = \"\",\r\n    onReady: () => void,\r\n    createRawShaderProgramInjection?: typeof createRawShaderProgram,\r\n    createShaderProgramInjection?: typeof createShaderProgram\r\n) {\r\n    const stateObject = getStateObject((pipelineContext as WebGLPipelineContext).context!);\r\n    if (!createRawShaderProgramInjection) {\r\n        createRawShaderProgramInjection = stateObject.createRawShaderProgramInjection ?? createRawShaderProgram;\r\n    }\r\n    if (!createShaderProgramInjection) {\r\n        createShaderProgramInjection = stateObject.createShaderProgramInjection ?? createShaderProgram;\r\n    }\r\n    const webGLRenderingState = pipelineContext as WebGLPipelineContext;\r\n\r\n    if (createAsRaw) {\r\n        webGLRenderingState.program = createRawShaderProgramInjection(\r\n            webGLRenderingState,\r\n            vertexSourceCode,\r\n            fragmentSourceCode,\r\n            webGLRenderingState.context!,\r\n            transformFeedbackVaryings\r\n        );\r\n    } else {\r\n        webGLRenderingState.program = createShaderProgramInjection(\r\n            webGLRenderingState,\r\n            vertexSourceCode,\r\n            fragmentSourceCode,\r\n            defines,\r\n            webGLRenderingState.context!,\r\n            transformFeedbackVaryings\r\n        );\r\n    }\r\n    webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;\r\n\r\n    onReady();\r\n}\r\n\r\nfunction CompileShader(source: string, type: string, defines: Nullable<string>, shaderVersion: string, gl: WebGLContext, _contextWasLost?: boolean): WebGLShader {\r\n    return CompileRawShader(_ConcatenateShader(source, defines, shaderVersion), type, gl, _contextWasLost);\r\n}\r\n\r\nfunction CompileRawShader(source: string, type: string, gl: WebGLContext, _contextWasLost?: boolean): WebGLShader {\r\n    const shader = gl.createShader(type === \"vertex\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);\r\n\r\n    if (!shader) {\r\n        let error: GLenum = gl.NO_ERROR;\r\n        let tempError: GLenum = gl.NO_ERROR;\r\n        while ((tempError = gl.getError()) !== gl.NO_ERROR) {\r\n            error = tempError;\r\n        }\r\n\r\n        throw new Error(\r\n            `Something went wrong while creating a gl ${type} shader object. gl error=${error}, gl isContextLost=${gl.isContextLost()}, _contextWasLost=${_contextWasLost}`\r\n        );\r\n    }\r\n\r\n    gl.shaderSource(shader, source);\r\n    gl.compileShader(shader);\r\n\r\n    return shader;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _setProgram(program: Nullable<WebGLProgram>, gl: WebGLContext): void {\r\n    gl.useProgram(program);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: (pipelineContext?: IPipelineContext) => void) {\r\n    const webGLPipelineContext = pipelineContext as WebGLPipelineContext;\r\n\r\n    if (!webGLPipelineContext.isParallelCompiled) {\r\n        action(pipelineContext);\r\n        return;\r\n    }\r\n\r\n    const oldHandler = webGLPipelineContext.onCompiled;\r\n\r\n    webGLPipelineContext.onCompiled = () => {\r\n        oldHandler?.();\r\n        action(pipelineContext);\r\n    };\r\n}\r\n", "import type { _IProcessingOptions } from \"./shaderProcessingOptions\";\r\n\r\nconst DefaultAttributeKeywordName = \"attribute\";\r\nconst DefaultVaryingKeywordName = \"varying\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeNode {\r\n    line: string;\r\n    children: ShaderCodeNode[] = [];\r\n    additionalDefineKey?: string;\r\n    additionalDefineValue?: string;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    isValid(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    process(preprocessors: { [key: string]: string }, options: _IProcessingOptions, preProcessorsFromCode: { [key: string]: string }): string {\r\n        let result = \"\";\r\n        if (this.line) {\r\n            let value: string = this.line;\r\n            const processor = options.processor;\r\n            if (processor) {\r\n                // This must be done before other replacements to avoid mistakenly changing something that was already changed.\r\n                if (processor.lineProcessor) {\r\n                    value = processor.lineProcessor(value, options.isFragment, options.processingContext);\r\n                }\r\n\r\n                const attributeKeyword = options.processor?.attributeKeywordName ?? DefaultAttributeKeywordName;\r\n                const varyingKeyword =\r\n                    options.isFragment && options.processor?.varyingFragmentKeywordName\r\n                        ? options.processor?.varyingFragmentKeywordName\r\n                        : !options.isFragment && options.processor?.varyingVertexKeywordName\r\n                          ? options.processor?.varyingVertexKeywordName\r\n                          : DefaultVaryingKeywordName;\r\n\r\n                if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {\r\n                    value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\r\n                } else if (\r\n                    processor.varyingProcessor &&\r\n                    (processor.varyingCheck?.(this.line, options.isFragment) || (!processor.varyingCheck && this.line.startsWith(varyingKeyword)))\r\n                ) {\r\n                    value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                    }\r\n                } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                        options.lookForClosingBracketForUniformBuffer = true;\r\n                    }\r\n                } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\r\n                    value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith(\"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\r\n                    const regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\r\n\r\n                    if (regex.test(this.line)) {\r\n                        // uniform\r\n                        if (processor.uniformProcessor) {\r\n                            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                        }\r\n                    } else {\r\n                        // Uniform buffer\r\n                        if (processor.uniformBufferProcessor) {\r\n                            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                            options.lookForClosingBracketForUniformBuffer = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\r\n                    options.lookForClosingBracketForUniformBuffer = false;\r\n                    if (processor.endOfUniformBufferProcessor) {\r\n                        value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result += value + \"\\n\";\r\n        }\r\n\r\n        for (const child of this.children) {\r\n            result += child.process(preprocessors, options, preProcessorsFromCode);\r\n        }\r\n\r\n        if (this.additionalDefineKey) {\r\n            preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\r\n            preProcessorsFromCode[this.additionalDefineKey] = preprocessors[this.additionalDefineKey];\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n", "/** @internal */\r\nexport class ShaderCodeCursor {\r\n    private _lines: string[] = [];\r\n    lineIndex: number;\r\n\r\n    get currentLine(): string {\r\n        return this._lines[this.lineIndex];\r\n    }\r\n\r\n    get canRead(): boolean {\r\n        return this.lineIndex < this._lines.length - 1;\r\n    }\r\n\r\n    set lines(value: string[]) {\r\n        this._lines.length = 0;\r\n\r\n        for (const line of value) {\r\n            // Skip empty lines\r\n            if (!line || line === \"\\r\") {\r\n                continue;\r\n            }\r\n\r\n            // Prevent removing line break in macros.\r\n            if (line[0] === \"#\") {\r\n                this._lines.push(line);\r\n                continue;\r\n            }\r\n\r\n            // Do not split single line comments\r\n            const trimmedLine = line.trim();\r\n\r\n            if (!trimmedLine) {\r\n                continue;\r\n            }\r\n\r\n            if (trimmedLine.startsWith(\"//\")) {\r\n                this._lines.push(line);\r\n                continue;\r\n            }\r\n\r\n            // Work with semicolon in the line\r\n            const semicolonIndex = trimmedLine.indexOf(\";\");\r\n\r\n            if (semicolonIndex === -1) {\r\n                // No semicolon in the line\r\n                this._lines.push(trimmedLine);\r\n            } else if (semicolonIndex === trimmedLine.length - 1) {\r\n                // Single semicolon at the end of the line\r\n                // If trimmedLine == \";\", we must not push, to be backward compatible with the old code!\r\n                if (trimmedLine.length > 1) {\r\n                    this._lines.push(trimmedLine);\r\n                }\r\n            } else {\r\n                // Semicolon in the middle of the line\r\n                const split = line.split(\";\");\r\n\r\n                for (let index = 0; index < split.length; index++) {\r\n                    let subLine = split[index];\r\n\r\n                    if (!subLine) {\r\n                        continue;\r\n                    }\r\n\r\n                    subLine = subLine.trim();\r\n\r\n                    if (!subLine) {\r\n                        continue;\r\n                    }\r\n\r\n                    this._lines.push(subLine + (index !== split.length - 1 ? \";\" : \"\"));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport type { _IProcessingOptions } from \"./shaderProcessingOptions\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeConditionNode extends ShaderCodeNode {\r\n    override process(preprocessors: { [key: string]: string }, options: _IProcessingOptions, preProcessorsFromCode: { [key: string]: string }) {\r\n        for (let index = 0; index < this.children.length; index++) {\r\n            const node = this.children[index];\r\n\r\n            if (node.isValid(preprocessors)) {\r\n                return node.process(preprocessors, options, preProcessorsFromCode);\r\n            }\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n}\r\n", "import { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport type { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeTestNode extends ShaderCodeNode {\r\n    public testExpression: ShaderDefineExpression;\r\n\r\n    public override isValid(preprocessors: { [key: string]: string }) {\r\n        return this.testExpression.isTrue(preprocessors);\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/** @internal */\r\nexport class ShaderDefineExpression {\r\n    /**\r\n     * Cache items count limit for the InfixToPostfix cache.\r\n     * It uses to improve the performance of the shader compilation.\r\n     * For details see PR: https://github.com/BabylonJS/Babylon.js/pull/13936\r\n     */\r\n    static InfixToPostfixCacheLimitSize = 50000;\r\n\r\n    /**\r\n     * When the cache size is exceeded, a cache cleanup will be triggered\r\n     * and the cache will be reduced by the size specified\r\n     * in the InfixToPostfixCacheCleanupSize variable, removing entries\r\n     * that have not been accessed the longest.\r\n     */\r\n    static InfixToPostfixCacheCleanupSize = 25000;\r\n\r\n    protected static _InfixToPostfixCache: Map<\r\n        string,\r\n        {\r\n            accessTime: number;\r\n            result: string[];\r\n        }\r\n    > = new Map();\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    private static _OperatorPriority: { [name: string]: number } = {\r\n        \")\": 0,\r\n        \"(\": 1,\r\n        \"||\": 2,\r\n        \"&&\": 3,\r\n    };\r\n\r\n    private static _Stack = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];\r\n\r\n    public static postfixToInfix(postfix: string[]): string {\r\n        const stack: string[] = [];\r\n\r\n        for (const c of postfix) {\r\n            if (ShaderDefineExpression._OperatorPriority[c] === undefined) {\r\n                stack.push(c);\r\n            } else {\r\n                const v1 = stack[stack.length - 1],\r\n                    v2 = stack[stack.length - 2];\r\n\r\n                stack.length -= 2;\r\n                stack.push(`(${v2}${c}${v1})`);\r\n            }\r\n        }\r\n\r\n        return stack[stack.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Converts an infix expression to a postfix expression.\r\n     *\r\n     * This method is used to transform infix expressions, which are more human-readable,\r\n     * into postfix expressions, also known as Reverse Polish Notation (RPN), that can be\r\n     * evaluated more efficiently by a computer. The conversion is based on the operator\r\n     * priority defined in _OperatorPriority.\r\n     *\r\n     * The function employs a stack-based algorithm for the conversion and caches the result\r\n     * to improve performance. The cache keeps track of each converted expression's access time\r\n     * to manage the cache size and optimize memory usage. When the cache size exceeds a specified\r\n     * limit, the least recently accessed items in the cache are deleted.\r\n     *\r\n     * The cache mechanism is particularly helpful for shader compilation, where the same infix\r\n     * expressions might be encountered repeatedly, hence the caching can speed up the process.\r\n     *\r\n     * @param infix - The infix expression to be converted.\r\n     * @returns The postfix expression as an array of strings.\r\n     */\r\n    public static infixToPostfix(infix: string): string[] {\r\n        // Is infix already in cache\r\n        const cacheItem = ShaderDefineExpression._InfixToPostfixCache.get(infix);\r\n        if (cacheItem) {\r\n            cacheItem.accessTime = Date.now();\r\n            return cacheItem.result;\r\n        }\r\n\r\n        // Is infix contain any operator\r\n        if (!infix.includes(\"&&\") && !infix.includes(\"||\") && !infix.includes(\")\") && !infix.includes(\"(\")) {\r\n            return [infix];\r\n        }\r\n\r\n        const result: string[] = [];\r\n\r\n        let stackIdx = -1;\r\n\r\n        const pushOperand = () => {\r\n            operand = operand.trim();\r\n            if (operand !== \"\") {\r\n                result.push(operand);\r\n                operand = \"\";\r\n            }\r\n        };\r\n\r\n        const push = (s: string) => {\r\n            if (stackIdx < ShaderDefineExpression._Stack.length - 1) {\r\n                ShaderDefineExpression._Stack[++stackIdx] = s;\r\n            }\r\n        };\r\n\r\n        const peek = () => ShaderDefineExpression._Stack[stackIdx];\r\n\r\n        const pop = () => (stackIdx === -1 ? \"!!INVALID EXPRESSION!!\" : ShaderDefineExpression._Stack[stackIdx--]);\r\n\r\n        let idx = 0,\r\n            operand = \"\";\r\n\r\n        while (idx < infix.length) {\r\n            const c = infix.charAt(idx),\r\n                token = idx < infix.length - 1 ? infix.substring(idx, 2 + idx) : \"\";\r\n\r\n            if (c === \"(\") {\r\n                operand = \"\";\r\n                push(c);\r\n            } else if (c === \")\") {\r\n                pushOperand();\r\n                while (stackIdx !== -1 && peek() !== \"(\") {\r\n                    result.push(pop());\r\n                }\r\n                pop();\r\n            } else if (ShaderDefineExpression._OperatorPriority[token] > 1) {\r\n                pushOperand();\r\n                while (stackIdx !== -1 && ShaderDefineExpression._OperatorPriority[peek()] >= ShaderDefineExpression._OperatorPriority[token]) {\r\n                    result.push(pop());\r\n                }\r\n                push(token);\r\n                idx++;\r\n            } else {\r\n                operand += c;\r\n            }\r\n            idx++;\r\n        }\r\n\r\n        pushOperand();\r\n\r\n        while (stackIdx !== -1) {\r\n            if (peek() === \"(\") {\r\n                pop();\r\n            } else {\r\n                result.push(pop());\r\n            }\r\n        }\r\n\r\n        // If the cache is at capacity, clear it before adding a new item\r\n        if (ShaderDefineExpression._InfixToPostfixCache.size >= ShaderDefineExpression.InfixToPostfixCacheLimitSize) {\r\n            ShaderDefineExpression.ClearCache();\r\n        }\r\n\r\n        // Add the new item to the cache, including the current time as the last access time\r\n        ShaderDefineExpression._InfixToPostfixCache.set(infix, { result, accessTime: Date.now() });\r\n\r\n        return result;\r\n    }\r\n\r\n    private static ClearCache(): void {\r\n        // Convert the cache to an array and sort by last access time\r\n        const sortedCache = Array.from(ShaderDefineExpression._InfixToPostfixCache.entries()).sort((a, b) => a[1].accessTime - b[1].accessTime);\r\n\r\n        // Remove the least recently accessed half of the cache\r\n        for (let i = 0; i < ShaderDefineExpression.InfixToPostfixCacheCleanupSize; i++) {\r\n            ShaderDefineExpression._InfixToPostfixCache.delete(sortedCache[i][0]);\r\n        }\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineIsDefinedOperator extends ShaderDefineExpression {\r\n    public constructor(\r\n        public define: string,\r\n        public not: boolean = false\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }) {\r\n        let condition = preprocessors[this.define] !== undefined;\r\n\r\n        if (this.not) {\r\n            condition = !condition;\r\n        }\r\n\r\n        return condition;\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineOrOperator extends ShaderDefineExpression {\r\n    public leftOperand: ShaderDefineExpression;\r\n    public rightOperand: ShaderDefineExpression;\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return this.leftOperand.isTrue(preprocessors) || this.rightOperand.isTrue(preprocessors);\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineAndOperator extends ShaderDefineExpression {\r\n    public leftOperand: ShaderDefineExpression;\r\n    public rightOperand: ShaderDefineExpression;\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }): boolean {\r\n        return this.leftOperand.isTrue(preprocessors) && this.rightOperand.isTrue(preprocessors);\r\n    }\r\n}\r\n", "import { ShaderDefineExpression } from \"../shaderDefineExpression\";\r\n\r\n/** @internal */\r\nexport class ShaderDefineArithmeticOperator extends ShaderDefineExpression {\r\n    public constructor(\r\n        public define: string,\r\n        public operand: string,\r\n        public testValue: string\r\n    ) {\r\n        super();\r\n    }\r\n\r\n    public override toString() {\r\n        return `${this.define} ${this.operand} ${this.testValue}`;\r\n    }\r\n\r\n    public override isTrue(preprocessors: { [key: string]: string }) {\r\n        let condition = false;\r\n\r\n        const left = parseInt(preprocessors[this.define] != undefined ? preprocessors[this.define] : this.define);\r\n        const right = parseInt(preprocessors[this.testValue] != undefined ? preprocessors[this.testValue] : this.testValue);\r\n\r\n        if (isNaN(left) || isNaN(right)) {\r\n            // We can't evaluate the expression because we can't resolve the left and/or right side\r\n            // We should not throw an error here because the code might be using a define that is not defined in the material/shader!\r\n            return false;\r\n        }\r\n\r\n        switch (this.operand) {\r\n            case \">\":\r\n                condition = left > right;\r\n                break;\r\n            case \"<\":\r\n                condition = left < right;\r\n                break;\r\n            case \"<=\":\r\n                condition = left <= right;\r\n                break;\r\n            case \">=\":\r\n                condition = left >= right;\r\n                break;\r\n            case \"==\":\r\n                condition = left === right;\r\n                break;\r\n            case \"!=\":\r\n                condition = left !== right;\r\n                break;\r\n        }\r\n\r\n        return condition;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport { ShaderCodeCursor } from \"./shaderCodeCursor\";\r\nimport { ShaderCodeConditionNode } from \"./shaderCodeConditionNode\";\r\nimport { ShaderCodeTestNode } from \"./shaderCodeTestNode\";\r\nimport { ShaderDefineIsDefinedOperator } from \"./Expressions/Operators/shaderDefineIsDefinedOperator\";\r\nimport { ShaderDefineOrOperator } from \"./Expressions/Operators/shaderDefineOrOperator\";\r\nimport { ShaderDefineAndOperator } from \"./Expressions/Operators/shaderDefineAndOperator\";\r\nimport { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression\";\r\nimport { ShaderDefineArithmeticOperator } from \"./Expressions/Operators/shaderDefineArithmeticOperator\";\r\nimport type { _IProcessingOptions } from \"./shaderProcessingOptions\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\nimport type { WebRequest } from \"../../Misc/webRequest\";\r\nimport type { LoadFileError } from \"../../Misc/fileTools\";\r\nimport type { IOfflineProvider } from \"../../Offline/IOfflineProvider\";\r\nimport type { IFileRequest } from \"../../Misc/fileRequest\";\r\nimport { _GetGlobalDefines } from \"../abstractEngine.functions\";\r\nimport type { AbstractEngine } from \"../abstractEngine\";\r\n\r\nconst RegexSe = /defined\\s*?\\((.+?)\\)/g;\r\nconst RegexSeRevert = /defined\\s*?\\[(.+?)\\]/g;\r\nconst RegexShaderInclude = /#include\\s?<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\r\nconst RegexShaderDecl = /__decl__/;\r\nconst RegexLightX = /light\\{X\\}.(\\w*)/g;\r\nconst RegexX = /\\{X\\}/g;\r\nconst ReusableMatches: RegExpMatchArray[] = [];\r\n\r\nconst MoveCursorRegex = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\r\n\r\n/** @internal */\r\nexport function Initialize(options: _IProcessingOptions): void {\r\n    if (options.processor && options.processor.initializeShaders) {\r\n        options.processor.initializeShaders(options.processingContext);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function Process(sourceCode: string, options: _IProcessingOptions, callback: (migratedCode: string, codeBeforeMigration: string) => void, engine?: AbstractEngine) {\r\n    if (options.processor?.preProcessShaderCode) {\r\n        sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n    }\r\n    ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n        if (options.processCodeAfterIncludes) {\r\n            codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes, options.defines);\r\n        }\r\n        const migratedCode = ProcessShaderConversion(codeWithIncludes, options, engine);\r\n        callback(migratedCode, codeWithIncludes);\r\n    });\r\n}\r\n\r\n/** @internal */\r\nexport function PreProcess(sourceCode: string, options: _IProcessingOptions, callback: (migratedCode: string, codeBeforeMigration: string) => void, engine: AbstractEngine) {\r\n    if (options.processor?.preProcessShaderCode) {\r\n        sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n    }\r\n    ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n        if (options.processCodeAfterIncludes) {\r\n            codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes, options.defines);\r\n        }\r\n        const migratedCode = ApplyPreProcessing(codeWithIncludes, options, engine);\r\n        callback(migratedCode, codeWithIncludes);\r\n    });\r\n}\r\n\r\n/** @internal */\r\nexport function Finalize(vertexCode: string, fragmentCode: string, options: _IProcessingOptions): { vertexCode: string; fragmentCode: string } {\r\n    if (!options.processor || !options.processor.finalizeShaders) {\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n\r\n    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);\r\n}\r\n\r\nfunction ProcessPrecision(source: string, options: _IProcessingOptions): string {\r\n    if (options.processor?.noPrecision) {\r\n        return source;\r\n    }\r\n\r\n    const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\r\n\r\n    if (source.indexOf(\"precision highp float\") === -1) {\r\n        if (!shouldUseHighPrecisionShader) {\r\n            source = \"precision mediump float;\\n\" + source;\r\n        } else {\r\n            source = \"precision highp float;\\n\" + source;\r\n        }\r\n    } else {\r\n        if (!shouldUseHighPrecisionShader) {\r\n            // Moving highp to mediump\r\n            source = source.replace(\"precision highp float\", \"precision mediump float\");\r\n        }\r\n    }\r\n\r\n    return source;\r\n}\r\n\r\nfunction ExtractOperation(expression: string) {\r\n    const regex = /defined\\((.+)\\)/;\r\n\r\n    const match = regex.exec(expression);\r\n\r\n    if (match && match.length) {\r\n        return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\r\n    }\r\n\r\n    const operators = [\"==\", \"!=\", \">=\", \"<=\", \"<\", \">\"];\r\n    let operator = \"\";\r\n    let indexOperator = 0;\r\n\r\n    for (operator of operators) {\r\n        indexOperator = expression.indexOf(operator);\r\n\r\n        if (indexOperator > -1) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (indexOperator === -1) {\r\n        return new ShaderDefineIsDefinedOperator(expression);\r\n    }\r\n\r\n    const define = expression.substring(0, indexOperator).trim();\r\n    const value = expression.substring(indexOperator + operator.length).trim();\r\n\r\n    return new ShaderDefineArithmeticOperator(define, operator, value);\r\n}\r\n\r\nfunction BuildSubExpression(expression: string): ShaderDefineExpression {\r\n    expression = expression.replace(RegexSe, \"defined[$1]\");\r\n\r\n    const postfix = ShaderDefineExpression.infixToPostfix(expression);\r\n\r\n    const stack: (string | ShaderDefineExpression)[] = [];\r\n\r\n    for (const c of postfix) {\r\n        if (c !== \"||\" && c !== \"&&\") {\r\n            stack.push(c);\r\n        } else if (stack.length >= 2) {\r\n            let v1 = stack[stack.length - 1],\r\n                v2 = stack[stack.length - 2];\r\n\r\n            stack.length -= 2;\r\n\r\n            const operator = c == \"&&\" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\r\n\r\n            if (typeof v1 === \"string\") {\r\n                v1 = v1.replace(RegexSeRevert, \"defined($1)\");\r\n            }\r\n\r\n            if (typeof v2 === \"string\") {\r\n                v2 = v2.replace(RegexSeRevert, \"defined($1)\");\r\n            }\r\n\r\n            operator.leftOperand = typeof v2 === \"string\" ? ExtractOperation(v2) : v2;\r\n            operator.rightOperand = typeof v1 === \"string\" ? ExtractOperation(v1) : v1;\r\n\r\n            stack.push(operator);\r\n        }\r\n    }\r\n\r\n    let result = stack[stack.length - 1];\r\n\r\n    if (typeof result === \"string\") {\r\n        result = result.replace(RegexSeRevert, \"defined($1)\");\r\n    }\r\n\r\n    // note: stack.length !== 1 if there was an error in the parsing\r\n\r\n    return typeof result === \"string\" ? ExtractOperation(result) : result;\r\n}\r\n\r\nfunction BuildExpression(line: string, start: number): ShaderCodeTestNode {\r\n    const node = new ShaderCodeTestNode();\r\n    const command = line.substring(0, start);\r\n    let expression = line.substring(start);\r\n\r\n    expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\r\n\r\n    if (command === \"#ifdef\") {\r\n        node.testExpression = new ShaderDefineIsDefinedOperator(expression);\r\n    } else if (command === \"#ifndef\") {\r\n        node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\r\n    } else {\r\n        node.testExpression = BuildSubExpression(expression);\r\n    }\r\n\r\n    return node;\r\n}\r\n\r\nfunction MoveCursorWithinIf(cursor: ShaderCodeCursor, rootNode: ShaderCodeConditionNode, ifNode: ShaderCodeNode, preProcessorsFromCode: { [key: string]: string }) {\r\n    let line = cursor.currentLine;\r\n    while (MoveCursor(cursor, ifNode, preProcessorsFromCode)) {\r\n        line = cursor.currentLine;\r\n        const first5 = line.substring(0, 5).toLowerCase();\r\n\r\n        if (first5 === \"#else\") {\r\n            const elseNode = new ShaderCodeNode();\r\n            rootNode.children.push(elseNode);\r\n            MoveCursor(cursor, elseNode, preProcessorsFromCode);\r\n            return;\r\n        } else if (first5 === \"#elif\") {\r\n            const elifNode = BuildExpression(line, 5);\r\n\r\n            rootNode.children.push(elifNode);\r\n            ifNode = elifNode;\r\n        }\r\n    }\r\n}\r\n\r\nfunction MoveCursor(cursor: ShaderCodeCursor, rootNode: ShaderCodeNode, preProcessorsFromCode: { [key: string]: string }): boolean {\r\n    while (cursor.canRead) {\r\n        cursor.lineIndex++;\r\n        const line = cursor.currentLine;\r\n\r\n        if (line.indexOf(\"#\") >= 0) {\r\n            const matches = MoveCursorRegex.exec(line);\r\n\r\n            if (matches && matches.length) {\r\n                const keyword = matches[0];\r\n\r\n                switch (keyword) {\r\n                    case \"#ifdef\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        const ifNode = BuildExpression(line, 6);\r\n                        newRootNode.children.push(ifNode);\r\n                        MoveCursorWithinIf(cursor, newRootNode, ifNode, preProcessorsFromCode);\r\n                        break;\r\n                    }\r\n                    case \"#else\":\r\n                    case \"#elif\":\r\n                        return true;\r\n                    case \"#endif\":\r\n                        return false;\r\n                    case \"#ifndef\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        const ifNode = BuildExpression(line, 7);\r\n                        newRootNode.children.push(ifNode);\r\n                        MoveCursorWithinIf(cursor, newRootNode, ifNode, preProcessorsFromCode);\r\n                        break;\r\n                    }\r\n                    case \"#if\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        const ifNode = BuildExpression(line, 3);\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        newRootNode.children.push(ifNode);\r\n                        MoveCursorWithinIf(cursor, newRootNode, ifNode, preProcessorsFromCode);\r\n                        break;\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n\r\n        const newNode = new ShaderCodeNode();\r\n        newNode.line = line;\r\n        rootNode.children.push(newNode);\r\n\r\n        // Detect additional defines\r\n        if (line[0] === \"#\" && line[1] === \"d\") {\r\n            const split = line.replace(\";\", \"\").split(\" \");\r\n            newNode.additionalDefineKey = split[1];\r\n\r\n            if (split.length === 3) {\r\n                newNode.additionalDefineValue = split[2];\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction EvaluatePreProcessors(\r\n    sourceCode: string,\r\n    preprocessors: { [key: string]: string },\r\n    options: _IProcessingOptions,\r\n    preProcessorsFromCode: { [key: string]: string }\r\n): string {\r\n    const rootNode = new ShaderCodeNode();\r\n    const cursor = new ShaderCodeCursor();\r\n\r\n    cursor.lineIndex = -1;\r\n    cursor.lines = sourceCode.split(\"\\n\");\r\n\r\n    // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\r\n    MoveCursor(cursor, rootNode, preProcessorsFromCode);\r\n\r\n    // Recompose\r\n    return rootNode.process(preprocessors, options, preProcessorsFromCode);\r\n}\r\n\r\nfunction PreparePreProcessors(options: _IProcessingOptions, engine?: AbstractEngine): { [key: string]: string } {\r\n    const defines = options.defines;\r\n    const preprocessors: { [key: string]: string } = {};\r\n\r\n    for (const define of defines) {\r\n        const keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\r\n        const split = keyValue.split(\" \");\r\n        preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\r\n    }\r\n\r\n    if (options.processor?.shaderLanguage === ShaderLanguage.GLSL) {\r\n        preprocessors[\"GL_ES\"] = \"true\";\r\n    }\r\n    preprocessors[\"__VERSION__\"] = options.version;\r\n    preprocessors[options.platformName] = \"true\";\r\n\r\n    _GetGlobalDefines(preprocessors, engine?.isNDCHalfZRange, engine?.useReverseDepthBuffer, engine?.useExactSrgbConversions);\r\n\r\n    return preprocessors;\r\n}\r\n\r\nfunction ProcessShaderConversion(sourceCode: string, options: _IProcessingOptions, engine?: AbstractEngine): string {\r\n    let preparedSourceCode = ProcessPrecision(sourceCode, options);\r\n\r\n    if (!options.processor) {\r\n        return preparedSourceCode;\r\n    }\r\n\r\n    // Already converted\r\n    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf(\"#version 3\") !== -1) {\r\n        preparedSourceCode = preparedSourceCode.replace(\"#version 300 es\", \"\");\r\n        if (!options.processor.parseGLES3) {\r\n            return preparedSourceCode;\r\n        }\r\n    }\r\n\r\n    const defines = options.defines;\r\n\r\n    const preprocessors = PreparePreProcessors(options, engine);\r\n\r\n    // General pre processing\r\n    if (options.processor.preProcessor) {\r\n        preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, preprocessors, options.isFragment, options.processingContext);\r\n    }\r\n\r\n    const preProcessorsFromCode: { [key: string]: string } = {};\r\n\r\n    preparedSourceCode = EvaluatePreProcessors(preparedSourceCode, preprocessors, options, preProcessorsFromCode);\r\n\r\n    // Post processing\r\n    if (options.processor.postProcessor) {\r\n        preparedSourceCode = options.processor.postProcessor(\r\n            preparedSourceCode,\r\n            defines,\r\n            options.isFragment,\r\n            options.processingContext,\r\n            engine\r\n                ? {\r\n                      drawBuffersExtensionDisabled: engine.getCaps().drawBuffersExtension ? false : true,\r\n                  }\r\n                : {},\r\n            preprocessors,\r\n            preProcessorsFromCode\r\n        );\r\n    }\r\n\r\n    // Inline functions tagged with #define inline\r\n    if (engine?._features.needShaderCodeInlining) {\r\n        preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n    }\r\n\r\n    return preparedSourceCode;\r\n}\r\n\r\nfunction ApplyPreProcessing(sourceCode: string, options: _IProcessingOptions, engine: AbstractEngine): string {\r\n    let preparedSourceCode = sourceCode;\r\n\r\n    const defines = options.defines;\r\n\r\n    const preprocessors = PreparePreProcessors(options, engine);\r\n\r\n    // General pre processing\r\n    if (options.processor?.preProcessor) {\r\n        preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, preprocessors, options.isFragment, options.processingContext);\r\n    }\r\n\r\n    const preProcessorsFromCode: { [key: string]: string } = {};\r\n\r\n    preparedSourceCode = EvaluatePreProcessors(preparedSourceCode, preprocessors, options, preProcessorsFromCode);\r\n\r\n    // Post processing\r\n    if (options.processor?.postProcessor) {\r\n        preparedSourceCode = options.processor.postProcessor(\r\n            preparedSourceCode,\r\n            defines,\r\n            options.isFragment,\r\n            options.processingContext,\r\n            engine\r\n                ? {\r\n                      drawBuffersExtensionDisabled: engine.getCaps().drawBuffersExtension ? false : true,\r\n                  }\r\n                : {},\r\n            preprocessors,\r\n            preProcessorsFromCode\r\n        );\r\n    }\r\n\r\n    // Inline functions tagged with #define inline\r\n    if (engine._features.needShaderCodeInlining) {\r\n        preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n    }\r\n\r\n    return preparedSourceCode;\r\n}\r\n\r\n/** @internal */\r\nexport function ProcessIncludes(sourceCode: string, options: _IProcessingOptions, callback: (data: any) => void): void {\r\n    ReusableMatches.length = 0;\r\n    let match: RegExpMatchArray | null;\r\n    // stay back-compat to the old matchAll syntax\r\n    while ((match = RegexShaderInclude.exec(sourceCode)) !== null) {\r\n        ReusableMatches.push(match);\r\n    }\r\n\r\n    let returnValue = String(sourceCode);\r\n    let parts = [sourceCode];\r\n\r\n    let keepProcessing = false;\r\n\r\n    for (const match of ReusableMatches) {\r\n        let includeFile = match[1];\r\n\r\n        // Uniform declaration\r\n        if (includeFile.indexOf(\"__decl__\") !== -1) {\r\n            includeFile = includeFile.replace(RegexShaderDecl, \"\");\r\n            if (options.supportsUniformBuffers) {\r\n                includeFile = includeFile.replace(\"Vertex\", \"Ubo\").replace(\"Fragment\", \"Ubo\");\r\n            }\r\n            includeFile = includeFile + \"Declaration\";\r\n        }\r\n\r\n        if (options.includesShadersStore[includeFile]) {\r\n            // Substitution\r\n            let includeContent = options.includesShadersStore[includeFile];\r\n            if (match[2]) {\r\n                const splits = match[3].split(\",\");\r\n\r\n                for (let index = 0; index < splits.length; index += 2) {\r\n                    const source = new RegExp(splits[index], \"g\");\r\n                    const dest = splits[index + 1];\r\n\r\n                    includeContent = includeContent.replace(source, dest);\r\n                }\r\n            }\r\n\r\n            if (match[4]) {\r\n                const indexString = match[5];\r\n\r\n                if (indexString.indexOf(\"..\") !== -1) {\r\n                    const indexSplits = indexString.split(\"..\");\r\n                    const minIndex = parseInt(indexSplits[0]);\r\n                    let maxIndex = parseInt(indexSplits[1]);\r\n                    let sourceIncludeContent = includeContent.slice(0);\r\n                    includeContent = \"\";\r\n\r\n                    if (isNaN(maxIndex)) {\r\n                        maxIndex = options.indexParameters[indexSplits[1]];\r\n                    }\r\n\r\n                    for (let i = minIndex; i < maxIndex; i++) {\r\n                        if (!options.supportsUniformBuffers) {\r\n                            // Ubo replacement\r\n                            sourceIncludeContent = sourceIncludeContent.replace(RegexLightX, (str: string, p1: string) => {\r\n                                return p1 + \"{X}\";\r\n                            });\r\n                        }\r\n                        includeContent += sourceIncludeContent.replace(RegexX, i.toString()) + \"\\n\";\r\n                    }\r\n                } else {\r\n                    if (!options.supportsUniformBuffers) {\r\n                        // Ubo replacement\r\n                        includeContent = includeContent.replace(RegexLightX, (str: string, p1: string) => {\r\n                            return p1 + \"{X}\";\r\n                        });\r\n                    }\r\n                    includeContent = includeContent.replace(RegexX, indexString);\r\n                }\r\n            }\r\n\r\n            // Replace\r\n            // Split all parts on match[0] and intersperse the parts with the include content\r\n            const newParts = [];\r\n            for (const part of parts) {\r\n                const splitPart = part.split(match[0]);\r\n                for (let i = 0; i < splitPart.length - 1; i++) {\r\n                    newParts.push(splitPart[i]);\r\n                    newParts.push(includeContent);\r\n                }\r\n                newParts.push(splitPart[splitPart.length - 1]);\r\n            }\r\n            parts = newParts;\r\n\r\n            keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0 || includeContent.indexOf(\"#include <\") >= 0;\r\n        } else {\r\n            const includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\r\n\r\n            _FunctionContainer.loadFile(includeShaderUrl, (fileContent) => {\r\n                options.includesShadersStore[includeFile] = fileContent as string;\r\n                ProcessIncludes(parts.join(\"\"), options, callback);\r\n            });\r\n            return;\r\n        }\r\n    }\r\n    ReusableMatches.length = 0;\r\n\r\n    returnValue = parts.join(\"\");\r\n\r\n    if (keepProcessing) {\r\n        ProcessIncludes(returnValue.toString(), options, callback);\r\n    } else {\r\n        callback(returnValue);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport const _FunctionContainer = {\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    loadFile: (\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest => {\r\n        throw _WarnImport(\"FileTools\");\r\n    },\r\n};\r\n", "import type { _IProcessingOptions, ShaderCustomProcessingFunction, _IShaderProcessingContext } from \"core/Engines/Processors/shaderProcessingOptions\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"core/Misc/domManagement\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { WebGLContext } from \"core/Engines/thinEngine.functions\";\r\nimport { getStateObject } from \"core/Engines/thinEngine.functions\";\r\nimport { ShaderStore } from \"core/Engines/shaderStore\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { Effect, IShaderPath } from \"./effect\";\r\nimport type { IPipelineContext } from \"core/Engines/IPipelineContext\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { Finalize, Initialize, Process } from \"core/Engines/Processors/shaderProcessor\";\r\nimport { _LoadFile } from \"core/Engines/abstractEngine.functions\";\r\nimport type { WebGLPipelineContext } from \"core/Engines/WebGL/webGLPipelineContext\";\r\n\r\n/**\r\n * Options to be used when creating a pipeline\r\n */\r\nexport interface IPipelineGenerationOptions {\r\n    /**\r\n     * The definition of the shader content.\r\n     * Can be either a unified name, name per vertex and frament or the shader code content itself\r\n     */\r\n    shaderNameOrContent: string | IShaderPath;\r\n    /**\r\n     * Unique key to identify the pipeline.\r\n     * Note that though not mandatory, it's recommended to provide a key to be able to use the automated pipeline loading system.\r\n     */\r\n    key?: string;\r\n    /**\r\n     * The list of defines to be used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * If true, the global defines will be added to the defines array\r\n     */\r\n    addGlobalDefines?: boolean;\r\n    /**\r\n     * The shader language.\r\n     * Defaults to the language suiting the platform name (GLSL for WEBGL2, WGSL for WEBGPU)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n\r\n    /**\r\n     * The name of the platform to be used when processing the shader\r\n     * defaults to WEBGL2\r\n     */\r\n    platformName?: string /* \"WEBGL2\" | \"WEBGL1\" | \"WEBGPU\" */;\r\n\r\n    /**\r\n     * extend the processing options when running code processing\r\n     */\r\n    extendedProcessingOptions?: Partial<_IProcessingOptions>;\r\n\r\n    /**\r\n     * extend the pipeline generation options\r\n     */\r\n    extendedCreatePipelineOptions?: Partial<ICreateAndPreparePipelineContextOptions>;\r\n\r\n    /**\r\n     * If true, generating a new pipeline will return when the pipeline is ready to be used\r\n     */\r\n    waitForIsReady?: boolean;\r\n\r\n    /**\r\n     * If true, the pipeline will be created synchronously, even if parallel shader compilation is available\r\n     */\r\n    disableParallelCompilation?: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport interface ICreateAndPreparePipelineContextOptions {\r\n    parallelShaderCompile?: { COMPLETION_STATUS_KHR: number };\r\n    shaderProcessingContext: Nullable<_IShaderProcessingContext>;\r\n    existingPipelineContext?: Nullable<IPipelineContext>;\r\n    name?: string;\r\n    rebuildRebind?: (vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) => void;\r\n    onRenderingStateCompiled?: (pipelineContext?: IPipelineContext) => void;\r\n    context?: WebGL2RenderingContext | WebGLRenderingContext;\r\n    // preparePipeline options\r\n    createAsRaw?: boolean;\r\n    vertex: string;\r\n    fragment: string;\r\n    defines: Nullable<string>;\r\n    transformFeedbackVaryings: Nullable<string[]>;\r\n    disableParallelCompilation?: boolean;\r\n}\r\n\r\n/**\r\n * Get a cached pipeline context\r\n * @param name the pipeline name\r\n * @param context the context to be used when creating the pipeline\r\n * @returns the cached pipeline context if it exists\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getCachedPipeline(name: string, context: WebGLContext): IPipelineContext | undefined {\r\n    const stateObject = getStateObject(context);\r\n    return stateObject.cachedPipelines[name];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function resetCachedPipeline(pipeline: IPipelineContext): void {\r\n    const name = pipeline._name;\r\n    const context = (pipeline as WebGLPipelineContext).context;\r\n    if (name && context) {\r\n        const stateObject = getStateObject(context);\r\n        const cachedPipeline = stateObject.cachedPipelines[name];\r\n        cachedPipeline?.dispose();\r\n        delete stateObject.cachedPipelines[name];\r\n    }\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function _ProcessShaderCode(\r\n    processorOptions: _IProcessingOptions,\r\n    baseName: any,\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>,\r\n    onFinalCodeReady?: (vertexCode: string, fragmentCode: string) => void,\r\n    shaderLanguage?: ShaderLanguage,\r\n    engine?: AbstractEngine,\r\n    effectContext?: Effect\r\n) {\r\n    let vertexSource: string | HTMLElement | IShaderPath;\r\n    let fragmentSource: string | HTMLElement | IShaderPath;\r\n\r\n    // const baseName = this.name;\r\n    const hostDocument = IsWindowObjectExist() ? engine?.getHostDocument() : null;\r\n\r\n    if (typeof baseName === \"string\") {\r\n        vertexSource = baseName;\r\n    } else if (baseName.vertexSource) {\r\n        vertexSource = \"source:\" + baseName.vertexSource;\r\n    } else if (baseName.vertexElement) {\r\n        vertexSource = hostDocument?.getElementById(baseName.vertexElement) || baseName.vertexElement;\r\n    } else {\r\n        vertexSource = baseName.vertex || baseName;\r\n    }\r\n    if (typeof baseName === \"string\") {\r\n        fragmentSource = baseName;\r\n    } else if (baseName.fragmentSource) {\r\n        fragmentSource = \"source:\" + baseName.fragmentSource;\r\n    } else if (baseName.fragmentElement) {\r\n        fragmentSource = hostDocument?.getElementById(baseName.fragmentElement) || baseName.fragmentElement;\r\n    } else {\r\n        fragmentSource = baseName.fragment || baseName;\r\n    }\r\n\r\n    const shaderCodes: [string | undefined, string | undefined] = [undefined, undefined];\r\n    const shadersLoaded = () => {\r\n        if (shaderCodes[0] && shaderCodes[1]) {\r\n            processorOptions.isFragment = true;\r\n            const [migratedVertexCode, fragmentCode] = shaderCodes;\r\n            Process(\r\n                fragmentCode,\r\n                processorOptions,\r\n                (migratedFragmentCode, codeBeforeMigration) => {\r\n                    if (effectContext) {\r\n                        effectContext._fragmentSourceCodeBeforeMigration = codeBeforeMigration;\r\n                    }\r\n                    if (processFinalCode) {\r\n                        migratedFragmentCode = processFinalCode(\"fragment\", migratedFragmentCode);\r\n                    }\r\n                    const finalShaders = Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);\r\n                    processorOptions = null as any;\r\n                    const finalCode = UseFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName, shaderLanguage);\r\n                    onFinalCodeReady?.(finalCode.vertexSourceCode, finalCode.fragmentSourceCode);\r\n                },\r\n                engine\r\n            );\r\n        }\r\n    };\r\n    LoadShader(\r\n        vertexSource,\r\n        \"Vertex\",\r\n        \"\",\r\n        (vertexCode) => {\r\n            Initialize(processorOptions);\r\n            Process(\r\n                vertexCode,\r\n                processorOptions,\r\n                (migratedVertexCode, codeBeforeMigration) => {\r\n                    if (effectContext) {\r\n                        effectContext._rawVertexSourceCode = vertexCode;\r\n                        effectContext._vertexSourceCodeBeforeMigration = codeBeforeMigration;\r\n                    }\r\n                    if (processFinalCode) {\r\n                        migratedVertexCode = processFinalCode(\"vertex\", migratedVertexCode);\r\n                    }\r\n                    shaderCodes[0] = migratedVertexCode;\r\n                    shadersLoaded();\r\n                },\r\n                engine\r\n            );\r\n        },\r\n        shaderLanguage\r\n    );\r\n    LoadShader(\r\n        fragmentSource,\r\n        \"Fragment\",\r\n        \"Pixel\",\r\n        (fragmentCode) => {\r\n            if (effectContext) {\r\n                effectContext._rawFragmentSourceCode = fragmentCode;\r\n            }\r\n            shaderCodes[1] = fragmentCode;\r\n            shadersLoaded();\r\n        },\r\n        shaderLanguage\r\n    );\r\n}\r\n\r\nfunction LoadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void, shaderLanguage?: ShaderLanguage, _loadFileInjection?: typeof _LoadFile) {\r\n    if (typeof HTMLElement !== \"undefined\") {\r\n        // DOM element ?\r\n        if (shader instanceof HTMLElement) {\r\n            const shaderCode = GetDOMTextContent(shader);\r\n            callback(shaderCode);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Direct source ?\r\n    if (shader.substring(0, 7) === \"source:\") {\r\n        callback(shader.substring(7));\r\n        return;\r\n    }\r\n\r\n    // Base64 encoded ?\r\n    if (shader.substring(0, 7) === \"base64:\") {\r\n        const shaderBinary = window.atob(shader.substring(7));\r\n        callback(shaderBinary);\r\n        return;\r\n    }\r\n\r\n    const shaderStore = ShaderStore.GetShadersStore(shaderLanguage);\r\n\r\n    // Is in local store ?\r\n    if (shaderStore[shader + key + \"Shader\"]) {\r\n        callback(shaderStore[shader + key + \"Shader\"]);\r\n        return;\r\n    }\r\n\r\n    if (optionalKey && shaderStore[shader + optionalKey + \"Shader\"]) {\r\n        callback(shaderStore[shader + optionalKey + \"Shader\"]);\r\n        return;\r\n    }\r\n\r\n    let shaderUrl;\r\n\r\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n        shaderUrl = shader;\r\n    } else {\r\n        shaderUrl = ShaderStore.GetShadersRepository(shaderLanguage) + shader;\r\n    }\r\n    _loadFileInjection = _loadFileInjection || _LoadFile;\r\n    if (!_loadFileInjection) {\r\n        // we got to this point and loadFile was not injected - throw an error\r\n        throw new Error(\"loadFileInjection is not defined\");\r\n    }\r\n    // Vertex shader\r\n    _loadFileInjection(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n}\r\n\r\nfunction UseFinalCode(migratedVertexCode: string, migratedFragmentCode: string, baseName: any, shaderLanguage?: ShaderLanguage) {\r\n    if (baseName) {\r\n        const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;\r\n        const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;\r\n\r\n        return {\r\n            vertexSourceCode: (shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME vertex:\" + vertex + \"\\n\" + migratedVertexCode,\r\n            fragmentSourceCode: (shaderLanguage === ShaderLanguage.WGSL ? \"//\" : \"\") + \"#define SHADER_NAME fragment:\" + fragment + \"\\n\" + migratedFragmentCode,\r\n        };\r\n    } else {\r\n        return {\r\n            vertexSourceCode: migratedVertexCode,\r\n            fragmentSourceCode: migratedFragmentCode,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Creates and prepares a pipeline context\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const createAndPreparePipelineContext = (\r\n    options: ICreateAndPreparePipelineContextOptions,\r\n    createPipelineContext: typeof AbstractEngine.prototype.createPipelineContext,\r\n    _preparePipelineContext: typeof AbstractEngine.prototype._preparePipelineContextAsync,\r\n    _executeWhenRenderingStateIsCompiled: typeof AbstractEngine.prototype._executeWhenRenderingStateIsCompiled\r\n): IPipelineContext => {\r\n    try {\r\n        const stateObject = options.context ? getStateObject(options.context) : null;\r\n        if (stateObject) {\r\n            // will not remove the reference to parallelShaderPrecompile, but will prevent it from being used in the next shader compilation\r\n            stateObject.disableParallelShaderCompile = options.disableParallelCompilation;\r\n        }\r\n        const pipelineContext: IPipelineContext = options.existingPipelineContext || createPipelineContext(options.shaderProcessingContext);\r\n        pipelineContext._name = options.name;\r\n        if (options.name && stateObject) {\r\n            stateObject.cachedPipelines[options.name] = pipelineContext;\r\n        }\r\n\r\n        // Flagged as async as we may need to delay load some processing tools\r\n        // This does not break anything as the execution is waiting for _executeWhenRenderingStateIsCompiled\r\n        _preparePipelineContext(\r\n            pipelineContext,\r\n            options.vertex,\r\n            options.fragment,\r\n            !!options.createAsRaw,\r\n            \"\",\r\n            \"\",\r\n            options.rebuildRebind,\r\n            options.defines,\r\n            options.transformFeedbackVaryings,\r\n            \"\",\r\n            () => {\r\n                _executeWhenRenderingStateIsCompiled(pipelineContext, () => {\r\n                    options.onRenderingStateCompiled?.(pipelineContext);\r\n                });\r\n            }\r\n        );\r\n\r\n        return pipelineContext;\r\n    } catch (e) {\r\n        Logger.Error(\"Error compiling effect\");\r\n        throw e;\r\n    }\r\n};\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { FloatArray, Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IPipelineContext } from \"../Engines/IPipelineContext\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { IShaderProcessor } from \"../Engines/Processors/iShaderProcessor\";\r\nimport type { _IProcessingOptions, ShaderCustomProcessingFunction, _IShaderProcessingContext } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { IMatrixLike, IVector2Like, IVector3Like, IVector4Like, IColor3Like, IColor4Like, IQuaternionLike } from \"../Maths/math.like\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { IEffectFallbacks } from \"./iEffectFallbacks\";\r\nimport { ShaderStore as EngineShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport type { IPipelineGenerationOptions } from \"./effect.functions\";\r\nimport { _ProcessShaderCode, getCachedPipeline, createAndPreparePipelineContext, resetCachedPipeline } from \"./effect.functions\";\r\nimport { _RetryWithInterval } from \"core/Misc/timingTools\";\r\n\r\n/**\r\n * Defines the route to the shader code. The priority is as follows:\r\n *  * object: `{ vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" }` for directly passing the shader code\r\n *  * object: `{ vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }`, used with shader code in script tags\r\n *  * object: `{ vertex: \"custom\", fragment: \"custom\" }`, used with `Effect.ShadersStore[\"customVertexShader\"]` and `Effect.ShadersStore[\"customFragmentShader\"]`\r\n *  * string: `\"./COMMON_NAME\"`, used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport type IShaderPath = {\r\n    // Should not have `I` prefix as it is a type and not an interface\r\n    /**\r\n     * Directly pass the shader code\r\n     */\r\n    vertexSource?: string;\r\n    /**\r\n     * Directly pass the shader code\r\n     */\r\n    fragmentSource?: string;\r\n    /**\r\n     * Used with Effect.ShadersStore. If the `vertex` is set to `\"custom`, then\r\n     * Babylon.js will read from Effect.ShadersStore[\"customVertexShader\"]\r\n     */\r\n    vertex?: string;\r\n    /**\r\n     * Used with Effect.ShadersStore. If the `fragment` is set to `\"custom`, then\r\n     * Babylon.js will read from Effect.ShadersStore[\"customFragmentShader\"]\r\n     */\r\n    fragment?: string;\r\n    /**\r\n     * Used with shader code in script tags\r\n     */\r\n    vertexElement?: string;\r\n    /**\r\n     * Used with shader code in script tags\r\n     */\r\n    fragmentElement?: string;\r\n    /**\r\n     * Defines the name appearing in spector when framgent/vertex...source are being used\r\n     */\r\n    spectorName?: string;\r\n};\r\n\r\n/**\r\n * Options to be used when creating an effect.\r\n */\r\nexport interface IEffectCreationOptions {\r\n    /**\r\n     * Attributes that will be used in the shader.\r\n     */\r\n    attributes: string[];\r\n    /**\r\n     * Uniform variable names that will be set in the shader.\r\n     */\r\n    uniformsNames: string[];\r\n    /**\r\n     * Uniform buffer variable names that will be set in the shader.\r\n     */\r\n    uniformBuffersNames?: string[];\r\n    /**\r\n     * Sampler texture variable names that will be set in the shader.\r\n     */\r\n    samplers: string[];\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * Possible fallbacks for this effect to improve performance when needed.\r\n     */\r\n    fallbacks: Nullable<IEffectFallbacks>;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: Effect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: Effect, errors: string) => void>;\r\n    /**\r\n     * Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\r\n     */\r\n    indexParameters?: any;\r\n    /**\r\n     * Max number of lights that can be used in the shader.\r\n     */\r\n    maxSimultaneousLights?: number;\r\n    /**\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings\r\n     */\r\n    transformFeedbackVaryings?: Nullable<string[]>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated after the #include have been processed\r\n     */\r\n    processCodeAfterIncludes?: Nullable<ShaderCustomProcessingFunction>;\r\n    /**\r\n     * Is this effect rendering to several color attachments ?\r\n     */\r\n    multiTarget?: boolean;\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n\r\n    /**\r\n     * Provide an existing pipeline context to avoid creating a new one\r\n     */\r\n    existingPipelineContext?: IPipelineContext;\r\n    /**\r\n     * Additional async code to run before preparing the effect\r\n     */\r\n    extraInitializationsAsync?: () => Promise<void>;\r\n\r\n    /**\r\n     * If set to true the shader will not be compiles asynchronously, even if the engine allows it.\r\n     */\r\n    disableParallelShaderCompilation?: boolean;\r\n}\r\n\r\n/**\r\n * Effect containing vertex and fragment shader that can be executed on an object.\r\n */\r\nexport class Effect implements IDisposable {\r\n    /**\r\n     * Gets or sets the relative url used to load shaders if using the engine in non-minified mode\r\n     */\r\n    public static get ShadersRepository(): string {\r\n        return EngineShaderStore.ShadersRepository;\r\n    }\r\n    public static set ShadersRepository(repo: string) {\r\n        EngineShaderStore.ShadersRepository = repo;\r\n    }\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that effect ref counting is disabled\r\n     * If true, the effect will persist in memory until engine is disposed\r\n     */\r\n    public static PersistentMode: boolean = false;\r\n\r\n    /**\r\n     * Use this with caution\r\n     * See ClearCodeCache function comments\r\n     */\r\n    public static AutomaticallyClearCodeCache = false;\r\n\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: IShaderPath | string;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: Effect, errors: string) => void> = null;\r\n    /**\r\n     * Callback that will be called when effect is bound.\r\n     */\r\n    public onBind: Nullable<(effect: Effect) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<Effect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<Effect>();\r\n\r\n    /** @internal */\r\n    public _onBindObservable: Nullable<Observable<Effect>> = null;\r\n\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the effect was already disposed\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /** @internal */\r\n    public _refCount = 1;\r\n\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public get onBindObservable(): Observable<Effect> {\r\n        if (!this._onBindObservable) {\r\n            this._onBindObservable = new Observable<Effect>();\r\n        }\r\n\r\n        return this._onBindObservable;\r\n    }\r\n\r\n    /** @internal */\r\n    public _bonesComputationForcedToCPU = false;\r\n    /** @internal */\r\n    public _uniformBuffersNames: { [key: string]: number } = {};\r\n    /** @internal */\r\n    public _samplerList: string[];\r\n    /** @internal */\r\n    public _multiTarget: boolean = false;\r\n\r\n    private static _UniqueIdSeed = 0;\r\n    /** @internal */\r\n    public _engine: AbstractEngine;\r\n    private _uniformBuffersNamesList: string[];\r\n    private _uniformsNames: string[];\r\n    /** @internal */\r\n    public _samplers: { [key: string]: number } = {};\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    private _allFallbacksProcessed = false;\r\n    private _attributesNames: string[];\r\n    private _attributes: number[];\r\n    private _attributeLocationByName: { [name: string]: number };\r\n    /** @internal */\r\n    public _uniforms: { [key: string]: Nullable<WebGLUniformLocation> } = {};\r\n    /**\r\n     * Key for the effect.\r\n     * @internal\r\n     */\r\n    public _key: string = \"\";\r\n    private _indexParameters: any;\r\n    private _fallbacks: Nullable<IEffectFallbacks> = null;\r\n    private _vertexSourceCodeOverride: string = \"\";\r\n    private _fragmentSourceCodeOverride: string = \"\";\r\n    private _transformFeedbackVaryings: Nullable<string[]> = null;\r\n    private _shaderLanguage: ShaderLanguage;\r\n    private _disableParallelShaderCompilation: boolean = false;\r\n    /**\r\n     * Compiled shader to webGL program.\r\n     * @internal\r\n     */\r\n    public _pipelineContext: Nullable<IPipelineContext> = null;\r\n    /** @internal */\r\n    public _vertexSourceCode: string = \"\";\r\n    /** @internal */\r\n    public _fragmentSourceCode: string = \"\";\r\n\r\n    /** @internal */\r\n    public _vertexSourceCodeBeforeMigration: string = \"\";\r\n    /** @internal */\r\n    public _fragmentSourceCodeBeforeMigration: string = \"\";\r\n\r\n    /** @internal */\r\n    public _rawVertexSourceCode: string = \"\";\r\n    /** @internal */\r\n    public _rawFragmentSourceCode: string = \"\";\r\n\r\n    private static _BaseCache: { [key: number]: DataBuffer } = {};\r\n    private _processingContext: Nullable<_IShaderProcessingContext>;\r\n\r\n    private _processCodeAfterIncludes: ShaderCustomProcessingFunction | undefined = undefined;\r\n    private _processFinalCode: Nullable<ShaderCustomProcessingFunction> = null;\r\n\r\n    private _onReleaseEffectsObserver: Nullable<Observer<AbstractEngine>> = null;\r\n\r\n    /**\r\n     * Gets the shader language type used to write vertex and fragment source code.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * Instantiates an effect.\r\n     * An effect can be used to create/manage/execute vertex and fragment shaders.\r\n     * @param baseName Name of the effect.\r\n     * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.\r\n     * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.\r\n     * @param samplers List of sampler variables that will be passed to the shader.\r\n     * @param engine Engine to be used to render the effect\r\n     * @param defines Define statements to be added to the shader.\r\n     * @param fallbacks Possible fallbacks for this effect to improve performance when needed.\r\n     * @param onCompiled Callback that will be called when the shader is compiled.\r\n     * @param onError Callback that will be called if an error occurs during shader compilation.\r\n     * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. \\{lights: 10\\})\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     * @param extraInitializationsAsync additional async code to run before preparing the effect\r\n     */\r\n    constructor(\r\n        baseName: IShaderPath | string,\r\n        attributesNamesOrOptions: string[] | IEffectCreationOptions,\r\n        uniformsNamesOrEngine: string[] | AbstractEngine,\r\n        samplers: Nullable<string[]> = null,\r\n        engine?: AbstractEngine,\r\n        defines: Nullable<string> = null,\r\n        fallbacks: Nullable<IEffectFallbacks> = null,\r\n        onCompiled: Nullable<(effect: Effect) => void> = null,\r\n        onError: Nullable<(effect: Effect, errors: string) => void> = null,\r\n        indexParameters?: any,\r\n        key: string = \"\",\r\n        shaderLanguage = ShaderLanguage.GLSL,\r\n        extraInitializationsAsync?: () => Promise<void>\r\n    ) {\r\n        this.name = baseName;\r\n        this._key = key;\r\n        const pipelineName = this._key.replace(/\\r/g, \"\").replace(/\\n/g, \"|\");\r\n        let cachedPipeline: IPipelineContext | undefined = undefined;\r\n\r\n        if ((<IEffectCreationOptions>attributesNamesOrOptions).attributes) {\r\n            const options = <IEffectCreationOptions>attributesNamesOrOptions;\r\n            this._engine = <AbstractEngine>uniformsNamesOrEngine;\r\n\r\n            this._attributesNames = options.attributes;\r\n            this._uniformsNames = options.uniformsNames.concat(options.samplers);\r\n            this._samplerList = options.samplers.slice();\r\n            this.defines = options.defines;\r\n            this.onError = options.onError;\r\n            this.onCompiled = options.onCompiled;\r\n            this._fallbacks = options.fallbacks;\r\n            this._indexParameters = options.indexParameters;\r\n            this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;\r\n            this._multiTarget = !!options.multiTarget;\r\n            this._shaderLanguage = options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n            this._disableParallelShaderCompilation = !!options.disableParallelShaderCompilation;\r\n\r\n            if (options.uniformBuffersNames) {\r\n                this._uniformBuffersNamesList = options.uniformBuffersNames.slice();\r\n                for (let i = 0; i < options.uniformBuffersNames.length; i++) {\r\n                    this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\r\n                }\r\n            }\r\n\r\n            this._processFinalCode = options.processFinalCode ?? null;\r\n            this._processCodeAfterIncludes = options.processCodeAfterIncludes ?? undefined;\r\n            extraInitializationsAsync = options.extraInitializationsAsync;\r\n\r\n            cachedPipeline = options.existingPipelineContext;\r\n        } else {\r\n            this._engine = <AbstractEngine>engine;\r\n            this.defines = defines == null ? \"\" : defines;\r\n            this._uniformsNames = (<string[]>uniformsNamesOrEngine).concat(<string[]>samplers);\r\n            this._samplerList = samplers ? samplers.slice() : [];\r\n            this._attributesNames = <string[]>attributesNamesOrOptions;\r\n            this._uniformBuffersNamesList = [];\r\n            this._shaderLanguage = shaderLanguage;\r\n\r\n            this.onError = onError;\r\n            this.onCompiled = onCompiled;\r\n\r\n            this._indexParameters = indexParameters;\r\n            this._fallbacks = fallbacks;\r\n        }\r\n\r\n        // Use the cache if we can. For now, WebGL2 only.\r\n        if (this._engine.shaderPlatformName === \"WEBGL2\") {\r\n            cachedPipeline = getCachedPipeline(pipelineName, (this._engine as any)._gl) ?? cachedPipeline;\r\n        }\r\n\r\n        this._attributeLocationByName = {};\r\n\r\n        this.uniqueId = Effect._UniqueIdSeed++;\r\n        if (!cachedPipeline) {\r\n            // Floating promise - should be checked here.\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._processShaderCodeAsync(null, false, null, extraInitializationsAsync);\r\n        } else {\r\n            this._pipelineContext = cachedPipeline;\r\n            this._pipelineContext.setEngine(this._engine);\r\n            this._onRenderingStateCompiled(this._pipelineContext);\r\n            // rebuildRebind for spector\r\n            if ((this._pipelineContext as any).program) {\r\n                (this._pipelineContext as any).program.__SPECTOR_rebuildProgram = this._rebuildProgram.bind(this);\r\n            }\r\n        }\r\n\r\n        this._onReleaseEffectsObserver = this._engine.onReleaseEffectsObservable.addOnce(() => {\r\n            this._onReleaseEffectsObserver = null;\r\n            if (this.isDisposed) {\r\n                return;\r\n            }\r\n\r\n            this.dispose(true);\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public async _processShaderCodeAsync(\r\n        shaderProcessor: Nullable<IShaderProcessor> = null,\r\n        keepExistingPipelineContext = false,\r\n        shaderProcessingContext: Nullable<_IShaderProcessingContext> = null,\r\n        extraInitializationsAsync?: () => Promise<void>\r\n    ) {\r\n        if (extraInitializationsAsync) {\r\n            await extraInitializationsAsync();\r\n        }\r\n\r\n        this._processingContext = shaderProcessingContext || this._engine._getShaderProcessingContext(this._shaderLanguage, false);\r\n\r\n        const processorOptions: _IProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: this._indexParameters,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n            processor: shaderProcessor ?? this._engine._getShaderProcessor(this._shaderLanguage),\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: EngineShaderStore.GetShadersRepository(this._shaderLanguage),\r\n            includesShadersStore: EngineShaderStore.GetIncludesShadersStore(this._shaderLanguage),\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: this._processingContext,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n            processCodeAfterIncludes: this._processCodeAfterIncludes,\r\n        };\r\n\r\n        _ProcessShaderCode(\r\n            processorOptions,\r\n            this.name,\r\n            this._processFinalCode,\r\n            (migratedVertexCode, migratedFragmentCode) => {\r\n                this._vertexSourceCode = migratedVertexCode;\r\n                this._fragmentSourceCode = migratedFragmentCode;\r\n                this._prepareEffect(keepExistingPipelineContext);\r\n            },\r\n            this._shaderLanguage,\r\n            this._engine,\r\n            this\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._engine.isDisposed) {\r\n            // Engine is disposed, we return true to prevent looping over the setTimeout call in _checkIsReady\r\n            return true;\r\n        }\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): AbstractEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IPipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The set of names of attribute variables for the shader.\r\n     * @returns An array of attribute names.\r\n     */\r\n    public getAttributesNames(): string[] {\r\n        return this._attributesNames;\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute at the given index.\r\n     * @param index The index of the attribute.\r\n     * @returns The location of the attribute.\r\n     */\r\n    public getAttributeLocation(index: number): number {\r\n        return this._attributes[index];\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param name of the attribute to look up.\r\n     * @returns the attribute location.\r\n     */\r\n    public getAttributeLocationByName(name: string): number {\r\n        return this._attributeLocationByName[name];\r\n    }\r\n\r\n    /**\r\n     * The number of attributes.\r\n     * @returns the number of attributes.\r\n     */\r\n    public getAttributesCount(): number {\r\n        return this._attributes.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index of a uniform variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the index.\r\n     */\r\n    public getUniformIndex(uniformName: string): number {\r\n        return this._uniformsNames.indexOf(uniformName);\r\n    }\r\n\r\n    /**\r\n     * Returns the attribute based on the name of the variable.\r\n     * @param uniformName of the uniform to look up.\r\n     * @returns the location of the uniform.\r\n     */\r\n    public getUniform(uniformName: string): Nullable<WebGLUniformLocation> {\r\n        return this._uniforms[uniformName];\r\n    }\r\n\r\n    /**\r\n     * Returns an array of sampler variable names\r\n     * @returns The array of sampler variable names.\r\n     */\r\n    public getSamplers(): string[] {\r\n        return this._samplerList;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform variable names\r\n     * @returns The array of uniform variable names.\r\n     */\r\n    public getUniformNames(): string[] {\r\n        return this._uniformsNames;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of uniform buffer variable names\r\n     * @returns The array of uniform buffer variable names.\r\n     */\r\n    public getUniformBuffersNames(): string[] {\r\n        return this._uniformBuffersNamesList;\r\n    }\r\n\r\n    /**\r\n     * Returns the index parameters used to create the effect\r\n     * @returns The index parameters object\r\n     */\r\n    public getIndexParameters(): any {\r\n        return this._indexParameters;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that all fallbacks were used during compilation\r\n     * @returns true if all fallbacks were used\r\n     */\r\n    public allFallbacksProcessed(): boolean {\r\n        return this._allFallbacksProcessed;\r\n    }\r\n\r\n    /**\r\n     * Wait until compilation before fulfilling.\r\n     * @returns a promise to wait for completion.\r\n     */\r\n    public async whenCompiledAsync(): Promise<Effect> {\r\n        return await new Promise((resolve) => {\r\n            this.executeWhenCompiled(resolve);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: Effect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            this._checkIsReady(null);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IPipelineContext>) {\r\n        _RetryWithInterval(\r\n            () => {\r\n                return this._isReadyInternal() || this._isDisposed;\r\n            },\r\n            () => {\r\n                // no-op - done in the _isReadyInternal call\r\n            },\r\n            (e) => {\r\n                this._processCompilationErrors(e, previousPipelineContext);\r\n            },\r\n            16,\r\n            120000,\r\n            true,\r\n            ` - Effect: ${typeof this.name === \"string\" ? this.name : this.key}`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code of this effect\r\n     * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\r\n     */\r\n    public get vertexSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._vertexSourceCodeOverride\r\n            : (this._pipelineContext?._getVertexShaderCode() ?? this._vertexSourceCode);\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code of this effect\r\n     * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)\r\n     */\r\n    public get fragmentSourceCode(): string {\r\n        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride\r\n            ? this._fragmentSourceCodeOverride\r\n            : (this._pipelineContext?._getFragmentShaderCode() ?? this._fragmentSourceCode);\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before migration.\r\n     * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\r\n     * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\r\n     */\r\n    public get vertexSourceCodeBeforeMigration(): string {\r\n        return this._vertexSourceCodeBeforeMigration;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before migration.\r\n     * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.\r\n     * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).\r\n     */\r\n    public get fragmentSourceCodeBeforeMigration(): string {\r\n        return this._fragmentSourceCodeBeforeMigration;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex shader source code before it has been modified by any processing\r\n     */\r\n    public get rawVertexSourceCode(): string {\r\n        return this._rawVertexSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the fragment shader source code before it has been modified by any processing\r\n     */\r\n    public get rawFragmentSourceCode(): string {\r\n        return this._rawFragmentSourceCode;\r\n    }\r\n\r\n    public getPipelineGenerationOptions(): IPipelineGenerationOptions {\r\n        return {\r\n            platformName: this._engine.shaderPlatformName,\r\n            shaderLanguage: this._shaderLanguage,\r\n            shaderNameOrContent: this.name,\r\n            key: this._key,\r\n            defines: this.defines.split(\"\\n\"),\r\n            addGlobalDefines: false,\r\n            extendedProcessingOptions: {\r\n                indexParameters: this._indexParameters,\r\n                isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n                supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            },\r\n            extendedCreatePipelineOptions: {\r\n                transformFeedbackVaryings: this._transformFeedbackVaryings,\r\n                createAsRaw: !!(this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride),\r\n            },\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Recompiles the webGL program\r\n     * @param vertexSourceCode The source code for the vertex shader.\r\n     * @param fragmentSourceCode The source code for the fragment shader.\r\n     * @param onCompiled Callback called when completed.\r\n     * @param onError Callback called on error.\r\n     * @internal\r\n     */\r\n    public _rebuildProgram(vertexSourceCode: string, fragmentSourceCode: string, onCompiled: (pipelineContext: IPipelineContext) => void, onError: (message: string) => void) {\r\n        this._isReady = false;\r\n\r\n        this._vertexSourceCodeOverride = vertexSourceCode;\r\n        this._fragmentSourceCodeOverride = fragmentSourceCode;\r\n        this.onError = (effect, error) => {\r\n            if (onError) {\r\n                onError(error);\r\n            }\r\n        };\r\n        this.onCompiled = () => {\r\n            const scenes = this.getEngine().scenes;\r\n            if (scenes) {\r\n                for (let i = 0; i < scenes.length; i++) {\r\n                    scenes[i].markAllMaterialsAsDirty(Constants.MATERIAL_AllDirtyFlag);\r\n                }\r\n            }\r\n\r\n            this._pipelineContext!._handlesSpectorRebuildCallback?.(onCompiled);\r\n        };\r\n        this._fallbacks = null;\r\n        this._prepareEffect();\r\n    }\r\n\r\n    private _onRenderingStateCompiled(pipelineContext: IPipelineContext) {\r\n        this._pipelineContext = pipelineContext;\r\n        this._pipelineContext.setEngine(this._engine);\r\n        this._attributes = [];\r\n        this._pipelineContext._fillEffectInformation(\r\n            this,\r\n            this._uniformBuffersNames,\r\n            this._uniformsNames,\r\n            this._uniforms,\r\n            this._samplerList,\r\n            this._samplers,\r\n            this._attributesNames,\r\n            this._attributes\r\n        );\r\n\r\n        // Caches attribute locations.\r\n        if (this._attributesNames) {\r\n            for (let i = 0; i < this._attributesNames.length; i++) {\r\n                const name = this._attributesNames[i];\r\n                this._attributeLocationByName[name] = this._attributes[i];\r\n            }\r\n        }\r\n\r\n        this._engine.bindSamplers(this);\r\n\r\n        this._compilationError = \"\";\r\n        this._isReady = true;\r\n        if (this.onCompiled) {\r\n            this.onCompiled(this);\r\n        }\r\n        this.onCompileObservable.notifyObservers(this);\r\n        this.onCompileObservable.clear();\r\n\r\n        // Unbind mesh reference in fallbacks\r\n        if (this._fallbacks) {\r\n            this._fallbacks.unBindMesh();\r\n        }\r\n\r\n        if (Effect.AutomaticallyClearCodeCache) {\r\n            this.clearCodeCache();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @internal\r\n     */\r\n    public _prepareEffect(keepExistingPipelineContext = false) {\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const overrides = !!(this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride);\r\n            const defines = overrides ? null : this.defines;\r\n            const vertex = overrides ? this._vertexSourceCodeOverride : this._vertexSourceCode;\r\n            const fragment = overrides ? this._fragmentSourceCodeOverride : this._fragmentSourceCode;\r\n            const engine = this._engine;\r\n            this._pipelineContext = createAndPreparePipelineContext(\r\n                {\r\n                    existingPipelineContext: keepExistingPipelineContext ? previousPipelineContext : null,\r\n                    vertex,\r\n                    fragment,\r\n                    context: engine.shaderPlatformName === \"WEBGL2\" || engine.shaderPlatformName === \"WEBGL1\" ? (engine as any)._gl : undefined,\r\n                    rebuildRebind: (\r\n                        vertexSourceCode: string,\r\n                        fragmentSourceCode: string,\r\n                        onCompiled: (pipelineContext: IPipelineContext) => void,\r\n                        onError: (message: string) => void\r\n                    ) => this._rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError),\r\n                    defines,\r\n                    transformFeedbackVaryings: this._transformFeedbackVaryings,\r\n                    name: this._key.replace(/\\r/g, \"\").replace(/\\n/g, \"|\"),\r\n                    createAsRaw: overrides,\r\n                    disableParallelCompilation: this._disableParallelShaderCompilation,\r\n                    shaderProcessingContext: this._processingContext,\r\n                    onRenderingStateCompiled: (pipelineContext) => {\r\n                        if (previousPipelineContext && !keepExistingPipelineContext) {\r\n                            this._engine._deletePipelineContext(previousPipelineContext);\r\n                        }\r\n                        if (pipelineContext) {\r\n                            this._onRenderingStateCompiled(pipelineContext);\r\n                        }\r\n                    },\r\n                },\r\n                this._engine.createPipelineContext.bind(this._engine),\r\n                this._engine._preparePipelineContextAsync.bind(this._engine),\r\n                this._engine._executeWhenRenderingStateIsCompiled.bind(this._engine)\r\n            );\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>, isFragment: boolean): [Nullable<string>, Nullable<string>] {\r\n        const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\\d+?):/ : /VERTEX SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in ${isFragment ? \"fragment\" : \"vertex\"} code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IPipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n        const attributesNames = this._attributesNames;\r\n        const fallbacks = this._fallbacks;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile effect:\");\r\n        Logger.Error(`Uniforms: ${this._uniformsNames.join(\" \")}`);\r\n        Logger.Error(`Attributes: ${attributesNames.join(\" \")}`);\r\n        Logger.Error(\"Defines:\\n\" + this.defines);\r\n        if (Effect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null,\r\n                lineErrorFragment = null,\r\n                code = null;\r\n            if (this._pipelineContext?._getVertexShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);\r\n                if (code) {\r\n                    Logger.Error(\"Vertex code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (this._pipelineContext?._getFragmentShaderCode()) {\r\n                [code, lineErrorFragment] = this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(), this._compilationError, true);\r\n                if (code) {\r\n                    Logger.Error(\"Fragment code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n            if (lineErrorFragment) {\r\n                Logger.Error(lineErrorFragment);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n\r\n        const notifyErrors = () => {\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n            this._engine.onEffectErrorObservable.notifyObservers({ effect: this, errors: this._compilationError });\r\n        };\r\n\r\n        // In case a previous compilation was successful, we need to restore the previous pipeline context\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            notifyErrors();\r\n        }\r\n\r\n        // Lets try to compile fallbacks as long as we have some.\r\n        if (fallbacks) {\r\n            this._pipelineContext = null;\r\n            if (fallbacks.hasMoreFallbacks) {\r\n                this._allFallbacksProcessed = false;\r\n                Logger.Error(\"Trying next fallback.\");\r\n                this.defines = fallbacks.reduce(this.defines, this);\r\n                this._prepareEffect();\r\n            } else {\r\n                // Sorry we did everything we can\r\n                this._allFallbacksProcessed = true;\r\n                notifyErrors();\r\n                this.onErrorObservable.clear();\r\n\r\n                // Unbind mesh reference in fallbacks\r\n                if (this._fallbacks) {\r\n                    this._fallbacks.unBindMesh();\r\n                }\r\n            }\r\n        } else {\r\n            this._allFallbacksProcessed = true;\r\n\r\n            // In case of error, without any prior successful compilation, let s notify observers\r\n            if (!previousPipelineContext) {\r\n                notifyErrors();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the effect is supported. (Must be called after compilation)\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._compilationError === \"\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the engine to be used as output of the shader.\r\n     * @param channel Name of the output variable.\r\n     * @param texture Texture to bind.\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: string, texture: Nullable<InternalTexture>): void {\r\n        this._engine._bindTexture(this._samplers[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets a texture on the engine to be used in the shader.\r\n     * @param channel Name of the sampler variable.\r\n     * @param texture Texture to set.\r\n     */\r\n    public setTexture(channel: string, texture: Nullable<ThinTexture>): void {\r\n        this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);\r\n    }\r\n\r\n    /**\r\n     * Sets an array of textures on the engine to be used in the shader.\r\n     * @param channel Name of the variable.\r\n     * @param textures Textures to set.\r\n     */\r\n    public setTextureArray(channel: string, textures: ThinTexture[]): void {\r\n        const exName = channel + \"Ex\";\r\n        if (this._samplerList.indexOf(exName + \"0\") === -1) {\r\n            const initialPos = this._samplerList.indexOf(channel);\r\n            for (let index = 1; index < textures.length; index++) {\r\n                const currentExName = exName + (index - 1).toString();\r\n                this._samplerList.splice(initialPos + index, 0, currentExName);\r\n            }\r\n\r\n            // Reset every channels\r\n            let channelIndex = 0;\r\n            for (const key of this._samplerList) {\r\n                this._samplers[key] = channelIndex;\r\n                channelIndex += 1;\r\n            }\r\n        }\r\n\r\n        this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);\r\n    }\r\n\r\n    /**\r\n     * Binds a buffer to a uniform.\r\n     * @param buffer Buffer to bind.\r\n     * @param name Name of the uniform variable to bind to.\r\n     */\r\n    public bindUniformBuffer(buffer: DataBuffer, name: string): void {\r\n        const bufferName = this._uniformBuffersNames[name];\r\n        if (bufferName === undefined || (Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache)) {\r\n            return;\r\n        }\r\n        Effect._BaseCache[bufferName] = buffer;\r\n        this._engine.bindUniformBufferBase(buffer, bufferName, name);\r\n    }\r\n\r\n    /**\r\n     * Binds block to a uniform.\r\n     * @param blockName Name of the block to bind.\r\n     * @param index Index to bind.\r\n     */\r\n    public bindUniformBlock(blockName: string, index: number): void {\r\n        this._engine.bindUniformBlock(this._pipelineContext!, blockName, index);\r\n    }\r\n\r\n    /**\r\n     * Sets an integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int2.\r\n     * @param y Second int in int2.\r\n     * @returns this effect.\r\n     */\r\n    public setInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int3.\r\n     * @param y Second int in int3.\r\n     * @param z Third int in int3.\r\n     * @returns this effect.\r\n     */\r\n    public setInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First int in int4.\r\n     * @param y Second int in int4.\r\n     * @param z Third int in int4.\r\n     * @param w Fourth int in int4.\r\n     * @returns this effect.\r\n     */\r\n    public setInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray2(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray3(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setIntArray4(uniformName: string, array: Int32Array): Effect {\r\n        this._pipelineContext!.setIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned integer value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setUInt(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int2 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint2.\r\n     * @param y Second unsigned int in uint2.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setUInt2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int3 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint3.\r\n     * @param y Second unsigned int in uint3.\r\n     * @param z Third unsigned int in uint3.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setUInt3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int4 value on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First unsigned int in uint4.\r\n     * @param y Second unsigned int in uint4.\r\n     * @param z Third unsigned int in uint4.\r\n     * @param w Fourth unsigned int in uint4.\r\n     * @returns this effect.\r\n     */\r\n    public setUInt4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setUInt4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray2(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray3(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setUIntArray4(uniformName: string, array: Uint32Array): Effect {\r\n        this._pipelineContext!.setUIntArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray2(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray3(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloatArray4(uniformName: string, array: FloatArray): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray2(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray2(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray3(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray3(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)\r\n     * @param uniformName Name of the variable.\r\n     * @param array array to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setArray4(uniformName: string, array: number[]): Effect {\r\n        this._pipelineContext!.setArray4(uniformName, array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrices on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrices matrices to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrices(uniformName: string, matrices: Float32Array | Array<number>): Effect {\r\n        this._pipelineContext!.setMatrices(uniformName, matrices as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets matrix on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix(uniformName: string, matrix: IMatrixLike): Effect {\r\n        this._pipelineContext!.setMatrix(uniformName, matrix);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix3x3(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix3x3(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)\r\n     * @param uniformName Name of the variable.\r\n     * @param matrix matrix to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setMatrix2x2(uniformName: string, matrix: Float32Array | Array<number>): Effect {\r\n        // the cast is ok because it is gl.uniformMatrix3fv() which is called at the end, and this function accepts Float32Array and Array<number>\r\n        this._pipelineContext!.setMatrix2x2(uniformName, matrix as Float32Array);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param value value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat(uniformName: string, value: number): Effect {\r\n        this._pipelineContext!.setFloat(uniformName, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a boolean on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param bool value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setBool(uniformName: string, bool: boolean): Effect {\r\n        this._pipelineContext!.setInt(uniformName, bool ? 1 : 0);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector2 vector2 to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector2(uniformName: string, vector2: IVector2Like): Effect {\r\n        this._pipelineContext!.setVector2(uniformName, vector2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float2 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float2.\r\n     * @param y Second float in float2.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat2(uniformName: string, x: number, y: number): Effect {\r\n        this._pipelineContext!.setFloat2(uniformName, x, y);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector3(uniformName: string, vector3: IVector3Like): Effect {\r\n        this._pipelineContext!.setVector3(uniformName, vector3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float3.\r\n     * @param y Second float in float3.\r\n     * @param z Third float in float3.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat3(uniformName: string, x: number, y: number, z: number): Effect {\r\n        this._pipelineContext!.setFloat3(uniformName, x, y, z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Vector4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param vector4 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setVector4(uniformName: string, vector4: IVector4Like): Effect {\r\n        this._pipelineContext!.setVector4(uniformName, vector4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Quaternion on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param quaternion Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setQuaternion(uniformName: string, quaternion: IQuaternionLike): Effect {\r\n        this._pipelineContext!.setQuaternion(uniformName, quaternion);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a float4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param x First float in float4.\r\n     * @param y Second float in float4.\r\n     * @param z Third float in float4.\r\n     * @param w Fourth float in float4.\r\n     * @returns this effect.\r\n     */\r\n    public setFloat4(uniformName: string, x: number, y: number, z: number, w: number): Effect {\r\n        this._pipelineContext!.setFloat4(uniformName, x, y, z, w);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color3 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor3(uniformName: string, color3: IColor3Like): Effect {\r\n        this._pipelineContext!.setColor3(uniformName, color3);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable.\r\n     * @param uniformName Name of the variable.\r\n     * @param color3 Value to be set.\r\n     * @param alpha Alpha value to be set.\r\n     * @returns this effect.\r\n     */\r\n    public setColor4(uniformName: string, color3: IColor3Like, alpha: number): Effect {\r\n        this._pipelineContext!.setColor4(uniformName, color3, alpha);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets a Color4 on a uniform variable\r\n     * @param uniformName defines the name of the variable\r\n     * @param color4 defines the value to be set\r\n     * @returns this effect.\r\n     */\r\n    public setDirectColor4(uniformName: string, color4: IColor4Like): Effect {\r\n        this._pipelineContext!.setDirectColor4(uniformName, color4);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Use this wisely: It will remove the cached code from this effect\r\n     * It is probably ok to call it if you are not using ShadowDepthWrapper or if everything is already up and running\r\n     * DO NOT CALL IT if you want to have support for context lost recovery\r\n     */\r\n    public clearCodeCache() {\r\n        this._vertexSourceCode = \"\";\r\n        this._fragmentSourceCode = \"\";\r\n        this._fragmentSourceCodeBeforeMigration = \"\";\r\n        this._vertexSourceCodeBeforeMigration = \"\";\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     * @param force specifies if the effect must be released no matter what\r\n     **/\r\n    public dispose(force = false) {\r\n        if (force) {\r\n            this._refCount = 0;\r\n        } else {\r\n            if (Effect.PersistentMode) {\r\n                return;\r\n            }\r\n            this._refCount--;\r\n        }\r\n\r\n        if (this._refCount > 0 || this._isDisposed) {\r\n            // Others are still using the effect or the effect was already disposed\r\n            return;\r\n        }\r\n\r\n        if (this._onReleaseEffectsObserver) {\r\n            this._engine.onReleaseEffectsObservable.remove(this._onReleaseEffectsObserver);\r\n            this._onReleaseEffectsObserver = null;\r\n        }\r\n\r\n        if (this._pipelineContext) {\r\n            resetCachedPipeline(this._pipelineContext);\r\n        }\r\n        this._engine._releaseEffect(this);\r\n\r\n        this.clearCodeCache();\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * This function will add a new shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param pixelShader optional pixel shader content\r\n     * @param vertexShader optional vertex shader content\r\n     * @param shaderLanguage the language the shader is written in (default: GLSL)\r\n     */\r\n    public static RegisterShader(name: string, pixelShader?: string, vertexShader?: string, shaderLanguage = ShaderLanguage.GLSL) {\r\n        if (pixelShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}PixelShader`] = pixelShader;\r\n        }\r\n\r\n        if (vertexShader) {\r\n            EngineShaderStore.GetShadersStore(shaderLanguage)[`${name}VertexShader`] = vertexShader;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Store of each shader (The can be looked up using effect.key)\r\n     */\r\n    public static ShadersStore: { [key: string]: string } = EngineShaderStore.ShadersStore;\r\n    /**\r\n     * Store of each included file for a shader (The can be looked up using effect.key)\r\n     */\r\n    public static IncludesShadersStore: { [key: string]: string } = EngineShaderStore.IncludesShadersStore;\r\n\r\n    /**\r\n     * Resets the cache of effects.\r\n     */\r\n    public static ResetCache() {\r\n        Effect._BaseCache = {};\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["index", "buffer", "match", "createPipelineContext", "_preparePipelineContext", "_executeWhenRenderingStateIsCompiled"]
}
