import {
  UniformBuffer
} from "./chunk-CSVPIDNO.js";
import {
  Effect
} from "./chunk-RG742WGM.js";
import {
  InvertMatrixToRef,
  Matrix,
  MultiplyMatricesToRef
} from "./chunk-YLLTSBLI.js";

// node_modules/.pnpm/@babylonjs+core@8.49.1/node_modules/@babylonjs/core/Materials/floatingOriginMatrixOverrides.js
var TempFinalMat = new Matrix();
var TempMat1 = new Matrix();
var TempMat2 = new Matrix();
var FloatingOriginCurrentScene = {
  getScene: () => void 0,
  eyeAtCamera: true
  // When true, we can assume viewMatrix translation is at origin. Otherwise, we must do full offset calculations
};
function OffsetWorldToRef(offset, world, ref) {
  const refArray = ref.asArray();
  const worldArray = world.asArray();
  for (let i = 0; i < 16; i++) {
    refArray[i] = worldArray[i];
  }
  refArray[12] -= offset.x;
  refArray[13] -= offset.y;
  refArray[14] -= offset.z;
  ref.markAsUpdated();
  return ref;
}
function GetFullOffsetView(offset, viewMatrix, ref) {
  InvertMatrixToRef(viewMatrix, TempMat1);
  OffsetWorldToRef(offset, TempMat1, TempMat2);
  InvertMatrixToRef(TempMat2, ref);
  return ref;
}
function OffsetViewToRef(offset, view, ref) {
  if (!FloatingOriginCurrentScene.eyeAtCamera) {
    return GetFullOffsetView(offset, view, ref);
  }
  const refArray = ref.asArray();
  const viewArray = view.asArray();
  for (let i = 0; i < 16; i++) {
    refArray[i] = viewArray[i];
  }
  refArray[12] = 0;
  refArray[13] = 0;
  refArray[14] = 0;
  ref.markAsUpdated();
  return ref;
}
function OffsetViewProjectionToRef(offset, view, projection, ref) {
  MultiplyMatricesToRef(OffsetViewToRef(offset, view, ref), projection, ref);
  return ref;
}
function GetOffsetTransformMatrices(offset, viewMatrices, projectionMatrices, length, resultArray) {
  for (let cascadeIndex = 0; cascadeIndex < length; ++cascadeIndex) {
    GetFullOffsetViewProjectionToRef(offset, viewMatrices[cascadeIndex], projectionMatrices[cascadeIndex], TempMat1);
    TempMat1.copyToArray(resultArray, cascadeIndex * 16);
  }
  return resultArray;
}
function OffsetWorldViewToRef(offset, worldView, view, ref) {
  InvertMatrixToRef(view, TempMat1);
  MultiplyMatricesToRef(worldView, TempMat1, TempMat2);
  OffsetWorldToRef(offset, TempMat2, TempMat1);
  OffsetViewToRef(offset, view, TempMat2);
  MultiplyMatricesToRef(TempMat1, TempMat2, ref);
  return ref;
}
function GetFullOffsetViewProjectionToRef(offset, viewMatrix, projectionMatrix, ref) {
  GetFullOffsetView(offset, viewMatrix, TempMat2);
  MultiplyMatricesToRef(TempMat2, projectionMatrix, ref);
  return ref;
}
function OffsetWorldViewProjectionToRef(offset, worldViewProjection, viewProjection, view, projection, ref) {
  InvertMatrixToRef(viewProjection, TempMat1);
  MultiplyMatricesToRef(worldViewProjection, TempMat1, TempMat2);
  OffsetWorldToRef(offset, TempMat2, TempMat1);
  OffsetViewProjectionToRef(offset, view, projection, TempMat2);
  MultiplyMatricesToRef(TempMat1, TempMat2, ref);
  return ref;
}
function GetOffsetMatrix(uniformName, mat) {
  const scene = FloatingOriginCurrentScene.getScene();
  if (!scene || TempFinalMat === mat) {
    return mat;
  }
  TempFinalMat.updateFlag = mat.updateFlag;
  const offset = scene.floatingOriginOffset;
  switch (uniformName) {
    case "world":
      return OffsetWorldToRef(offset, mat, TempFinalMat);
    case "view":
      return OffsetViewToRef(offset, mat, TempFinalMat);
    case "worldView":
      return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);
    case "viewProjection":
      return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
    case "worldViewProjection":
      return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
    default:
      if (uniformName.startsWith("u_")) {
        const lowercaseUniformName = uniformName.toLowerCase();
        if (lowercaseUniformName.startsWith("u_worldviewprojection")) {
          return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_viewprojection")) {
          return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_worldview")) {
          return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_world")) {
          return OffsetWorldToRef(offset, mat, TempFinalMat);
        }
        if (lowercaseUniformName.startsWith("u_view")) {
          return OffsetViewToRef(offset, mat, TempFinalMat);
        }
      }
      return mat;
  }
}
var UniformBufferInternal = UniformBuffer;
var EffectInternal = Effect;
var OriginalUpdateMatrixForUniform = UniformBufferInternal.prototype._updateMatrixForUniform;
var OriginalSetMatrix = Effect.prototype.setMatrix;
function ResetMatrixFunctions() {
  Effect.prototype.setMatrix = OriginalSetMatrix;
  EffectInternal._setMatrixOverride = void 0;
  UniformBufferInternal.prototype._updateMatrixForUniform = OriginalUpdateMatrixForUniform;
  UniformBufferInternal.prototype._updateMatrixForUniformOverride = void 0;
}
function OverrideMatrixFunctions() {
  EffectInternal.prototype._setMatrixOverride = OriginalSetMatrix;
  EffectInternal.prototype.setMatrix = function(uniformName, matrix) {
    this._setMatrixOverride(uniformName, GetOffsetMatrix(uniformName, matrix));
    return this;
  };
  UniformBufferInternal.prototype._updateMatrixForUniformOverride = OriginalUpdateMatrixForUniform;
  UniformBufferInternal.prototype._updateMatrixForUniform = function(uniformName, matrix) {
    this._updateMatrixForUniformOverride(uniformName, GetOffsetMatrix(uniformName, matrix));
  };
}

export {
  FloatingOriginCurrentScene,
  GetOffsetTransformMatrices,
  GetFullOffsetViewProjectionToRef,
  ResetMatrixFunctions,
  OverrideMatrixFunctions
};
//# sourceMappingURL=chunk-EWHDDCCY.js.map
