{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Particles/particleSystemComponent.ts"],
  "sourcesContent": ["import { Mesh } from \"../Meshes/mesh\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport type { Scene } from \"../scene\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport type { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { AddParser, AddIndividualParser, GetIndividualParser } from \"core/Loading/Plugins/babylonFileParser.function\";\r\n\r\n// Adds the parsers to the scene parsers.\r\nAddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    const individualParser = GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);\r\n\r\n    if (!individualParser) {\r\n        return;\r\n    }\r\n\r\n    // Particles Systems\r\n    if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {\r\n        for (let index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\r\n            const parsedParticleSystem = parsedData.particleSystems[index];\r\n            container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));\r\n        }\r\n    }\r\n});\r\n\r\nAddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, (parsedParticleSystem: any, scene: Scene, rootUrl: string) => {\r\n    if (parsedParticleSystem.activeParticleCount) {\r\n        const ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\r\n        return ps;\r\n    } else {\r\n        const ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\r\n        return ps;\r\n    }\r\n});\r\n\r\ndeclare module \"../Engines/abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Create an effect to use with particle systems.\r\n         * Please note that some parameters like animation sheets or not being billboard are not supported in this configuration, except if you pass\r\n         * the particle system for which you want to create a custom effect in the last parameter\r\n         * @param fragmentName defines the base name of the effect (The name of file without .fragment.fx)\r\n         * @param uniformsNames defines a list of attribute names\r\n         * @param samplers defines an array of string used to represent textures\r\n         * @param defines defines the string containing the defines to use to compile the shaders\r\n         * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails\r\n         * @param onCompiled defines a function to call when the effect creation is successful\r\n         * @param onError defines a function to call when the effect creation has failed\r\n         * @param particleSystem the particle system you want to create the effect for\r\n         * @param shaderLanguage defines the shader language to use\r\n         * @param vertexName defines the vertex base name of the effect (The name of file without .vertex.fx)\r\n         * @returns the new Effect\r\n         */\r\n        createEffectForParticles(\r\n            fragmentName: string,\r\n            uniformsNames: string[],\r\n            samplers: string[],\r\n            defines: string,\r\n            fallbacks?: EffectFallbacks,\r\n            onCompiled?: (effect: Effect) => void,\r\n            onError?: (effect: Effect, errors: string) => void,\r\n            particleSystem?: IParticleSystem,\r\n            shaderLanguage?: ShaderLanguage,\r\n            vertexName?: string\r\n        ): Effect;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype.createEffectForParticles = function (\r\n    fragmentName: string,\r\n    uniformsNames: string[] = [],\r\n    samplers: string[] = [],\r\n    defines = \"\",\r\n    fallbacks?: EffectFallbacks,\r\n    onCompiled?: (effect: Effect) => void,\r\n    onError?: (effect: Effect, errors: string) => void,\r\n    particleSystem?: IParticleSystem,\r\n    shaderLanguage = ShaderLanguage.GLSL,\r\n    vertexName?: string\r\n): Effect {\r\n    let attributesNamesOrOptions: Array<string> = [];\r\n    let effectCreationOption: Array<string> = [];\r\n    const allSamplers: Array<string> = [];\r\n\r\n    if (particleSystem) {\r\n        particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);\r\n    } else {\r\n        attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();\r\n        effectCreationOption = ParticleSystem._GetEffectCreationOptions();\r\n    }\r\n\r\n    if (defines.indexOf(\" BILLBOARD\") === -1) {\r\n        defines += \"\\n#define BILLBOARD\\n\";\r\n    }\r\n\r\n    if (particleSystem?.isAnimationSheetEnabled) {\r\n        if (defines.indexOf(\" ANIMATESHEET\") === -1) {\r\n            defines += \"\\n#define ANIMATESHEET\\n\";\r\n        }\r\n    }\r\n\r\n    if (samplers.indexOf(\"diffuseSampler\") === -1) {\r\n        samplers.push(\"diffuseSampler\");\r\n    }\r\n\r\n    return this.createEffect(\r\n        {\r\n            vertex: vertexName ?? particleSystem?.vertexShaderName ?? \"particles\",\r\n            fragmentElement: fragmentName,\r\n        },\r\n        attributesNamesOrOptions,\r\n        effectCreationOption.concat(uniformsNames),\r\n        allSamplers.concat(samplers),\r\n        defines,\r\n        fallbacks,\r\n        onCompiled,\r\n        onError,\r\n        undefined,\r\n        shaderLanguage,\r\n        async () => {\r\n            if (shaderLanguage === ShaderLanguage.GLSL) {\r\n                await import(\"../Shaders/particles.vertex\");\r\n            } else {\r\n                await import(\"../ShadersWGSL/particles.vertex\");\r\n            }\r\n        }\r\n    );\r\n};\r\n\r\ndeclare module \"../Meshes/mesh\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Mesh {\r\n        /**\r\n         * Returns an array populated with IParticleSystem objects whose the mesh is the emitter\r\n         * @returns an array of IParticleSystem\r\n         */\r\n        getEmittedParticleSystems(): IParticleSystem[];\r\n\r\n        /**\r\n         * Returns an array populated with IParticleSystem objects whose the mesh or its children are the emitter\r\n         * @returns an array of IParticleSystem\r\n         */\r\n        getHierarchyEmittedParticleSystems(): IParticleSystem[];\r\n    }\r\n}\r\n\r\nMesh.prototype.getEmittedParticleSystems = function (): IParticleSystem[] {\r\n    const results: IParticleSystem[] = [];\r\n    for (let index = 0; index < this.getScene().particleSystems.length; index++) {\r\n        const particleSystem = this.getScene().particleSystems[index];\r\n        if (particleSystem.emitter === this) {\r\n            results.push(particleSystem);\r\n        }\r\n    }\r\n    return results;\r\n};\r\n\r\nMesh.prototype.getHierarchyEmittedParticleSystems = function (): IParticleSystem[] {\r\n    const results: IParticleSystem[] = [];\r\n    const descendants = this.getDescendants();\r\n    descendants.push(this);\r\n\r\n    for (let index = 0; index < this.getScene().particleSystems.length; index++) {\r\n        const particleSystem = this.getScene().particleSystems[index];\r\n        const emitter: any = particleSystem.emitter;\r\n\r\n        if (emitter.position && descendants.indexOf(emitter) !== -1) {\r\n            results.push(particleSystem);\r\n        }\r\n    }\r\n\r\n    return results;\r\n};\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA,UAAU,wBAAwB,qBAAqB,CAAC,YAAiB,OAAc,WAA2B,YAAmB;AACjI,QAAM,mBAAmB,oBAAoB,wBAAwB,mBAAmB;AAExF,MAAI,CAAC,kBAAkB;AACnB;EACJ;AAGA,MAAI,WAAW,oBAAoB,UAAa,WAAW,oBAAoB,MAAM;AACjF,aAAS,QAAQ,GAAG,QAAQ,WAAW,gBAAgB,QAAQ,QAAQ,OAAO,SAAS;AACnF,YAAM,uBAAuB,WAAW,gBAAgB,KAAK;AAC7D,gBAAU,gBAAgB,KAAK,iBAAiB,sBAAsB,OAAO,OAAO,CAAC;IACzF;EACJ;AACJ,CAAC;AAED,oBAAoB,wBAAwB,qBAAqB,CAAC,sBAA2B,OAAc,YAAmB;AAC1H,MAAI,qBAAqB,qBAAqB;AAC1C,UAAM,KAAK,kBAAkB,MAAM,sBAAsB,OAAO,OAAO;AACvE,WAAO;EACX,OAAO;AACH,UAAM,KAAK,eAAe,MAAM,sBAAsB,OAAO,OAAO;AACpE,WAAO;EACX;AACJ,CAAC;AAoCD,eAAe,UAAU,2BAA2B,SAChD,cACA,gBAA0B,CAAA,GAC1B,WAAqB,CAAA,GACrB,UAAU,IACV,WACA,YACA,SACA,gBACA,iBAAc,GACd,YAAmB;AAEnB,MAAI,2BAA0C,CAAA;AAC9C,MAAI,uBAAsC,CAAA;AAC1C,QAAM,cAA6B,CAAA;AAEnC,MAAI,gBAAgB;AAChB,mBAAe,sCAAsC,sBAAsB,0BAA0B,WAAW;EACpH,OAAO;AACH,+BAA2B,eAAe,4BAA2B;AACrE,2BAAuB,eAAe,0BAAyB;EACnE;AAEA,MAAI,QAAQ,QAAQ,YAAY,MAAM,IAAI;AACtC,eAAW;EACf;AAEA,MAAI,gBAAgB,yBAAyB;AACzC,QAAI,QAAQ,QAAQ,eAAe,MAAM,IAAI;AACzC,iBAAW;IACf;EACJ;AAEA,MAAI,SAAS,QAAQ,gBAAgB,MAAM,IAAI;AAC3C,aAAS,KAAK,gBAAgB;EAClC;AAEA,SAAO,KAAK,aACR;IACI,QAAQ,cAAc,gBAAgB,oBAAoB;IAC1D,iBAAiB;KAErB,0BACA,qBAAqB,OAAO,aAAa,GACzC,YAAY,OAAO,QAAQ,GAC3B,SACA,WACA,YACA,SACA,QACA,gBACA,YAAW;AACP,QAAI,mBAAc,GAA0B;AACxC,YAAM,OAAO,gCAA+B;IAChD,OAAO;AACH,YAAM,OAAO,gCAAmC;IACpD;EACJ,CAAC;AAET;AAmBA,KAAK,UAAU,4BAA4B,WAAA;AACvC,QAAM,UAA6B,CAAA;AACnC,WAAS,QAAQ,GAAG,QAAQ,KAAK,SAAQ,EAAG,gBAAgB,QAAQ,SAAS;AACzE,UAAM,iBAAiB,KAAK,SAAQ,EAAG,gBAAgB,KAAK;AAC5D,QAAI,eAAe,YAAY,MAAM;AACjC,cAAQ,KAAK,cAAc;IAC/B;EACJ;AACA,SAAO;AACX;AAEA,KAAK,UAAU,qCAAqC,WAAA;AAChD,QAAM,UAA6B,CAAA;AACnC,QAAM,cAAc,KAAK,eAAc;AACvC,cAAY,KAAK,IAAI;AAErB,WAAS,QAAQ,GAAG,QAAQ,KAAK,SAAQ,EAAG,gBAAgB,QAAQ,SAAS;AACzE,UAAM,iBAAiB,KAAK,SAAQ,EAAG,gBAAgB,KAAK;AAC5D,UAAM,UAAe,eAAe;AAEpC,QAAI,QAAQ,YAAY,YAAY,QAAQ,OAAO,MAAM,IAAI;AACzD,cAAQ,KAAK,cAAc;IAC/B;EACJ;AAEA,SAAO;AACX;",
  "names": []
}
