{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/RenderPipeline/postProcessRenderEffect.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinCircleOfConfusionPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/circleOfConfusionPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinDepthOfFieldBlurPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/depthOfFieldBlurPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinDepthOfFieldMergePostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/depthOfFieldMergePostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinDepthOfFieldEffect.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/depthOfFieldEffect.ts"],
  "sourcesContent": ["import type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\n/**\r\n * This represents a set of one or more post processes in Babylon.\r\n * A post process can be used to apply a shader to a texture after it is rendered.\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n */\r\nexport class PostProcessRenderEffect {\r\n    private _postProcesses: { [Key: string]: Array<PostProcess> };\r\n    private _getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>;\r\n\r\n    private _singleInstance: boolean;\r\n\r\n    private _cameras: { [key: string]: Nullable<Camera> };\r\n    private _indicesForCamera: { [key: string]: number[] };\r\n\r\n    /**\r\n     * Name of the effect\r\n     * @internal\r\n     */\r\n    public _name: string;\r\n\r\n    /**\r\n     * Instantiates a post process render effect.\r\n     * A post process can be used to apply a shader to a texture after it is rendered.\r\n     * @param engine The engine the effect is tied to\r\n     * @param name The name of the effect\r\n     * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.\r\n     * @param singleInstance False if this post process can be run on multiple cameras. (default: true)\r\n     */\r\n    constructor(engine: AbstractEngine, name: string, getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>, singleInstance = true) {\r\n        this._name = name;\r\n        this._singleInstance = singleInstance;\r\n\r\n        this._getPostProcesses = getPostProcesses;\r\n\r\n        this._cameras = {};\r\n        this._indicesForCamera = {};\r\n\r\n        this._postProcesses = {};\r\n    }\r\n\r\n    /**\r\n     * Checks if all the post processes in the effect are supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        for (const index in this._postProcesses) {\r\n            if (Object.prototype.hasOwnProperty.call(this._postProcesses, index)) {\r\n                const pps = this._postProcesses[index];\r\n                for (let ppIndex = 0; ppIndex < pps.length; ppIndex++) {\r\n                    if (!pps[ppIndex].isSupported) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Updates the current state of the effect\r\n     * @internal\r\n     */\r\n    public _update(): void {}\r\n\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: Camera): void;\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: Camera[]): void;\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: any): void {\r\n        let cameraKey;\r\n\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            if (!camera) {\r\n                continue;\r\n            }\r\n\r\n            const cameraName = camera.name;\r\n\r\n            if (this._singleInstance) {\r\n                cameraKey = 0;\r\n            } else {\r\n                cameraKey = cameraName;\r\n            }\r\n\r\n            if (!this._postProcesses[cameraKey]) {\r\n                const postProcess = this._getPostProcesses();\r\n                if (postProcess) {\r\n                    this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];\r\n                }\r\n            }\r\n\r\n            if (!this._indicesForCamera[cameraName]) {\r\n                this._indicesForCamera[cameraName] = [];\r\n            }\r\n\r\n            const pps = this._postProcesses[cameraKey];\r\n            for (const postProcess of pps) {\r\n                const index = camera.attachPostProcess(postProcess);\r\n\r\n                this._indicesForCamera[cameraName].push(index);\r\n            }\r\n\r\n            if (!this._cameras[cameraName]) {\r\n                this._cameras[cameraName] = camera;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: Camera): void;\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: Camera[]): void;\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: any): void {\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera: Camera = cams[i];\r\n            const cameraName: string = camera.name;\r\n            const postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];\r\n\r\n            if (postProcesses) {\r\n                for (const postProcess of postProcesses) {\r\n                    camera.detachPostProcess(postProcess);\r\n                }\r\n            }\r\n\r\n            if (this._cameras[cameraName]) {\r\n                this._cameras[cameraName] = null;\r\n            }\r\n\r\n            delete this._indicesForCamera[cameraName];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @internal\r\n     */\r\n    public _enable(cameras: Camera): void;\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @internal\r\n     */\r\n    public _enable(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @internal\r\n     */\r\n    public _enable(cameras: any): void {\r\n        const cams: Nullable<Array<Camera>> = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            const cameraName = camera.name;\r\n            const cameraKey = this._singleInstance ? 0 : cameraName;\r\n\r\n            for (let j = 0; j < this._indicesForCamera[cameraName].length; j++) {\r\n                const index = this._indicesForCamera[cameraName][j];\r\n                const postProcess = camera._postProcesses[index];\r\n                if (postProcess === undefined || postProcess === null) {\r\n                    cams[i].attachPostProcess(this._postProcesses[cameraKey][j], index);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @internal\r\n     */\r\n    public _disable(cameras: Camera): void;\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @internal\r\n     */\r\n    public _disable(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @internal\r\n     */\r\n    public _disable(cameras: any): void {\r\n        const cams: Nullable<Array<Camera>> = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            const cameraName = camera.name;\r\n            const pps = this._postProcesses[this._singleInstance ? 0 : cameraName];\r\n            for (const postProcess of pps) {\r\n                camera.detachPostProcess(postProcess);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a list of the post processes contained in the effect.\r\n     * @param camera The camera to get the post processes on.\r\n     * @returns The list of the post processes in the effect.\r\n     */\r\n    public getPostProcesses(camera?: Camera): Nullable<Array<PostProcess>> {\r\n        if (this._singleInstance) {\r\n            return this._postProcesses[0];\r\n        } else {\r\n            if (!camera) {\r\n                return null;\r\n            }\r\n            return this._postProcesses[camera.name];\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable, AbstractEngine, EffectWrapperCreationOptions } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Options used to create a ThinCircleOfConfusionPostProcess.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface ThinCircleOfConfusionPostProcessOptions extends EffectWrapperCreationOptions {\r\n    /**\r\n     * If the (view) depth is normalized (0.0 to 1.0 from near to far) or not (0 to camera max distance)\r\n     */\r\n    depthNotNormalized?: boolean;\r\n}\r\n\r\n/**\r\n * Post process used to calculate the circle of confusion (used for depth of field, for example)\r\n */\r\nexport class ThinCircleOfConfusionPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"circleOfConfusion\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"cameraMinMaxZ\", \"focusDistance\", \"cocPrecalculation\"];\r\n\r\n    /**\r\n     * The list of samplers used by the effect\r\n     */\r\n    public static readonly Samplers = [\"depthSampler\"];\r\n\r\n    /**\r\n     * Defines if the depth is normalized or not\r\n     */\r\n    public static readonly DefinesDepthNotNormalized = \"#define COC_DEPTH_NOT_NORMALIZED\";\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/circleOfConfusion.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/circleOfConfusion.fragment\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructs a new circle of confusion post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: ThinCircleOfConfusionPostProcessOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinCircleOfConfusionPostProcess.FragmentUrl,\r\n            uniforms: ThinCircleOfConfusionPostProcess.Uniforms,\r\n            samplers: ThinCircleOfConfusionPostProcess.Samplers,\r\n            defines: options?.depthNotNormalized ? ThinCircleOfConfusionPostProcess.DefinesDepthNotNormalized : undefined,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The camera to use to calculate the circle of confusion\r\n     */\r\n    public camera: Camera;\r\n\r\n    /**\r\n     * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diameter of the resulting aperture can be computed by lensSize/fStop.\r\n     */\r\n    public lensSize = 50;\r\n\r\n    /**\r\n     * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)\r\n     */\r\n    public fStop = 1.4;\r\n\r\n    /**\r\n     * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)\r\n     */\r\n    public focusDistance = 2000;\r\n\r\n    /**\r\n     * Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)\r\n     */\r\n    public focalLength = 50;\r\n\r\n    public override bind(noDefaultBindings = false) {\r\n        super.bind(noDefaultBindings);\r\n\r\n        const options = this.options as ThinCircleOfConfusionPostProcessOptions;\r\n\r\n        const effect = this._drawWrapper.effect!;\r\n\r\n        if (!options.depthNotNormalized) {\r\n            effect.setFloat2(\"cameraMinMaxZ\", this.camera.minZ, this.camera.maxZ - this.camera.minZ);\r\n        }\r\n\r\n        // Circle of confusion calculation, See https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch23.html\r\n        const aperture = this.lensSize / this.fStop;\r\n        const cocPrecalculation = (aperture * this.focalLength) / (this.focusDistance - this.focalLength); // * ((this.focusDistance - pixelDistance)/pixelDistance) [This part is done in shader]\r\n\r\n        effect.setFloat(\"focusDistance\", this.focusDistance);\r\n        effect.setFloat(\"cocPrecalculation\", cocPrecalculation);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { ThinCircleOfConfusionPostProcessOptions } from \"./thinCircleOfConfusionPostProcess\";\r\nimport { ThinCircleOfConfusionPostProcess } from \"./thinCircleOfConfusionPostProcess\";\r\n\r\nexport type CircleOfConfusionPostProcessOptions = ThinCircleOfConfusionPostProcessOptions & PostProcessOptions;\r\n\r\n/**\r\n * The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion\r\n */\r\nexport class CircleOfConfusionPostProcess extends PostProcess {\r\n    /**\r\n     * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diameter of the resulting aperture can be computed by lensSize/fStop.\r\n     */\r\n    @serialize()\r\n    public get lensSize() {\r\n        return this._effectWrapper.lensSize;\r\n    }\r\n\r\n    public set lensSize(value: number) {\r\n        this._effectWrapper.lensSize = value;\r\n    }\r\n\r\n    /**\r\n     * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)\r\n     */\r\n    @serialize()\r\n    public get fStop() {\r\n        return this._effectWrapper.fStop;\r\n    }\r\n\r\n    public set fStop(value: number) {\r\n        this._effectWrapper.fStop = value;\r\n    }\r\n\r\n    /**\r\n     * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)\r\n     */\r\n    @serialize()\r\n    public get focusDistance() {\r\n        return this._effectWrapper.focusDistance;\r\n    }\r\n\r\n    public set focusDistance(value: number) {\r\n        this._effectWrapper.focusDistance = value;\r\n    }\r\n\r\n    /**\r\n     * Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)\r\n     */\r\n    @serialize()\r\n    public get focalLength() {\r\n        return this._effectWrapper.focalLength;\r\n    }\r\n\r\n    public set focalLength(value: number) {\r\n        this._effectWrapper.focalLength = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"CircleOfConfusionPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"CircleOfConfusionPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinCircleOfConfusionPostProcess;\r\n    private _depthTexture: Nullable<RenderTargetTexture> = null;\r\n\r\n    /**\r\n     * Creates a new instance CircleOfConfusionPostProcess\r\n     * @param name The name of the effect.\r\n     * @param depthTexture The depth texture of the scene to compute the circle of confusion. This must be set in order for this to function but may be set after initialization if needed.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        depthTexture: Nullable<RenderTargetTexture>,\r\n        options: number | CircleOfConfusionPostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            uniforms: ThinCircleOfConfusionPostProcess.Uniforms,\r\n            samplers: ThinCircleOfConfusionPostProcess.Samplers,\r\n            defines: typeof options === \"object\" && options.depthNotNormalized ? ThinCircleOfConfusionPostProcess.DefinesDepthNotNormalized : undefined,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinCircleOfConfusionPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinCircleOfConfusionPostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this._depthTexture = depthTexture;\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (!this._depthTexture) {\r\n                Logger.Warn(\"No depth texture set on CircleOfConfusionPostProcess\");\r\n                return;\r\n            }\r\n\r\n            effect.setTexture(\"depthSampler\", this._depthTexture);\r\n\r\n            this._effectWrapper.camera = this._depthTexture.activeCamera!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.\r\n     */\r\n    public set depthTexture(value: RenderTargetTexture) {\r\n        this._depthTexture = value;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.CircleOfConfusionPostProcess\", CircleOfConfusionPostProcess);\r\n", "import type { Nullable, AbstractEngine, EffectWrapperCreationOptions, Vector2 } from \"core/index\";\r\nimport { ThinBlurPostProcess } from \"./thinBlurPostProcess\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ThinDepthOfFieldBlurPostProcess extends ThinBlurPostProcess {\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, direction: Vector2, kernel: number, options?: EffectWrapperCreationOptions) {\r\n        super(name, engine, direction, kernel, {\r\n            ...options,\r\n            defines: `#define DOF 1\\n`,\r\n        });\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { PostProcess, PostProcessOptions } from \"./postProcess\";\r\nimport { BlurPostProcess } from \"./blurPostProcess\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { ThinDepthOfFieldBlurPostProcess } from \"./thinDepthOfFieldBlurPostProcess\";\r\n\r\n/**\r\n * The DepthOfFieldBlurPostProcess applied a blur in a give direction.\r\n * This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels\r\n * based on samples that have a large difference in distance than the center pixel.\r\n * See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf\r\n */\r\nexport class DepthOfFieldBlurPostProcess extends BlurPostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"DepthOfFieldBlurPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"DepthOfFieldBlurPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance DepthOfFieldBlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param _scene The scene the effect belongs to (not used, you can pass null)\r\n     * @param direction The direction the blur should be applied.\r\n     * @param kernel The size of the kernel used to blur.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param circleOfConfusion The circle of confusion + depth map to be used to avoid blurring across edges\r\n     * @param imageToBlur The image to apply the blur to (default: Current rendered frame)\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        _scene: Nullable<Scene>,\r\n        direction: Vector2,\r\n        kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        circleOfConfusion: PostProcess,\r\n        imageToBlur: Nullable<PostProcess> = null,\r\n        samplingMode = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        const localOptions = {\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n            samplingMode: (samplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE),\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            defines: `#define DOF 1\\n`,\r\n            blockCompilation,\r\n            textureFormat,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, direction, kernel, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinDepthOfFieldBlurPostProcess(name, engine, direction, kernel, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this.externalTextureSamplerBinding = !!imageToBlur;\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (imageToBlur != null) {\r\n                effect.setTextureFromPostProcess(\"textureSampler\", imageToBlur);\r\n            }\r\n            effect.setTextureFromPostProcessOutput(\"circleOfConfusionSampler\", circleOfConfusion);\r\n        });\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DepthOfFieldBlurPostProcess\", DepthOfFieldBlurPostProcess);\r\n", "import type { Nullable, AbstractEngine, EffectWrapperCreationOptions } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ThinDepthOfFieldMergePostProcess extends EffectWrapper {\r\n    public static readonly FragmentUrl = \"depthOfFieldMerge\";\r\n\r\n    public static readonly Samplers = [\"circleOfConfusionSampler\", \"blurStep0\", \"blurStep1\", \"blurStep2\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/depthOfFieldMerge.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/depthOfFieldMerge.fragment\"));\r\n        }\r\n    }\r\n\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinDepthOfFieldMergePostProcess.FragmentUrl,\r\n            samplers: ThinDepthOfFieldMergePostProcess.Samplers,\r\n        });\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { ThinDepthOfFieldMergePostProcess } from \"./thinDepthOfFieldMergePostProcess\";\r\n\r\n/**\r\n * The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.\r\n */\r\nexport class DepthOfFieldMergePostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"DepthOfFieldMergePostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"DepthOfFieldMergePostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of DepthOfFieldMergePostProcess\r\n     * @param name The name of the effect.\r\n     * @param originalFromInput Post process which's input will be used for the merge.\r\n     * @param circleOfConfusion Circle of confusion post process which's output will be used to blur each pixel.\r\n     * @param _blurSteps Blur post processes from low to high which will be mixed with the original image.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        originalFromInput: PostProcess,\r\n        circleOfConfusion: PostProcess,\r\n        private _blurSteps: Array<PostProcess>,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const blockCompilationFinal = typeof options === \"number\" ? blockCompilation : !!options.blockCompilation;\r\n        const localOptions = {\r\n            samplers: ThinDepthOfFieldMergePostProcess.Samplers,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            ...(options as PostProcessOptions),\r\n            blockCompilation: true,\r\n        };\r\n\r\n        super(name, ThinDepthOfFieldMergePostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinDepthOfFieldMergePostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this.externalTextureSamplerBinding = true;\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureSampler\", originalFromInput);\r\n            effect.setTextureFromPostProcessOutput(\"circleOfConfusionSampler\", circleOfConfusion);\r\n            for (let i = 0; i < _blurSteps.length; i++) {\r\n                const step = _blurSteps[i];\r\n                effect.setTextureFromPostProcessOutput(\"blurStep\" + (_blurSteps.length - i - 1), step);\r\n            }\r\n        });\r\n\r\n        if (!blockCompilationFinal) {\r\n            this.updateEffect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     */\r\n    public override updateEffect(\r\n        defines: Nullable<string> = null,\r\n        uniforms: Nullable<string[]> = null,\r\n        samplers: Nullable<string[]> = null,\r\n        indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void\r\n    ) {\r\n        if (!defines) {\r\n            defines = \"\";\r\n            defines += \"#define BLUR_LEVEL \" + (this._blurSteps.length - 1) + \"\\n\";\r\n        }\r\n        super.updateEffect(defines, uniforms, samplers, indexParameters, onCompiled, onError);\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { ThinDepthOfFieldBlurPostProcess } from \"./thinDepthOfFieldBlurPostProcess\";\r\nimport { ThinCircleOfConfusionPostProcess } from \"./thinCircleOfConfusionPostProcess\";\r\nimport { ThinDepthOfFieldMergePostProcess } from \"./thinDepthOfFieldMergePostProcess\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\n\r\n/**\r\n * Specifies the level of blur that should be applied when using the depth of field effect\r\n */\r\nexport const enum ThinDepthOfFieldEffectBlurLevel {\r\n    /**\r\n     * Subtle blur\r\n     */\r\n    Low,\r\n    /**\r\n     * Medium blur\r\n     */\r\n    Medium,\r\n    /**\r\n     * Large blur\r\n     */\r\n    High,\r\n}\r\n\r\nexport class ThinDepthOfFieldEffect {\r\n    /** @internal */\r\n    public readonly _circleOfConfusion: ThinCircleOfConfusionPostProcess;\r\n    /** @internal */\r\n    public readonly _depthOfFieldBlurX: Array<[ThinDepthOfFieldBlurPostProcess, number]> = [];\r\n    /** @internal */\r\n    public readonly _depthOfFieldBlurY: Array<[ThinDepthOfFieldBlurPostProcess, number]> = [];\r\n    /** @internal */\r\n    public readonly _dofMerge: ThinDepthOfFieldMergePostProcess;\r\n\r\n    /**\r\n     * The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)\r\n     */\r\n    public set focalLength(value: number) {\r\n        this._circleOfConfusion.focalLength = value;\r\n    }\r\n    public get focalLength() {\r\n        return this._circleOfConfusion.focalLength;\r\n    }\r\n    /**\r\n     * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)\r\n     */\r\n    public set fStop(value: number) {\r\n        this._circleOfConfusion.fStop = value;\r\n    }\r\n    public get fStop() {\r\n        return this._circleOfConfusion.fStop;\r\n    }\r\n    /**\r\n     * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)\r\n     */\r\n    public set focusDistance(value: number) {\r\n        this._circleOfConfusion.focusDistance = value;\r\n    }\r\n    public get focusDistance() {\r\n        return this._circleOfConfusion.focusDistance;\r\n    }\r\n    /**\r\n     * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diameter of the resulting aperture can be computed by lensSize/fStop.\r\n     */\r\n    public set lensSize(value: number) {\r\n        this._circleOfConfusion.lensSize = value;\r\n    }\r\n    public get lensSize() {\r\n        return this._circleOfConfusion.lensSize;\r\n    }\r\n\r\n    /**\r\n     * The quality of the effect.\r\n     */\r\n    public readonly blurLevel: ThinDepthOfFieldEffectBlurLevel;\r\n\r\n    /**\r\n     * Creates a new instance of @see ThinDepthOfFieldEffect\r\n     * @param name The name of the depth of field render effect\r\n     * @param engine The engine which the render effect will be applied. (default: current engine)\r\n     * @param blurLevel The quality of the effect. (default: DepthOfFieldEffectBlurLevel.Low)\r\n     * @param depthNotNormalized If the (view) depth used in circle of confusion post-process is normalized (0.0 to 1.0 from near to far) or not (0 to camera max distance) (default: false)\r\n     * @param blockCompilation If shaders should not be compiled when the effect is created (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        engine: Nullable<AbstractEngine>,\r\n        blurLevel: ThinDepthOfFieldEffectBlurLevel = ThinDepthOfFieldEffectBlurLevel.Low,\r\n        depthNotNormalized = false,\r\n        blockCompilation = false\r\n    ) {\r\n        this._circleOfConfusion = new ThinCircleOfConfusionPostProcess(name, engine, { depthNotNormalized, blockCompilation });\r\n        this.blurLevel = blurLevel;\r\n\r\n        let blurCount = 1;\r\n        let kernelSize = 15;\r\n        switch (blurLevel) {\r\n            case ThinDepthOfFieldEffectBlurLevel.High: {\r\n                blurCount = 3;\r\n                kernelSize = 51;\r\n                break;\r\n            }\r\n            case ThinDepthOfFieldEffectBlurLevel.Medium: {\r\n                blurCount = 2;\r\n                kernelSize = 31;\r\n                break;\r\n            }\r\n            default: {\r\n                kernelSize = 15;\r\n                blurCount = 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        const adjustedKernelSize = kernelSize / Math.pow(2, blurCount - 1);\r\n        let ratio = 1.0;\r\n        for (let i = 0; i < blurCount; i++) {\r\n            this._depthOfFieldBlurY.push([new ThinDepthOfFieldBlurPostProcess(name, engine, new Vector2(0, 1), adjustedKernelSize, { blockCompilation }), ratio]);\r\n            ratio = 0.75 / Math.pow(2, i);\r\n            this._depthOfFieldBlurX.push([new ThinDepthOfFieldBlurPostProcess(name, engine, new Vector2(1, 0), adjustedKernelSize, { blockCompilation }), ratio]);\r\n        }\r\n\r\n        this._dofMerge = new ThinDepthOfFieldMergePostProcess(name, engine, { blockCompilation });\r\n    }\r\n\r\n    /**\r\n     * Checks if the effect is ready to be used\r\n     * @returns if the effect is ready\r\n     */\r\n    public isReady() {\r\n        let isReady = this._circleOfConfusion.isReady() && this._dofMerge.isReady();\r\n        for (let i = 0; i < this._depthOfFieldBlurX.length; i++) {\r\n            isReady = isReady && this._depthOfFieldBlurX[i][0].isReady() && this._depthOfFieldBlurY[i][0].isReady();\r\n        }\r\n        return isReady;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { PostProcess } from \"./postProcess\";\r\nimport { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { CircleOfConfusionPostProcess } from \"./circleOfConfusionPostProcess\";\r\nimport { DepthOfFieldBlurPostProcess } from \"./depthOfFieldBlurPostProcess\";\r\nimport { DepthOfFieldMergePostProcess } from \"./depthOfFieldMergePostProcess\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { ThinDepthOfFieldEffectBlurLevel } from \"./thinDepthOfFieldEffect\";\r\nimport { ThinDepthOfFieldEffect } from \"./thinDepthOfFieldEffect\";\r\n\r\n/**\r\n * Specifies the level of max blur that should be applied when using the depth of field effect\r\n */\r\nexport const enum DepthOfFieldEffectBlurLevel {\r\n    /**\r\n     * Subtle blur\r\n     */\r\n    Low,\r\n    /**\r\n     * Medium blur\r\n     */\r\n    Medium,\r\n    /**\r\n     * Large blur\r\n     */\r\n    High,\r\n}\r\n\r\n/**\r\n * The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.\r\n */\r\nexport class DepthOfFieldEffect extends PostProcessRenderEffect {\r\n    private _circleOfConfusion: CircleOfConfusionPostProcess;\r\n    /**\r\n     * @internal Internal, blurs from high to low\r\n     */\r\n    public _depthOfFieldBlurX: Array<DepthOfFieldBlurPostProcess>;\r\n    private _depthOfFieldBlurY: Array<DepthOfFieldBlurPostProcess>;\r\n    private _dofMerge: Nullable<DepthOfFieldMergePostProcess>;\r\n\r\n    /**\r\n     * @internal Internal post processes in depth of field effect\r\n     */\r\n    public _effects: Array<PostProcess> = [];\r\n\r\n    /**\r\n     * The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)\r\n     */\r\n    public set focalLength(value: number) {\r\n        this._thinDepthOfFieldEffect.focalLength = value;\r\n    }\r\n    public get focalLength() {\r\n        return this._thinDepthOfFieldEffect.focalLength;\r\n    }\r\n    /**\r\n     * F-Stop of the effect's camera. The diameter of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)\r\n     */\r\n    public set fStop(value: number) {\r\n        this._thinDepthOfFieldEffect.fStop = value;\r\n    }\r\n    public get fStop() {\r\n        return this._thinDepthOfFieldEffect.fStop;\r\n    }\r\n    /**\r\n     * Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)\r\n     */\r\n    public set focusDistance(value: number) {\r\n        this._thinDepthOfFieldEffect.focusDistance = value;\r\n    }\r\n    public get focusDistance() {\r\n        return this._thinDepthOfFieldEffect.focusDistance;\r\n    }\r\n    /**\r\n     * Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diameter of the resulting aperture can be computed by lensSize/fStop.\r\n     */\r\n    public set lensSize(value: number) {\r\n        this._thinDepthOfFieldEffect.lensSize = value;\r\n    }\r\n    public get lensSize() {\r\n        return this._thinDepthOfFieldEffect.lensSize;\r\n    }\r\n\r\n    private _thinDepthOfFieldEffect: ThinDepthOfFieldEffect;\r\n\r\n    /**\r\n     * Creates a new instance DepthOfFieldEffect\r\n     * @param sceneOrEngine The scene or engine the effect belongs to.\r\n     * @param depthTexture The depth texture of the scene to compute the circle of confusion.This must be set in order for this to function but may be set after initialization if needed.\r\n     * @param blurLevel\r\n     * @param pipelineTextureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     * @param depthNotNormalized If the depth from the depth texture is already normalized or if the normalization should be done at runtime in the shader (default: false)\r\n     */\r\n    constructor(\r\n        sceneOrEngine: Scene | AbstractEngine,\r\n        depthTexture: Nullable<RenderTargetTexture>,\r\n        blurLevel: DepthOfFieldEffectBlurLevel = DepthOfFieldEffectBlurLevel.Low,\r\n        pipelineTextureType = 0,\r\n        blockCompilation = false,\r\n        depthNotNormalized = false\r\n    ) {\r\n        const engine = (sceneOrEngine as Scene)._renderForCamera ? (sceneOrEngine as Scene).getEngine() : (sceneOrEngine as AbstractEngine);\r\n        super(\r\n            engine,\r\n            \"depth of field\",\r\n            () => {\r\n                return this._effects;\r\n            },\r\n            true\r\n        );\r\n\r\n        this._thinDepthOfFieldEffect = new ThinDepthOfFieldEffect(\"Depth of Field\", engine, blurLevel as unknown as ThinDepthOfFieldEffectBlurLevel, false, blockCompilation);\r\n\r\n        // Use R-only formats if supported to store the circle of confusion values.\r\n        // This should be more space and bandwidth efficient than using RGBA.\r\n        const circleOfConfusionTextureFormat = engine.isWebGPU || engine.version > 1 ? Constants.TEXTUREFORMAT_RED : Constants.TEXTUREFORMAT_RGBA;\r\n\r\n        // Circle of confusion value for each pixel is used to determine how much to blur that pixel\r\n        this._circleOfConfusion = new CircleOfConfusionPostProcess(\r\n            \"circleOfConfusion\",\r\n            depthTexture,\r\n            {\r\n                size: 1,\r\n                samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                textureType: pipelineTextureType,\r\n                blockCompilation,\r\n                depthNotNormalized,\r\n                effectWrapper: this._thinDepthOfFieldEffect._circleOfConfusion,\r\n            },\r\n            null\r\n        );\r\n\r\n        // Create a pyramid of blurred images (eg. fullSize 1/4 blur, half size 1/2 blur, quarter size 3/4 blur, eith size 4/4 blur)\r\n        // Blur the image but do not blur on sharp far to near distance changes to avoid bleeding artifacts\r\n        // See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf\r\n        this._depthOfFieldBlurY = [];\r\n        this._depthOfFieldBlurX = [];\r\n\r\n        const blurCount = this._thinDepthOfFieldEffect._depthOfFieldBlurX.length;\r\n\r\n        for (let i = 0; i < blurCount; i++) {\r\n            const [thinBlurY, ratioY] = this._thinDepthOfFieldEffect._depthOfFieldBlurY[i];\r\n            const blurY = new DepthOfFieldBlurPostProcess(\r\n                \"vertical blur\",\r\n                null,\r\n                thinBlurY.direction,\r\n                thinBlurY.kernel,\r\n                {\r\n                    size: ratioY,\r\n                    samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n                    engine,\r\n                    textureType: pipelineTextureType,\r\n                    blockCompilation,\r\n                    textureFormat: i == 0 ? circleOfConfusionTextureFormat : Constants.TEXTUREFORMAT_RGBA,\r\n                    effectWrapper: thinBlurY,\r\n                },\r\n                null,\r\n                this._circleOfConfusion,\r\n                i == 0 ? this._circleOfConfusion : null\r\n            );\r\n            blurY.autoClear = false;\r\n\r\n            const [thinBlurX, ratioX] = this._thinDepthOfFieldEffect._depthOfFieldBlurX[i];\r\n            const blurX = new DepthOfFieldBlurPostProcess(\r\n                \"horizontal blur\",\r\n                null,\r\n                thinBlurX.direction,\r\n                thinBlurX.kernel,\r\n                {\r\n                    size: ratioX,\r\n                    samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n                    engine,\r\n                    textureType: pipelineTextureType,\r\n                    blockCompilation,\r\n                    effectWrapper: thinBlurX,\r\n                },\r\n                null,\r\n                this._circleOfConfusion,\r\n                null\r\n            );\r\n            blurX.autoClear = false;\r\n            this._depthOfFieldBlurY.push(blurY);\r\n            this._depthOfFieldBlurX.push(blurX);\r\n        }\r\n\r\n        // Set all post processes on the effect.\r\n        this._effects = [this._circleOfConfusion];\r\n        for (let i = 0; i < this._depthOfFieldBlurX.length; i++) {\r\n            this._effects.push(this._depthOfFieldBlurY[i]);\r\n            this._effects.push(this._depthOfFieldBlurX[i]);\r\n        }\r\n\r\n        // Merge blurred images with original image based on circleOfConfusion\r\n        this._dofMerge = new DepthOfFieldMergePostProcess(\r\n            \"dofMerge\",\r\n            this._circleOfConfusion,\r\n            this._circleOfConfusion,\r\n            this._depthOfFieldBlurX,\r\n            {\r\n                size: this._thinDepthOfFieldEffect._depthOfFieldBlurX[blurCount - 1][1],\r\n                samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                textureType: pipelineTextureType,\r\n                blockCompilation,\r\n                effectWrapper: this._thinDepthOfFieldEffect._dofMerge,\r\n            },\r\n            null\r\n        );\r\n        this._dofMerge.autoClear = false;\r\n        this._effects.push(this._dofMerge);\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the current effect\r\n     * @returns \"DepthOfFieldEffect\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DepthOfFieldEffect\";\r\n    }\r\n\r\n    /**\r\n     * Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.\r\n     */\r\n    public set depthTexture(value: RenderTargetTexture) {\r\n        this._circleOfConfusion.depthTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Disposes each of the internal effects for a given camera.\r\n     * @param camera The camera to dispose the effect on.\r\n     */\r\n    public disposeEffects(camera: Camera) {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].dispose(camera);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _updateEffects() {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].updateEffect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal\r\n     * @returns if all the contained post processes are ready.\r\n     * @internal\r\n     */\r\n    public _isReady() {\r\n        return this._thinDepthOfFieldEffect.isReady();\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["ThinDepthOfFieldEffectBlurLevel", "DepthOfFieldEffectBlurLevel"]
}
