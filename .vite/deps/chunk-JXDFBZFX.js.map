{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/RenderPipeline/postProcessRenderPipelineManager.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.ts"],
  "sourcesContent": ["import type { Camera, IReadonlyObservable, PostProcessRenderPipeline } from \"core/index\";\r\n\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * PostProcessRenderPipelineManager class\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n */\r\nexport class PostProcessRenderPipelineManager {\r\n    private readonly _renderPipelines: { [Key: string]: PostProcessRenderPipeline } = {};\r\n    private readonly _onNewPipelineAddedObservable = new Observable<PostProcessRenderPipeline>();\r\n    private readonly _onPipelineRemovedObservable = new Observable<PostProcessRenderPipeline>();\r\n\r\n    /**\r\n     * Initializes a PostProcessRenderPipelineManager\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * An event triggered when a pipeline is added to the manager\r\n     */\r\n    public get onNewPipelineAddedObservable(): IReadonlyObservable<PostProcessRenderPipeline> {\r\n        return this._onNewPipelineAddedObservable;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when a pipeline is removed from the manager\r\n     */\r\n    public get onPipelineRemovedObservable(): IReadonlyObservable<PostProcessRenderPipeline> {\r\n        return this._onPipelineRemovedObservable;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of supported render pipelines\r\n     */\r\n    public get supportedPipelines(): PostProcessRenderPipeline[] {\r\n        const result = [];\r\n\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                if (pipeline.isSupported) {\r\n                    result.push(pipeline);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a pipeline to the manager\r\n     * @param renderPipeline The pipeline to add\r\n     */\r\n    public addPipeline(renderPipeline: PostProcessRenderPipeline): void {\r\n        this.removePipeline(renderPipeline._name);\r\n        this._renderPipelines[renderPipeline._name] = renderPipeline;\r\n        this._onNewPipelineAddedObservable.notifyObservers(renderPipeline);\r\n    }\r\n\r\n    /**\r\n     * Remove the pipeline from the manager\r\n     * @param renderPipelineName the name of the pipeline to remove\r\n     */\r\n    public removePipeline(renderPipelineName: string): void {\r\n        const pipeline = this._renderPipelines[renderPipelineName];\r\n        if (pipeline) {\r\n            this._onPipelineRemovedObservable.notifyObservers(pipeline);\r\n            delete this._renderPipelines[renderPipelineName];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attaches a camera to the pipeline\r\n     * @param renderPipelineName The name of the pipeline to attach to\r\n     * @param cameras the camera to attach\r\n     * @param unique if the camera can be attached multiple times to the pipeline\r\n     */\r\n    public attachCamerasToRenderPipeline(renderPipelineName: string, cameras: Camera[] | Camera, unique: boolean = false): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._attachCameras(cameras as Camera[], unique);\r\n    }\r\n\r\n    /**\r\n     * Detaches a camera from the pipeline\r\n     * @param renderPipelineName The name of the pipeline to detach from\r\n     * @param cameras the camera to detach\r\n     */\r\n    public detachCamerasFromRenderPipeline(renderPipelineName: string, cameras: Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._detachCameras(cameras as Camera[]);\r\n    }\r\n\r\n    /**\r\n     * Enables an effect by name on a pipeline\r\n     * @param renderPipelineName the name of the pipeline to enable the effect in\r\n     * @param renderEffectName the name of the effect to enable\r\n     * @param cameras the cameras that the effect should be enabled on\r\n     */\r\n    public enableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._enableEffect(renderEffectName, cameras as Camera[]);\r\n    }\r\n\r\n    /**\r\n     * Disables an effect by name on a pipeline\r\n     * @param renderPipelineName the name of the pipeline to disable the effect in\r\n     * @param renderEffectName the name of the effect to disable\r\n     * @param cameras the cameras that the effect should be disabled on\r\n     */\r\n    public disableEffectInPipeline(renderPipelineName: string, renderEffectName: string, cameras: Camera[] | Camera): void {\r\n        const renderPipeline: PostProcessRenderPipeline = this._renderPipelines[renderPipelineName];\r\n\r\n        if (!renderPipeline) {\r\n            return;\r\n        }\r\n\r\n        renderPipeline._disableEffect(renderEffectName, cameras as Camera[]);\r\n    }\r\n\r\n    /**\r\n     * Updates the state of all contained render pipelines and disposes of any non supported pipelines\r\n     */\r\n    public update(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                if (!pipeline.isSupported) {\r\n                    pipeline.dispose();\r\n                    delete this._renderPipelines[renderPipelineName];\r\n                } else {\r\n                    pipeline._update();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                pipeline._rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the manager and pipelines\r\n     */\r\n    public dispose(): void {\r\n        for (const renderPipelineName in this._renderPipelines) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderPipelines, renderPipelineName)) {\r\n                const pipeline = this._renderPipelines[renderPipelineName];\r\n                pipeline.dispose();\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import type { ISceneComponent } from \"../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { PostProcessRenderPipelineManager } from \"./postProcessRenderPipelineManager\";\r\nimport { Scene } from \"../../scene\";\r\n\r\ndeclare module \"../../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _postProcessRenderPipelineManager: PostProcessRenderPipelineManager;\r\n\r\n        /**\r\n         * Gets the postprocess render pipeline manager\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/defaultRenderingPipeline\r\n         */\r\n        readonly postProcessRenderPipelineManager: PostProcessRenderPipelineManager;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"postProcessRenderPipelineManager\", {\r\n    get: function (this: Scene) {\r\n        if (!this._postProcessRenderPipelineManager) {\r\n            // Register the G Buffer component to the scene.\r\n            let component = this._getComponent(SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER) as PostProcessRenderPipelineManagerSceneComponent;\r\n            if (!component) {\r\n                component = new PostProcessRenderPipelineManagerSceneComponent(this);\r\n                this._addComponent(component);\r\n            }\r\n            this._postProcessRenderPipelineManager = new PostProcessRenderPipelineManager();\r\n        }\r\n\r\n        return this._postProcessRenderPipelineManager;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Defines the Render Pipeline scene component responsible to rendering pipelines\r\n */\r\nexport class PostProcessRenderPipelineManagerSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        if (this.scene._postProcessRenderPipelineManager) {\r\n            this.scene._postProcessRenderPipelineManager._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this.scene._postProcessRenderPipelineManager) {\r\n            this.scene._postProcessRenderPipelineManager.dispose();\r\n        }\r\n    }\r\n\r\n    private _gatherRenderTargets(): void {\r\n        if (this.scene._postProcessRenderPipelineManager) {\r\n            this.scene._postProcessRenderPipelineManager.update();\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
