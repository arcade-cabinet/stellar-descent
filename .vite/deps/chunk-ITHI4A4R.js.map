{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Animations/runtimeAnimation.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Animations/animatable.core.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Animations/animatable.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { _IAnimationState } from \"./animation\";\r\nimport {\r\n    Animation,\r\n    _StaticOffsetValueColor3,\r\n    _StaticOffsetValueColor4,\r\n    _StaticOffsetValueQuaternion,\r\n    _StaticOffsetValueSize,\r\n    _StaticOffsetValueVector2,\r\n    _StaticOffsetValueVector3,\r\n} from \"./animation\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport type { Animatable } from \"./animatable\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\n/**\r\n * Defines a runtime animation\r\n */\r\nexport class RuntimeAnimation {\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * The current frame of the runtime animation\r\n     */\r\n    private _currentFrame: number = 0;\r\n\r\n    /**\r\n     * The animation used by the runtime animation\r\n     */\r\n    public _animation: Animation;\r\n\r\n    /**\r\n     * The target of the runtime animation\r\n     */\r\n    private _target: any;\r\n\r\n    /**\r\n     * The initiating animatable\r\n     */\r\n    private _host: Animatable;\r\n\r\n    /**\r\n     * The original value of the runtime animation\r\n     */\r\n    private _originalValue = new Array<any>();\r\n\r\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\r\n    private _originalBlendValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\r\n    private _offsetsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\r\n    private _highLimitsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\r\n    private _stopped = false;\r\n\r\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\r\n    private _blendingFactor = 0;\r\n\r\n    /**\r\n     * The BabylonJS scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The current value of the runtime animation\r\n     */\r\n    private _currentValue: Nullable<any> = null;\r\n\r\n    /** @internal */\r\n    public _animationState: _IAnimationState;\r\n\r\n    /**\r\n     * The active target of the runtime animation\r\n     */\r\n    private _activeTargets: any[];\r\n    private _currentActiveTarget: Nullable<any> = null;\r\n    private _directTarget: Nullable<any> = null;\r\n\r\n    /**\r\n     * The target path of the runtime animation\r\n     */\r\n    private _targetPath: string = \"\";\r\n\r\n    /**\r\n     * The weight of the runtime animation\r\n     */\r\n    private _weight = 1.0;\r\n\r\n    /**\r\n     * The absolute frame offset of the runtime animation\r\n     */\r\n    private _absoluteFrameOffset = 0;\r\n\r\n    /**\r\n     * The previous elapsed time (since start of animation) of the runtime animation\r\n     */\r\n    private _previousElapsedTime: number = 0;\r\n\r\n    private _yoyoDirection: number = 1;\r\n\r\n    /**\r\n     * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\r\n     */\r\n    private _previousAbsoluteFrame: number = 0;\r\n\r\n    private _enableBlending: boolean;\r\n\r\n    private _keys: IAnimationKey[];\r\n    private _minFrame: number;\r\n    private _maxFrame: number;\r\n    private _targetIsArray = false;\r\n\r\n    /** @internal */\r\n    public _coreRuntimeAnimation: RuntimeAnimation | null = null;\r\n\r\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\r\n    public get currentFrame(): number {\r\n        return this._currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\r\n    public get currentValue(): any {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target path of the runtime animation\r\n     */\r\n    public get targetPath(): string {\r\n        return this._targetPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\r\n    public get target(): any {\r\n        return this._currentActiveTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._host && this._host.isAdditive;\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLoop: () => void;\r\n\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    public constructor(target: any, animation: Animation, scene: Scene, host: Animatable) {\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n\r\n        animation._runtimeAnimations.push(this);\r\n\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode(),\r\n        };\r\n\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            const newKey = { frame: 0, value: this._keys[0].value };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            let index = 0;\r\n            for (const target of this._target) {\r\n                this._preparePath(target, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        } else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n\r\n        // Cloning events locally\r\n        const events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            for (const e of events) {\r\n                this._events.push(e._clone());\r\n            }\r\n        }\r\n\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n\r\n    private _preparePath(target: any, targetIndex = 0) {\r\n        const targetPropertyPath = this._animation.targetPropertyPath;\r\n\r\n        if (targetPropertyPath.length > 1) {\r\n            let property = target;\r\n            for (let index = 0; index < targetPropertyPath.length - 1; index++) {\r\n                const name = targetPropertyPath[index];\r\n                property = property[name];\r\n                if (property === undefined) {\r\n                    throw new Error(`Invalid property (${name}) in property path (${targetPropertyPath.join(\".\")})`);\r\n                }\r\n            }\r\n\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        } else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n\r\n        if (this._activeTargets[targetIndex][this._targetPath] === undefined) {\r\n            throw new Error(`Invalid property (${this._targetPath}) in property path (${targetPropertyPath.join(\".\")})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\r\n    public get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    public reset(restoreOriginal = false): void {\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                let index = 0;\r\n                for (const target of this._target) {\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            } else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n\r\n        // Events\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    public dispose(): void {\r\n        const index = this._animation.runtimeAnimations.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    public setValue(currentValue: any, weight: number) {\r\n        if (this._targetIsArray) {\r\n            for (let index = 0; index < this._target.length; index++) {\r\n                const target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    }\r\n\r\n    private _getOriginalValues(targetIndex = 0) {\r\n        let originalValue: any;\r\n        const target = this._activeTargets[targetIndex];\r\n\r\n        if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\r\n            // For bones\r\n            originalValue = target.getLocalMatrix();\r\n        } else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        } else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    }\r\n\r\n    private _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n        const target = runtimeAnimation.target;\r\n        this._scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n        if (!target._lateAnimationHolders) {\r\n            target._lateAnimationHolders = {};\r\n        }\r\n\r\n        if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n                totalWeight: 0,\r\n                totalAdditiveWeight: 0,\r\n                animations: [],\r\n                additiveAnimations: [],\r\n                originalValue: originalValue,\r\n            };\r\n        }\r\n\r\n        if (runtimeAnimation.isAdditive) {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n        } else {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n        }\r\n    }\r\n\r\n    private _setValue(target: any, destination: any, currentValue: any, weight: number, targetIndex: number): void {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n\r\n        this._weight = weight;\r\n\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                const originalValue = destination[this._targetPath];\r\n\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                } else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n\r\n            if (this._originalBlendValue.m) {\r\n                // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                } else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            } else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n\r\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        } else {\r\n            if (!this._currentValue) {\r\n                if (currentValue?.clone) {\r\n                    this._currentValue = currentValue.clone();\r\n                } else {\r\n                    this._currentValue = currentValue;\r\n                }\r\n            } else if (this._currentValue.copyFrom) {\r\n                this._currentValue.copyFrom(currentValue);\r\n            } else {\r\n                this._currentValue = currentValue;\r\n            }\r\n        }\r\n\r\n        if (weight !== -1.0) {\r\n            this._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        } else {\r\n            if (this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT) {\r\n                if (this._currentValue.addToRef) {\r\n                    this._currentValue.addToRef(this._originalValue[targetIndex], destination[this._targetPath]);\r\n                } else {\r\n                    destination[this._targetPath] = this._originalValue[targetIndex] + this._currentValue;\r\n                }\r\n            } else {\r\n                destination[this._targetPath] = this._currentValue;\r\n            }\r\n        }\r\n\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    private _getCorrectLoopMode(): number | undefined {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode as number;\r\n        }\r\n\r\n        return this._animation.loopMode;\r\n    }\r\n\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     * @param weight defines the weight to apply to the animation (-1.0 by default)\r\n     */\r\n    public goToFrame(frame: number, weight = -1): void {\r\n        const keys = this._animation.getKeys();\r\n\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        } else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        // Need to reset animation events\r\n        const events = this._events;\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._currentFrame = frame;\r\n        const currentValue = this._animation._interpolate(frame, this._animationState);\r\n\r\n        this.setValue(currentValue, weight);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _prepareForSpeedRatioChange(newSpeedRatio: number): void {\r\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\r\n\r\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\r\n    }\r\n\r\n    /**\r\n     * Execute the current animation\r\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\r\n     * @param from defines the lower frame of the animation range\r\n     * @param to defines the upper frame of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    public animate(elapsedTimeSinceAnimationStart: number, from: number, to: number, loop: boolean, speedRatio: number, weight = -1.0): boolean {\r\n        const animation = this._animation;\r\n        const targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n\r\n        let returnValue = true;\r\n        let currentFrame: number;\r\n        const events = this._events;\r\n        let frameRange = 0;\r\n\r\n        if (!this._coreRuntimeAnimation) {\r\n            // Check limits\r\n            if (from < this._minFrame || from > this._maxFrame) {\r\n                from = this._minFrame;\r\n            }\r\n            if (to < this._minFrame || to > this._maxFrame) {\r\n                to = this._maxFrame;\r\n            }\r\n\r\n            frameRange = to - from;\r\n            let offsetValue: any;\r\n\r\n            // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\r\n            let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\r\n            let highLimitValue = 0;\r\n\r\n            // Apply the yoyo function if required\r\n            let yoyoLoop = false;\r\n            const yoyoMode = loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO;\r\n            if (yoyoMode) {\r\n                const position = (absoluteFrame - from) / frameRange;\r\n\r\n                // Apply the yoyo curve\r\n                const sin = Math.sin(position * Math.PI);\r\n                const yoyoPosition = Math.abs(sin);\r\n\r\n                // Map the yoyo position back to the range\r\n                absoluteFrame = yoyoPosition * frameRange + from;\r\n\r\n                const direction = sin >= 0 ? 1 : -1;\r\n                if (this._yoyoDirection !== direction) {\r\n                    yoyoLoop = true;\r\n                }\r\n\r\n                this._yoyoDirection = direction;\r\n            }\r\n\r\n            this._previousElapsedTime = elapsedTimeSinceAnimationStart;\r\n            this._previousAbsoluteFrame = absoluteFrame;\r\n\r\n            if (!loop && to >= from && ((absoluteFrame >= frameRange && speedRatio > 0) || (absoluteFrame <= 0 && speedRatio < 0))) {\r\n                // If we are out of range and not looping get back to caller\r\n                returnValue = false;\r\n                highLimitValue = animation.evaluate(to);\r\n            } else if (!loop && from >= to && ((absoluteFrame <= frameRange && speedRatio < 0) || (absoluteFrame >= 0 && speedRatio > 0))) {\r\n                returnValue = false;\r\n                highLimitValue = animation.evaluate(from);\r\n            } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n                const keyOffset = to.toString() + from.toString();\r\n                if (!this._offsetsCache[keyOffset]) {\r\n                    this._animationState.repeatCount = 0;\r\n                    this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\r\n                    const fromValue = animation._interpolate(from, this._animationState);\r\n                    const toValue = animation._interpolate(to, this._animationState);\r\n\r\n                    this._animationState.loopMode = this._getCorrectLoopMode();\r\n                    switch (animation.dataType) {\r\n                        // Float\r\n                        case Animation.ANIMATIONTYPE_FLOAT:\r\n                            this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                            break;\r\n                        // Quaternion\r\n                        case Animation.ANIMATIONTYPE_QUATERNION:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Vector3\r\n                        case Animation.ANIMATIONTYPE_VECTOR3:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Vector2\r\n                        case Animation.ANIMATIONTYPE_VECTOR2:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Size\r\n                        case Animation.ANIMATIONTYPE_SIZE:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Color3\r\n                        case Animation.ANIMATIONTYPE_COLOR3:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n\r\n                    this._highLimitsCache[keyOffset] = toValue;\r\n                }\r\n\r\n                highLimitValue = this._highLimitsCache[keyOffset];\r\n                offsetValue = this._offsetsCache[keyOffset];\r\n            }\r\n\r\n            if (offsetValue === undefined) {\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        offsetValue = 0;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        offsetValue = _StaticOffsetValueQuaternion;\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        offsetValue = _StaticOffsetValueVector3;\r\n                        break;\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        offsetValue = _StaticOffsetValueVector2;\r\n                        break;\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        offsetValue = _StaticOffsetValueSize;\r\n                        break;\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        offsetValue = _StaticOffsetValueColor3;\r\n                        break;\r\n                    case Animation.ANIMATIONTYPE_COLOR4:\r\n                        offsetValue = _StaticOffsetValueColor4;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Compute value\r\n\r\n            if (this._host && this._host.syncRoot) {\r\n                // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\r\n                const syncRoot = this._host.syncRoot;\r\n                const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n                currentFrame = from + frameRange * hostNormalizedFrame;\r\n            } else {\r\n                if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\r\n                    currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\r\n                } else {\r\n                    currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\r\n                }\r\n            }\r\n\r\n            // Reset event/state if looping\r\n            if ((!yoyoMode && ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame))) || (yoyoMode && yoyoLoop)) {\r\n                this._onLoop();\r\n\r\n                // Need to reset animation events\r\n                for (let index = 0; index < events.length; index++) {\r\n                    if (!events[index].onlyOnce) {\r\n                        // reset event, the animation is looping\r\n                        events[index].isDone = false;\r\n                    }\r\n                }\r\n\r\n                this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\r\n            }\r\n            this._currentFrame = currentFrame;\r\n            this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\r\n            this._animationState.highLimitValue = highLimitValue;\r\n            this._animationState.offsetValue = offsetValue;\r\n        } else {\r\n            frameRange = to - from;\r\n            currentFrame = this._coreRuntimeAnimation.currentFrame;\r\n            this._currentFrame = currentFrame;\r\n            this._animationState.repeatCount = this._coreRuntimeAnimation._animationState.repeatCount;\r\n            this._animationState.highLimitValue = this._coreRuntimeAnimation._animationState.highLimitValue;\r\n            this._animationState.offsetValue = this._coreRuntimeAnimation._animationState.offsetValue;\r\n        }\r\n\r\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\r\n\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n\r\n        // Check events\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if (\r\n                    (frameRange >= 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)\r\n                ) {\r\n                    const event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already been done.\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n", "import { Observable } from \"core/Misc/observable\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\nimport { Animation } from \"./animation\";\r\nimport { PrecisionDate } from \"core/Misc/precisionDate\";\r\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { Node } from \"../node\";\r\n\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nexport class Animatable {\r\n    /**\r\n     * If true, the animatable will be processed even if it is considered actively paused (weight of 0 and previous weight of 0).\r\n     * This can be used to force the full processing of paused animatables in the animation engine.\r\n     * Default is false.\r\n     */\r\n    public static ProcessPausedAnimatables = false;\r\n\r\n    private _localDelayOffset: Nullable<number> = null;\r\n    private _pausedDelay: Nullable<number> = null;\r\n    private _manualJumpDelay: Nullable<number> = null;\r\n    /** @hidden */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n    private _paused = false;\r\n    private _scene: Scene;\r\n    private _speedRatio = 1;\r\n    private _weight = -1.0;\r\n    private _previousWeight = -1.0;\r\n    private _syncRoot: Nullable<Animatable> = null;\r\n    private _frameToSyncFromJump: Nullable<number> = null;\r\n    private _goToFrame: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\r\n    public disposeOnEnd = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\r\n    public animationStarted = false;\r\n\r\n    /**\r\n     * Observer raised when the animation ends\r\n     */\r\n    public onAnimationEndObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Observer raised when the animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\r\n    public get syncRoot(): Nullable<Animatable> {\r\n        return this._syncRoot;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\r\n    public get masterFrame(): number {\r\n        if (this._runtimeAnimations.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return this._runtimeAnimations[0].currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (value === -1) {\r\n            // -1 is ok and means no weight\r\n            this._weight = -1;\r\n            return;\r\n        }\r\n\r\n        // Else weight must be in [0, 1] range\r\n        this._weight = Math.min(Math.max(value, 0), 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    public set speedRatio(value: number) {\r\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\r\n            const animation = this._runtimeAnimations[index];\r\n\r\n            animation._prepareForSpeedRatioChange(value);\r\n        }\r\n        this._speedRatio = value;\r\n\r\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\r\n        if (this._goToFrame !== null) {\r\n            this.goToFrame(this._goToFrame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the elapsed time since the animatable started in milliseconds\r\n     */\r\n    public get elapsedTime(): number {\r\n        return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        /** defines the target object */\r\n        public target: any,\r\n        /** [0] defines the starting frame number (default is 0) */\r\n        public fromFrame: number = 0,\r\n        /** [100] defines the ending frame number (default is 100) */\r\n        public toFrame: number = 100,\r\n        /** [false] defines if the animation must loop (default is false)  */\r\n        public loopAnimation: boolean = false,\r\n        speedRatio: number = 1.0,\r\n        /** defines a callback to call when animation ends if it is not looping */\r\n        public onAnimationEnd?: Nullable<() => void>,\r\n        animations?: Animation[],\r\n        /** defines a callback to call when animation loops */\r\n        public onAnimationLoop?: Nullable<() => void>,\r\n        /** [false] defines whether the animation should be evaluated additively */\r\n        public isAdditive: boolean = false,\r\n        /** [0] defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\r\n        public playOrder = 0\r\n    ) {\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the current Animatable\r\n     */\r\n    public syncWith(root: Nullable<Animatable>): Animatable {\r\n        this._syncRoot = root;\r\n\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    public getAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    public appendAnimations(target: any, animations: Animation[]): void {\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n\r\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = () => {\r\n                this.onAnimationLoopObservable.notifyObservers(this);\r\n                if (this.onAnimationLoop) {\r\n                    this.onAnimationLoop();\r\n                }\r\n            };\r\n\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    public getAnimationByTargetProperty(property: string): Nullable<Animation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    public getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    public reset(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    }\r\n\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    public enableBlending(blendingSpeed: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public disableBlending(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\r\n     */\r\n    public goToFrame(frame: number, useWeight = false): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        if (runtimeAnimations[0]) {\r\n            const fps = runtimeAnimations[0].animation.framePerSecond;\r\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\r\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\r\n            this._manualJumpDelay = -delay;\r\n        }\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame, useWeight ? this._weight : -1);\r\n        }\r\n\r\n        this._goToFrame = frame;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the animations for this animatable are paused\r\n     */\r\n    public get paused() {\r\n        return this._paused;\r\n    }\r\n\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    public pause(): void {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    }\r\n\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    public restart(): void {\r\n        this._paused = false;\r\n    }\r\n\r\n    private _raiseOnAnimationEnd() {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\r\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\r\n     */\r\n    public stop(animationName?: string, targetMask?: (target: any) => boolean, useGlobalSplice = false, skipOnAnimationEnd = false): void {\r\n        if (animationName || targetMask) {\r\n            const idx = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (idx > -1) {\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    const runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n\r\n                if (runtimeAnimations.length == 0) {\r\n                    if (!useGlobalSplice) {\r\n                        this._scene._activeAnimatables.splice(idx, 1);\r\n                    }\r\n                    if (!skipOnAnimationEnd) {\r\n                        this._raiseOnAnimationEnd();\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (index > -1) {\r\n                if (!useGlobalSplice) {\r\n                    this._scene._activeAnimatables.splice(index, 1);\r\n                }\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n\r\n                this._runtimeAnimations.length = 0;\r\n\r\n                if (!skipOnAnimationEnd) {\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fulfilled when the animation ends\r\n     */\r\n    public async waitAsync(): Promise<Animatable> {\r\n        return await new Promise((resolve) => {\r\n            this.onAnimationEndObservable.add(\r\n                () => {\r\n                    resolve(this);\r\n                },\r\n                undefined,\r\n                undefined,\r\n                this,\r\n                true\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _animate(delay: number): boolean {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        } else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n\r\n        if (this._manualJumpDelay !== null) {\r\n            this._localDelayOffset += this.speedRatio < 0 ? -this._manualJumpDelay : this._manualJumpDelay;\r\n            this._manualJumpDelay = null;\r\n            this._frameToSyncFromJump = null;\r\n        }\r\n\r\n        this._goToFrame = null;\r\n\r\n        if (!Animatable.ProcessPausedAnimatables && this._weight === 0 && this._previousWeight === 0) {\r\n            // We consider that an animatable with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n\r\n        this._previousWeight = this._weight;\r\n\r\n        // Animating\r\n        let running = false;\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n        let index: number;\r\n\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            const animation = runtimeAnimations[index];\r\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n\r\n        this.animationStarted = running;\r\n\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n\r\n            this._raiseOnAnimationEnd();\r\n\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n\r\n        return running;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindingsForMatrices(holder: {\r\n    totalWeight: number;\r\n    totalAdditiveWeight: number;\r\n    animations: RuntimeAnimation[];\r\n    additiveAnimations: RuntimeAnimation[];\r\n    originalValue: Matrix;\r\n}): any {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n\r\n    let normalizer = 1.0;\r\n    const finalPosition = TmpVectors.Vector3[0];\r\n    const finalScaling = TmpVectors.Vector3[1];\r\n    const finalQuaternion = TmpVectors.Quaternion[0];\r\n    let startIndex = 0;\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n\r\n    let scale = 1;\r\n    let skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    } else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            } else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n\r\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n\r\n            scale = runtimeAnimation.weight / normalizer;\r\n            const currentPosition = TmpVectors.Vector3[2];\r\n            const currentScaling = TmpVectors.Vector3[3];\r\n            const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n\r\n        finalQuaternion.normalize();\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        const currentPosition = TmpVectors.Vector3[2];\r\n        const currentScaling = TmpVectors.Vector3[3];\r\n        const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n\r\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindingsForQuaternions(\r\n    holder: {\r\n        totalWeight: number;\r\n        totalAdditiveWeight: number;\r\n        animations: RuntimeAnimation[];\r\n        additiveAnimations: RuntimeAnimation[];\r\n        originalValue: Quaternion;\r\n    },\r\n    refQuaternion: Quaternion\r\n): Quaternion {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n    let cumulativeQuaternion = refQuaternion;\r\n\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    } else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    } else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        let normalizer = 1.0;\r\n        let quaternions: Array<Quaternion>;\r\n        let weights: Array<number>;\r\n\r\n        if (holder.totalWeight < 1.0) {\r\n            const scale = 1.0 - holder.totalWeight;\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        } else {\r\n            if (holder.animations.length === 2) {\r\n                // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n\r\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n\r\n        let cumulativeAmount = 0;\r\n        for (let index = 0; index < quaternions.length; ) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n\r\n    return cumulativeQuaternion;\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindings(scene: Scene): void {\r\n    if (!scene._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (let index = 0; index < scene._registeredForLateAnimationBindings.length; index++) {\r\n        const target = scene._registeredForLateAnimationBindings.data[index];\r\n\r\n        for (const path in target._lateAnimationHolders) {\r\n            const holder = target._lateAnimationHolders[path];\r\n            const originalAnimation: RuntimeAnimation = holder.animations[0];\r\n            const originalValue = holder.originalValue;\r\n            if (originalValue === undefined || originalValue === null) {\r\n                continue;\r\n            }\r\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n\r\n            let finalValue: any = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = ProcessLateAnimationBindingsForMatrices(holder);\r\n            } else {\r\n                const quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = ProcessLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                } else {\r\n                    let startIndex = 0;\r\n                    let normalizer = 1.0;\r\n\r\n                    const originalAnimationIsLoopRelativeFromCurrent =\r\n                        originalAnimation && originalAnimation._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;\r\n\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\r\n                            finalValue = originalValue.clone ? originalValue.clone() : originalValue;\r\n                        } else if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        } else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        } else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        } else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    } else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        const scale = originalAnimation.weight / normalizer;\r\n                        if (scale !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale);\r\n                            } else {\r\n                                finalValue = originalAnimation.currentValue * scale;\r\n                            }\r\n                        } else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n\r\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\r\n                            if (finalValue.addToRef) {\r\n                                finalValue.addToRef(originalValue, finalValue);\r\n                            } else {\r\n                                finalValue += originalValue;\r\n                            }\r\n                        }\r\n\r\n                        startIndex = 1;\r\n                    }\r\n\r\n                    // Add up the override animations\r\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.animations[animIndex];\r\n                        const scale = runtimeAnimation.weight / normalizer;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n\r\n                    // Add up the additive animations\r\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n                        const scale: number = runtimeAnimation.weight;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    scene._registeredForLateAnimationBindings.reset();\r\n}\r\n\r\n/** @internal */\r\nexport function RegisterTargetForLateAnimationBinding(scene: Scene, runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n    const target = runtimeAnimation.target;\r\n    scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue,\r\n        };\r\n    }\r\n\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    } else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize all the inter dependecies between the animations and Scene and Bone\r\n * @param sceneClass defines the scene prototype to use\r\n * @param boneClass defines the bone prototype to use\r\n */\r\nexport function AddAnimationExtensions(sceneClass: typeof Scene, boneClass: typeof Bone): void {\r\n    if (boneClass) {\r\n        boneClass.prototype.copyAnimationRange = function (\r\n            source: Bone,\r\n            rangeName: string,\r\n            frameOffset: number,\r\n            rescaleAsRequired = false,\r\n            skelDimensionsRatio: Nullable<Vector3> = null\r\n        ): boolean {\r\n            // all animation may be coming from a library skeleton, so may need to create animation\r\n            if (this.animations.length === 0) {\r\n                this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n                this.animations[0].setKeys([]);\r\n            }\r\n\r\n            // get animation info / verify there is such a range from the source bone\r\n            const sourceRange = source.animations[0].getRange(rangeName);\r\n            if (!sourceRange) {\r\n                return false;\r\n            }\r\n            const from = sourceRange.from;\r\n            const to = sourceRange.to;\r\n            const sourceKeys = source.animations[0].getKeys();\r\n\r\n            // rescaling prep\r\n            const sourceBoneLength = source.length;\r\n            const sourceParent = source.getParent();\r\n            const parent = this.getParent();\r\n            const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n            const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n\r\n            const dimensionsScalingReqd =\r\n                rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n\r\n            const destKeys = this.animations[0].getKeys();\r\n\r\n            // loop vars declaration\r\n            let orig: { frame: number; value: Matrix };\r\n            let origTranslation: Vector3;\r\n            let mat: Matrix;\r\n\r\n            for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n                orig = sourceKeys[key];\r\n                if (orig.frame >= from && orig.frame <= to) {\r\n                    if (rescaleAsRequired) {\r\n                        mat = orig.value.clone();\r\n\r\n                        // scale based on parent ratio, when bone has parent\r\n                        if (parentScalingReqd) {\r\n                            origTranslation = mat.getTranslation();\r\n                            mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n\r\n                            // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                            origTranslation = mat.getTranslation();\r\n                            mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n\r\n                            // use original when root bone, and no data for skelDimensionsRatio\r\n                        } else {\r\n                            mat = orig.value;\r\n                        }\r\n                    } else {\r\n                        mat = orig.value;\r\n                    }\r\n                    destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n                }\r\n            }\r\n            this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n            return true;\r\n        };\r\n    }\r\n\r\n    if (!sceneClass) {\r\n        return;\r\n    }\r\n\r\n    sceneClass.prototype._animate = function (customDeltaTime?: number): void {\r\n        if (!this.animationsEnabled) {\r\n            return;\r\n        }\r\n\r\n        // Getting time\r\n        const now = PrecisionDate.Now;\r\n        if (!this._animationTimeLast) {\r\n            if (this._pendingData.length > 0) {\r\n                return;\r\n            }\r\n            this._animationTimeLast = now;\r\n        }\r\n\r\n        this.deltaTime = customDeltaTime !== undefined ? customDeltaTime : this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n        this._animationTimeLast = now;\r\n\r\n        const animatables = this._activeAnimatables;\r\n        if (animatables.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this._animationTime += this.deltaTime;\r\n        const animationTime = this._animationTime;\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            const animatable = animatables[index];\r\n\r\n            if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n                index--; // Array was updated\r\n            }\r\n        }\r\n\r\n        // Late animation bindings\r\n        ProcessLateAnimationBindings(this);\r\n    };\r\n\r\n    sceneClass.prototype.sortActiveAnimatables = function (): void {\r\n        this._activeAnimatables.sort((a, b) => {\r\n            return a.playOrder - b.playOrder;\r\n        });\r\n    };\r\n\r\n    sceneClass.prototype.beginWeightedAnimation = function (\r\n        target: any,\r\n        from: number,\r\n        to: number,\r\n        weight = 1.0,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n        returnedAnimatable.weight = weight;\r\n\r\n        return returnedAnimatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginAnimation = function (\r\n        target: any,\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        stopCurrent = true,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        // get speed speedRatio, to and from, based on the sign and value(s)\r\n        if (speedRatio < 0) {\r\n            const tmp = from;\r\n            from = to;\r\n            to = tmp;\r\n            speedRatio = -speedRatio;\r\n        }\r\n        // if from > to switch speed ratio\r\n        if (from > to) {\r\n            speedRatio = -speedRatio;\r\n        }\r\n        if (stopCurrent) {\r\n            this.stopAnimation(target, undefined, targetMask);\r\n        }\r\n\r\n        if (!animatable) {\r\n            animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n        }\r\n\r\n        const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n        // Local animations\r\n        if (target.animations && shouldRunTargetAnimations) {\r\n            animatable.appendAnimations(target, target.animations);\r\n        }\r\n\r\n        // Children animations\r\n        if (target.getAnimatables) {\r\n            const animatables = target.getAnimatables();\r\n            for (let index = 0; index < animatables.length; index++) {\r\n                this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n            }\r\n        }\r\n\r\n        animatable.reset();\r\n\r\n        return animatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginHierarchyAnimation = function (\r\n        target: any,\r\n        directDescendantsOnly: boolean,\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        stopCurrent = true,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable[] {\r\n        const children = target.getDescendants(directDescendantsOnly);\r\n\r\n        const result = [];\r\n        result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n        for (const child of children) {\r\n            result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.beginDirectAnimation = function (\r\n        target: any,\r\n        animations: Animation[],\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        // get speed speedRatio, to and from, based on the sign and value(s)\r\n        if (speedRatio < 0) {\r\n            const tmp = from;\r\n            from = to;\r\n            to = tmp;\r\n            speedRatio = -speedRatio;\r\n        }\r\n        // if from > to switch speed ratio\r\n        if (from > to) {\r\n            speedRatio = -speedRatio;\r\n        }\r\n        const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n\r\n        return animatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginDirectHierarchyAnimation = function (\r\n        target: Node,\r\n        directDescendantsOnly: boolean,\r\n        animations: Animation[],\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio?: number,\r\n        onAnimationEnd?: () => void,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable[] {\r\n        const children = target.getDescendants(directDescendantsOnly);\r\n\r\n        const result = [];\r\n        result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n        for (const child of children) {\r\n            result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.getAnimatableByTarget = function (target: any): Nullable<Animatable> {\r\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n            if (this._activeAnimatables[index].target === target) {\r\n                return this._activeAnimatables[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    sceneClass.prototype.getAllAnimatablesByTarget = function (target: any): Array<Animatable> {\r\n        const result = [];\r\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n            if (this._activeAnimatables[index].target === target) {\r\n                result.push(this._activeAnimatables[index]);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.stopAnimation = function (target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n        const animatables = this.getAllAnimatablesByTarget(target);\r\n\r\n        for (const animatable of animatables) {\r\n            animatable.stop(animationName, targetMask);\r\n        }\r\n    };\r\n\r\n    sceneClass.prototype.stopAllAnimations = function (): void {\r\n        if (this._activeAnimatables) {\r\n            for (let i = 0; i < this._activeAnimatables.length; i++) {\r\n                this._activeAnimatables[i].stop(undefined, undefined, true);\r\n            }\r\n            this._activeAnimatables.length = 0;\r\n        }\r\n\r\n        for (const group of this.animationGroups) {\r\n            group.stop();\r\n        }\r\n    };\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport type { Node } from \"../node\";\r\nimport { AddAnimationExtensions } from \"./animatable.core\";\r\nimport type { Animatable } from \"./animatable.core\";\r\nimport type { Animation } from \"./animation\";\r\nimport { Scene } from \"core/scene\";\r\n\r\nexport * from \"./animatable.core\";\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * Sort active animatables based on their playOrder property\r\n         */\r\n        sortActiveAnimatables(): void;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param weight defines the weight to apply to the animation (1.0 by default)\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginWeightedAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            weight: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         *\r\n         * Note that it is possible that the value(s) of speedRatio from and to will be changed if the animation is inverted\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target and its hierarchy\r\n         * @param target defines the target\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginHierarchyAnimation(\r\n            target: any,\r\n            directDescendantsOnly: boolean,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Begin a new animation on a given node\r\n         *\r\n         * Note that it is possible that the value(s) of speedRatio from and to will be changed if the animation is inverted\r\n         * @param target defines the target where the animation will take place\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginDirectAnimation(\r\n            target: any,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Begin a new animation on a given node and its hierarchy\r\n         * @param target defines the root node where the animation will take place\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of animatables created for all nodes\r\n         */\r\n        beginDirectHierarchyAnimation(\r\n            target: Node,\r\n            directDescendantsOnly: boolean,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Gets the animatable associated with a specific target\r\n         * @param target defines the target of the animatable\r\n         * @returns the required animatable if found\r\n         */\r\n        getAnimatableByTarget(target: any): Nullable<Animatable>;\r\n\r\n        /**\r\n         * Gets all animatables associated with a given target\r\n         * @param target defines the target to look animatables for\r\n         * @returns an array of Animatables\r\n         */\r\n        getAllAnimatablesByTarget(target: any): Array<Animatable>;\r\n\r\n        /**\r\n         * Stops and removes all animations that have been applied to the scene\r\n         */\r\n        stopAllAnimations(): void;\r\n    }\r\n}\r\n\r\ndeclare module \"../Bones/bone\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Bone {\r\n        /**\r\n         * Copy an animation range from another bone\r\n         * @param source defines the source bone\r\n         * @param rangeName defines the range name to copy\r\n         * @param frameOffset defines the frame offset\r\n         * @param rescaleAsRequired defines if rescaling must be applied if required\r\n         * @param skelDimensionsRatio defines the scaling ratio\r\n         * @returns true if operation was successful\r\n         */\r\n        copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired: boolean, skelDimensionsRatio: Nullable<Vector3>): boolean;\r\n    }\r\n}\r\n\r\n// Connect everything!\r\nAddAnimationExtensions(Scene, Bone);\r\n"],
  "mappings": "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",
  "names": ["target", "index"]
}
