{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Layers/thinGlowLayer.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Layers/glowLayer.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ThinEffectLayer } from \"./thinEffectLayer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { PBRMaterial } from \"../Materials/PBR/pbrMaterial\";\r\n\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { IThinEffectLayerOptions } from \"./thinEffectLayer\";\r\nimport { ThinBlurPostProcess } from \"core/PostProcesses/thinBlurPostProcess\";\r\n\r\n/**\r\n * Glow layer options. This helps customizing the behaviour\r\n * of the glow layer.\r\n */\r\nexport interface IThinGlowLayerOptions extends IThinEffectLayerOptions {\r\n    /**\r\n     * How big is the kernel of the blur texture. Default: 32\r\n     */\r\n    blurKernelSize?: number;\r\n\r\n    /**\r\n     * Forces the merge step to be done in ldr (clamp values > 1). Default: false\r\n     */\r\n    ldrMerge?: boolean;\r\n\r\n    /**\r\n     * Exclude all meshes from the glow layer by default.\r\n     * This is useful if you have dynamic meshes and you want to control them specifically and\r\n     * make sure that there are no \"leaking\" glowing meshes.\r\n     * Default: false\r\n     */\r\n    excludeByDefault?: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ThinGlowLayer extends ThinEffectLayer {\r\n    /**\r\n     * Effect Name of the layer.\r\n     */\r\n    public static readonly EffectName = \"GlowLayer\";\r\n\r\n    /**\r\n     * The default blur kernel size used for the glow.\r\n     */\r\n    public static DefaultBlurKernelSize = 32;\r\n\r\n    /**\r\n     * Gets the ldrMerge option.\r\n     */\r\n    public get ldrMerge(): boolean {\r\n        return this._options.ldrMerge;\r\n    }\r\n\r\n    /**\r\n     * Sets the kernel size of the blur.\r\n     */\r\n    public set blurKernelSize(value: number) {\r\n        if (value === this._options.blurKernelSize) {\r\n            return;\r\n        }\r\n\r\n        this._options.blurKernelSize = value;\r\n\r\n        const effectiveKernel = this._getEffectiveBlurKernelSize();\r\n        this._horizontalBlurPostprocess1.kernel = effectiveKernel;\r\n        this._verticalBlurPostprocess1.kernel = effectiveKernel;\r\n        this._horizontalBlurPostprocess2.kernel = effectiveKernel;\r\n        this._verticalBlurPostprocess2.kernel = effectiveKernel;\r\n    }\r\n\r\n    /**\r\n     * Gets the kernel size of the blur.\r\n     */\r\n    public get blurKernelSize(): number {\r\n        return this._options.blurKernelSize;\r\n    }\r\n\r\n    /**\r\n     * Sets the glow intensity.\r\n     */\r\n    public set intensity(value: number) {\r\n        this._intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow intensity.\r\n     */\r\n    public get intensity(): number {\r\n        return this._intensity;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _options: Required<IThinGlowLayerOptions>;\r\n\r\n    private _intensity: number = 1.0;\r\n    private _horizontalBlurPostprocess1: ThinBlurPostProcess;\r\n    private _verticalBlurPostprocess1: ThinBlurPostProcess;\r\n    private _horizontalBlurPostprocess2: ThinBlurPostProcess;\r\n    private _verticalBlurPostprocess2: ThinBlurPostProcess;\r\n\r\n    /** @internal */\r\n    public _includedOnlyMeshes: number[] = [];\r\n    /** @internal */\r\n    public _excludedMeshes: number[] = [];\r\n    private _meshesUsingTheirOwnMaterials: number[] = [];\r\n\r\n    /**\r\n     * Callback used to let the user override the color selection on a per mesh basis\r\n     */\r\n    public customEmissiveColorSelector: (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void;\r\n    /**\r\n     * Callback used to let the user override the texture selection on a per mesh basis\r\n     */\r\n    public customEmissiveTextureSelector: (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture;\r\n\r\n    /** @internal */\r\n    public _renderPassId = 0;\r\n\r\n    /**\r\n     * Instantiates a new glow Layer and references it to the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\r\n     * @param dontCheckIfReady Specifies if the layer should disable checking whether all the post processes are ready (default: false). To save performance, this should be set to true and you should call `isReady` manually before rendering to the layer.\r\n     */\r\n    constructor(name: string, scene?: Scene, options?: IThinGlowLayerOptions, dontCheckIfReady = false) {\r\n        super(name, scene, false, dontCheckIfReady);\r\n        this.neutralColor = new Color4(0, 0, 0, 1);\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            mainTextureFixedSize: 0,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            blurKernelSize: 32,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            ldrMerge: false,\r\n            alphaBlendingMode: Constants.ALPHA_ADD,\r\n            excludeByDefault: false,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init(this._options);\r\n\r\n        if (dontCheckIfReady) {\r\n            // When dontCheckIfReady is true, we are in the new ThinXXX layer mode, so we must call _createTextureAndPostProcesses ourselves (it is called by EffectLayer otherwise)\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the thin glow layer\r\n     * @returns the string with the class name of the glow layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"GlowLayer\";\r\n    }\r\n\r\n    protected override async _importShadersAsync() {\r\n        if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([\r\n                import(\"../ShadersWGSL/glowMapMerge.fragment\"),\r\n                import(\"../ShadersWGSL/glowMapMerge.vertex\"),\r\n                import(\"../ShadersWGSL/glowBlurPostProcess.fragment\"),\r\n            ]);\r\n        } else {\r\n            await Promise.all([import(\"../Shaders/glowMapMerge.fragment\"), import(\"../Shaders/glowMapMerge.vertex\"), import(\"../Shaders/glowBlurPostProcess.fragment\")]);\r\n        }\r\n\r\n        await super._importShadersAsync();\r\n    }\r\n\r\n    public override getEffectName(): string {\r\n        return ThinGlowLayer.EffectName;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _internalShouldRender(): boolean {\r\n        if (this._options.excludeByDefault && !this._includedOnlyMeshes.length) {\r\n            return false;\r\n        }\r\n        return super._internalShouldRender();\r\n    }\r\n\r\n    public override _createMergeEffect(): Effect {\r\n        let defines = \"#define EMISSIVE \\n\";\r\n        if (this._options.ldrMerge) {\r\n            defines += \"#define LDR \\n\";\r\n        }\r\n\r\n        // Effect\r\n        return this._engine.createEffect(\r\n            \"glowMapMerge\",\r\n            [VertexBuffer.PositionKind],\r\n            [\"offset\"],\r\n            [\"textureSampler\", \"textureSampler2\"],\r\n            defines,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            this.shaderLanguage,\r\n            this._shadersLoaded\r\n                ? undefined\r\n                : async () => {\r\n                      await this._importShadersAsync();\r\n                      this._shadersLoaded = true;\r\n                  }\r\n        );\r\n    }\r\n\r\n    public override _createTextureAndPostProcesses(): void {\r\n        const effectiveKernel = this._getEffectiveBlurKernelSize();\r\n        this._horizontalBlurPostprocess1 = new ThinBlurPostProcess(\"GlowLayerHBP1\", this._scene.getEngine(), new Vector2(1.0, 0), effectiveKernel);\r\n        this._verticalBlurPostprocess1 = new ThinBlurPostProcess(\"GlowLayerVBP1\", this._scene.getEngine(), new Vector2(0, 1.0), effectiveKernel);\r\n\r\n        this._horizontalBlurPostprocess2 = new ThinBlurPostProcess(\"GlowLayerHBP2\", this._scene.getEngine(), new Vector2(1.0, 0), effectiveKernel);\r\n        this._verticalBlurPostprocess2 = new ThinBlurPostProcess(\"GlowLayerVBP2\", this._scene.getEngine(), new Vector2(0, 1.0), effectiveKernel);\r\n\r\n        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n    }\r\n\r\n    private _getEffectiveBlurKernelSize() {\r\n        return this._options.blurKernelSize / 2;\r\n    }\r\n\r\n    public override isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const material = subMesh.getMaterial();\r\n        const mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh) {\r\n            return false;\r\n        }\r\n\r\n        const emissiveTexture = (<any>material).emissiveTexture;\r\n        return super._isSubMeshReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    public override _canRenderMesh(_mesh: AbstractMesh, _material: Material): boolean {\r\n        return true;\r\n    }\r\n\r\n    public override _internalCompose(effect: Effect): void {\r\n        // Texture\r\n        this.bindTexturesForCompose(effect);\r\n        effect.setFloat(\"offset\", this._intensity);\r\n\r\n        // Cache\r\n        const engine = this._engine;\r\n        const previousStencilBuffer = engine.getStencilBuffer();\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(false);\r\n\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(previousStencilBuffer);\r\n    }\r\n\r\n    public override _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        let textureLevel = 1.0;\r\n\r\n        if (this.customEmissiveTextureSelector) {\r\n            this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\r\n        } else {\r\n            if (material) {\r\n                this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    textureLevel = this._emissiveTextureAndColor.texture.level;\r\n                }\r\n            } else {\r\n                this._emissiveTextureAndColor.texture = null;\r\n            }\r\n        }\r\n\r\n        if (this.customEmissiveColorSelector) {\r\n            this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\r\n        } else {\r\n            if ((<any>material).emissiveColor) {\r\n                const emissiveIntensity = (<PBRMaterial>material).emissiveIntensity ?? 1;\r\n                textureLevel *= emissiveIntensity;\r\n                this._emissiveTextureAndColor.color.set(\r\n                    (<any>material).emissiveColor.r * textureLevel,\r\n                    (<any>material).emissiveColor.g * textureLevel,\r\n                    (<any>material).emissiveColor.b * textureLevel,\r\n                    material.alpha\r\n                );\r\n            } else {\r\n                this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override _shouldRenderMesh(mesh: Mesh): boolean {\r\n        return this.hasMesh(mesh);\r\n    }\r\n\r\n    public override _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define GLOW\");\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * This will not have an effect if meshes are excluded by default (see setExcludedByDefault).\r\n     * @param mesh The mesh to exclude from the glow layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh): void {\r\n        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._excludedMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\r\n     * This will not have an effect if meshes are excluded by default (see setExcludedByDefault).\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh): void {\r\n        const index = this._excludedMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._excludedMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to include in the glow layer\r\n     */\r\n    public addIncludedOnlyMesh(mesh: Mesh): void {\r\n        if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._includedOnlyMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeIncludedOnlyMesh(mesh: Mesh): void {\r\n        const index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._includedOnlyMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the excluded by default option.\r\n     * If true, all meshes will be excluded by default unless they are added to the inclusion list.\r\n     * @param value The boolean value to set the excluded by default option to\r\n     */\r\n    public setExcludedByDefault(value: boolean): void {\r\n        this._options.excludeByDefault = value;\r\n    }\r\n\r\n    public override hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        // Included Mesh\r\n        if (this._includedOnlyMeshes.length) {\r\n            return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\r\n        }\r\n\r\n        // Excluded Mesh\r\n        if (this._excludedMeshes.length) {\r\n            return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        // Specific case of material supporting glow directly\r\n        if (mesh.material?._supportGlowLayer) {\r\n            return true;\r\n        }\r\n\r\n        if (this._meshesUsingTheirOwnMaterials.length == 0) {\r\n            return false;\r\n        }\r\n\r\n        return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to be rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to use its material\r\n     */\r\n    public referenceMeshToUseItsOwnMaterial(mesh: AbstractMesh): void {\r\n        mesh.resetDrawCache(this._renderPassId);\r\n\r\n        this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\r\n\r\n        mesh.onDisposeObservable.add(() => {\r\n            this._disposeMesh(mesh as Mesh);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from being rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to not use its material\r\n     * @param renderPassId The render pass id used when rendering the mesh\r\n     */\r\n    public unReferenceMeshFromUsingItsOwnMaterial(mesh: AbstractMesh, renderPassId: number): void {\r\n        let index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        while (index >= 0) {\r\n            this._meshesUsingTheirOwnMaterials.splice(index, 1);\r\n            index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        }\r\n        mesh.resetDrawCache(renderPassId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeIncludedOnlyMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport type { IThinGlowLayerOptions } from \"./thinGlowLayer\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Color4 } from \"core/Maths/math.color\";\r\n\r\nimport \"../Layers/effectLayerSceneComponent\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { GetExponentOfTwo } from \"../Misc/tools.functions\";\r\nimport { ThinGlowLayer } from \"./thinGlowLayer\";\r\nimport type { ThinBlurPostProcess } from \"core/PostProcesses/thinBlurPostProcess\";\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * Return the first glow layer of the scene with a given name.\r\n         * @param name The name of the glow layer to look for.\r\n         * @returns The glow layer if found otherwise null.\r\n         */\r\n        getGlowLayerByName(name: string): Nullable<GlowLayer>;\r\n    }\r\n}\r\n\r\nScene.prototype.getGlowLayerByName = function (name: string): Nullable<GlowLayer> {\r\n    for (let index = 0; index < this.effectLayers?.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as GlowLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Glow layer options. This helps customizing the behaviour\r\n * of the glow layer.\r\n */\r\nexport interface IGlowLayerOptions extends IThinGlowLayerOptions {\r\n    /**\r\n     * Enable MSAA by choosing the number of samples. Default: 1\r\n     */\r\n    mainTextureSamples?: number;\r\n\r\n    /**\r\n     * Whether or not to generate a stencil buffer. Default: false\r\n     */\r\n    generateStencilBuffer?: boolean;\r\n}\r\n\r\n/**\r\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\r\n *\r\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\r\n *\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/mesh/glowLayer\r\n */\r\nexport class GlowLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the layer.\r\n     */\r\n    public static get EffectName() {\r\n        return ThinGlowLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * The default blur kernel size used for the glow.\r\n     */\r\n    public static DefaultBlurKernelSize = 32;\r\n\r\n    /**\r\n     * The default texture size ratio used for the glow.\r\n     */\r\n    public static DefaultTextureRatio = 0.5;\r\n\r\n    /**\r\n     * Sets the kernel size of the blur.\r\n     */\r\n    public set blurKernelSize(value: number) {\r\n        this._thinEffectLayer.blurKernelSize = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the kernel size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurKernelSize(): number {\r\n        return this._thinEffectLayer.blurKernelSize;\r\n    }\r\n\r\n    /**\r\n     * Sets the glow intensity.\r\n     */\r\n    public set intensity(value: number) {\r\n        this._thinEffectLayer.intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow intensity.\r\n     */\r\n    @serialize()\r\n    public get intensity(): number {\r\n        return this._thinEffectLayer.intensity;\r\n    }\r\n\r\n    @serialize(\"options\")\r\n    protected _options: IGlowLayerOptions;\r\n\r\n    protected override readonly _thinEffectLayer: ThinGlowLayer;\r\n    private _horizontalBlurPostprocess1: BlurPostProcess;\r\n    private _verticalBlurPostprocess1: BlurPostProcess;\r\n    private _horizontalBlurPostprocess2: BlurPostProcess;\r\n    private _verticalBlurPostprocess2: BlurPostProcess;\r\n    private _blurTexture1: RenderTargetTexture;\r\n    private _blurTexture2: RenderTargetTexture;\r\n    private _postProcesses1: PostProcess[];\r\n    private _postProcesses2: PostProcess[];\r\n    /**\r\n     * Callback used to let the user override the color selection on a per mesh basis\r\n     */\r\n    public get customEmissiveColorSelector(): (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void {\r\n        return this._thinEffectLayer.customEmissiveColorSelector;\r\n    }\r\n\r\n    public set customEmissiveColorSelector(value: (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void) {\r\n        this._thinEffectLayer.customEmissiveColorSelector = value;\r\n    }\r\n\r\n    /**\r\n     * Callback used to let the user override the texture selection on a per mesh basis\r\n     */\r\n    public get customEmissiveTextureSelector(): (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture {\r\n        return this._thinEffectLayer.customEmissiveTextureSelector;\r\n    }\r\n\r\n    public set customEmissiveTextureSelector(value: (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture) {\r\n        this._thinEffectLayer.customEmissiveTextureSelector = value;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new glow Layer and references it to the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\r\n     */\r\n    constructor(name: string, scene?: Scene, options?: Partial<IGlowLayerOptions>) {\r\n        super(name, scene, false, new ThinGlowLayer(name, scene, options));\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: GlowLayer.DefaultTextureRatio,\r\n            blurKernelSize: 32,\r\n            mainTextureFixedSize: undefined,\r\n            camera: null,\r\n            mainTextureSamples: 1,\r\n            renderingGroupId: -1,\r\n            ldrMerge: false,\r\n            alphaBlendingMode: Constants.ALPHA_ADD,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            generateStencilBuffer: false,\r\n            excludeByDefault: false,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init(this._options);\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return GlowLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        return this._thinEffectLayer._createMergeEffect();\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the glow layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        this._thinEffectLayer._renderPassId = this._mainTexture.renderPassId;\r\n\r\n        let blurTextureWidth = this._mainTextureDesiredSize.width;\r\n        let blurTextureHeight = this._mainTextureDesiredSize.height;\r\n        blurTextureWidth = this._engine.needPOTTextures ? GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        let textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else {\r\n            textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        }\r\n\r\n        this._blurTexture1 = new RenderTargetTexture(\r\n            \"GlowLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture1.renderParticles = false;\r\n        this._blurTexture1.ignoreCameraViewport = true;\r\n\r\n        const blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\r\n        const blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\r\n\r\n        this._blurTexture2 = new RenderTargetTexture(\r\n            \"GlowLayerBlurRTT2\",\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture2.renderParticles = false;\r\n        this._blurTexture2.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture1, this._blurTexture2];\r\n\r\n        this._thinEffectLayer.bindTexturesForCompose = (effect: Effect) => {\r\n            effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n            effect.setTexture(\"textureSampler2\", this._blurTexture2);\r\n            effect.setFloat(\"offset\", this.intensity);\r\n        };\r\n\r\n        this._thinEffectLayer._createTextureAndPostProcesses();\r\n\r\n        const thinBlurPostProcesses1 = this._thinEffectLayer._postProcesses[0] as ThinBlurPostProcess;\r\n        this._horizontalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerHBP1\", thinBlurPostProcesses1.direction, thinBlurPostProcesses1.kernel, {\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine: this._scene.getEngine(),\r\n            width: blurTextureWidth,\r\n            height: blurTextureHeight,\r\n            textureType,\r\n            effectWrapper: thinBlurPostProcesses1,\r\n        });\r\n        this._horizontalBlurPostprocess1.width = blurTextureWidth;\r\n        this._horizontalBlurPostprocess1.height = blurTextureHeight;\r\n        this._horizontalBlurPostprocess1.externalTextureSamplerBinding = true;\r\n        this._horizontalBlurPostprocess1.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._mainTexture);\r\n        });\r\n\r\n        const thinBlurPostProcesses2 = this._thinEffectLayer._postProcesses[1] as ThinBlurPostProcess;\r\n        this._verticalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerVBP1\", thinBlurPostProcesses2.direction, thinBlurPostProcesses2.kernel, {\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine: this._scene.getEngine(),\r\n            width: blurTextureWidth,\r\n            height: blurTextureHeight,\r\n            textureType,\r\n            effectWrapper: thinBlurPostProcesses2,\r\n        });\r\n\r\n        const thinBlurPostProcesses3 = this._thinEffectLayer._postProcesses[2] as ThinBlurPostProcess;\r\n        this._horizontalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerHBP2\", thinBlurPostProcesses3.direction, thinBlurPostProcesses3.kernel, {\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine: this._scene.getEngine(),\r\n            width: blurTextureWidth2,\r\n            height: blurTextureHeight2,\r\n            textureType,\r\n            effectWrapper: thinBlurPostProcesses3,\r\n        });\r\n        this._horizontalBlurPostprocess2.width = blurTextureWidth2;\r\n        this._horizontalBlurPostprocess2.height = blurTextureHeight2;\r\n        this._horizontalBlurPostprocess2.externalTextureSamplerBinding = true;\r\n        this._horizontalBlurPostprocess2.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n        });\r\n\r\n        const thinBlurPostProcesses4 = this._thinEffectLayer._postProcesses[3] as ThinBlurPostProcess;\r\n        this._verticalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerVBP2\", thinBlurPostProcesses4.direction, thinBlurPostProcesses4.kernel, {\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine: this._scene.getEngine(),\r\n            width: blurTextureWidth2,\r\n            height: blurTextureHeight2,\r\n            textureType,\r\n            effectWrapper: thinBlurPostProcesses4,\r\n        });\r\n\r\n        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n        this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\r\n        this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n\r\n        this._mainTexture.samples = this._options.mainTextureSamples!;\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            const internalTexture = this._blurTexture1.renderTarget;\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(this._postProcesses1, internalTexture, true);\r\n\r\n                const internalTexture2 = this._blurTexture2.renderTarget;\r\n                if (internalTexture2) {\r\n                    this._scene.postProcessManager.directRender(this._postProcesses2, internalTexture2, true);\r\n                }\r\n                this._engine.unBindFramebuffer(internalTexture2 ?? internalTexture, true);\r\n            }\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => {\r\n            pp.autoClear = false;\r\n        });\r\n\r\n        this._mainTextureCreatedSize.width = this._mainTextureDesiredSize.width;\r\n        this._mainTextureCreatedSize.height = this._mainTextureDesiredSize.height;\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        return this._thinEffectLayer.isReady(subMesh, useInstances);\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected override _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return this._thinEffectLayer._canRenderMesh(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     */\r\n    protected _internalRender(effect: Effect): void {\r\n        this._thinEffectLayer._internalCompose(effect);\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     * @param mesh\r\n     * @param subMesh\r\n     * @param material\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        this._thinEffectLayer._setEmissiveTextureAndColor(mesh, subMesh, material);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected override _shouldRenderMesh(mesh: Mesh): boolean {\r\n        return this._thinEffectLayer._shouldRenderMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected override _addCustomEffectDefines(defines: string[]): void {\r\n        this._thinEffectLayer._addCustomEffectDefines(defines);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * This will not have an effect if meshes are excluded by default (see setExcludedByDefault).\r\n     * @param mesh The mesh to exclude from the glow layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer.addExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\r\n     * This will not have an effect if meshes are excluded by default (see setExcludedByDefault).\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to include in the glow layer\r\n     */\r\n    public addIncludedOnlyMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer.addIncludedOnlyMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeIncludedOnlyMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer.removeIncludedOnlyMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Set the excluded by default option.\r\n     * If true, all meshes will be excluded by default unless they are added to the inclusion list.\r\n     * @param value The boolean value to set the excluded by default option to\r\n     */\r\n    public setExcludedByDefault(value: boolean): void {\r\n        this._thinEffectLayer.setExcludedByDefault(value);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the glow layer\r\n     * @param mesh The mesh to test\r\n     * @returns true if the mesh will be highlighted by the current glow layer\r\n     */\r\n    public override hasMesh(mesh: AbstractMesh): boolean {\r\n        return this._thinEffectLayer.hasMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     * @returns true if the material of the mesh should be use to render the effect\r\n     */\r\n    protected override _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return this._thinEffectLayer._useMeshMaterial(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to be rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to use its material\r\n     */\r\n    public referenceMeshToUseItsOwnMaterial(mesh: AbstractMesh): void {\r\n        this._thinEffectLayer.referenceMeshToUseItsOwnMaterial(mesh);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from being rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to not use its material\r\n     */\r\n    public unReferenceMeshFromUsingItsOwnMaterial(mesh: AbstractMesh): void {\r\n        this._thinEffectLayer.unReferenceMeshFromUsingItsOwnMaterial(mesh, this._mainTexture.renderPassId);\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @internal\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer._disposeMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GlowLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this glow layer\r\n     * @returns a serialized glow layer object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.GlowLayer\";\r\n\r\n        let index;\r\n\r\n        // Included meshes\r\n        serializationObject.includedMeshes = [];\r\n\r\n        const includedOnlyMeshes = this._thinEffectLayer._includedOnlyMeshes;\r\n        if (includedOnlyMeshes.length) {\r\n            for (index = 0; index < includedOnlyMeshes.length; index++) {\r\n                const mesh = this._scene.getMeshByUniqueId(includedOnlyMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.includedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        const excludedMeshes = this._thinEffectLayer._excludedMeshes;\r\n        if (excludedMeshes.length) {\r\n            for (index = 0; index < excludedMeshes.length; index++) {\r\n                const mesh = this._scene.getMeshByUniqueId(excludedMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.excludedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Glow Layer from parsed glow layer data\r\n     * @param parsedGlowLayer defines glow layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the glow layer information\r\n     * @returns a parsed Glow Layer\r\n     */\r\n    public static override Parse(parsedGlowLayer: any, scene: Scene, rootUrl: string): GlowLayer {\r\n        const gl = SerializationHelper.Parse(() => new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options), parsedGlowLayer, scene, rootUrl);\r\n        let index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedGlowLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedGlowLayer.includedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addIncludedOnlyMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        return gl;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GlowLayer\", GlowLayer);\r\n"],
  "mappings": "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",
  "names": []
}
