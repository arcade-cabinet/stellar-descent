{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Misc/error.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Buffers/bufferUtils.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/naming-convention */\r\n/**\r\n * Base error. Due to limitations of typedoc-check and missing documentation\r\n * in lib.es5.d.ts, cannot extend Error directly for RuntimeError.\r\n * @ignore\r\n */\r\nexport abstract class BaseError extends Error {\r\n    // See https://stackoverflow.com/questions/12915412/how-do-i-extend-a-host-object-e-g-error-in-typescript\r\n    // and https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n\r\n    // Polyfill for Object.setPrototypeOf if necessary.\r\n    protected static _setPrototypeOf: (o: any, proto: object | null) => any =\r\n        (Object as any).setPrototypeOf ||\r\n        ((o, proto) => {\r\n            o.__proto__ = proto;\r\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n            return o;\r\n        });\r\n}\r\n\r\n/* IMP! DO NOT CHANGE THE NUMBERING OF EXISTING ERROR CODES */\r\n/**\r\n * Error codes for BaseError\r\n */\r\nexport const ErrorCodes = {\r\n    // Mesh errors 0-999\r\n    /** Invalid or empty mesh vertex positions. */\r\n    MeshInvalidPositionsError: 0,\r\n\r\n    // Texture errors 1000-1999\r\n    /** Unsupported texture found. */\r\n    UnsupportedTextureError: 1000,\r\n\r\n    // GLTFLoader errors 2000-2999\r\n    /** Unexpected magic number found in GLTF file header. */\r\n    GLTFLoaderUnexpectedMagicError: 2000,\r\n\r\n    // SceneLoader errors 3000-3999\r\n    /** SceneLoader generic error code. Ideally wraps the inner exception. */\r\n    SceneLoaderError: 3000,\r\n\r\n    // File related errors 4000-4999\r\n    /** Load file error */\r\n    LoadFileError: 4000,\r\n    /** Request file error */\r\n    RequestFileError: 4001,\r\n    /** Read file error */\r\n    ReadFileError: 4002,\r\n} as const;\r\n\r\n/**\r\n * Error code type\r\n */\r\nexport type ErrorCodesType = (typeof ErrorCodes)[keyof typeof ErrorCodes];\r\n\r\n/**\r\n * Application runtime error\r\n */\r\nexport class RuntimeError extends BaseError {\r\n    /**\r\n     * The error code\r\n     */\r\n    public errorCode: ErrorCodesType;\r\n\r\n    /**\r\n     * The error that caused this outer error\r\n     */\r\n    public innerError?: Error;\r\n\r\n    /**\r\n     * Creates a new RuntimeError\r\n     * @param message defines the message of the error\r\n     * @param errorCode the error code\r\n     * @param innerError the error that caused the outer error\r\n     */\r\n    public constructor(message: string, errorCode: ErrorCodesType, innerError?: Error) {\r\n        super(message);\r\n\r\n        this.errorCode = errorCode;\r\n        this.innerError = innerError;\r\n\r\n        this.name = \"RuntimeError\";\r\n        BaseError._setPrototypeOf(this, RuntimeError.prototype);\r\n    }\r\n}\r\n\r\n/**\r\n * Used for flow control when an operation is aborted, such as with AbortController.\r\n */\r\nexport class AbortError extends BaseError {\r\n    public constructor(message = \"Operation aborted\") {\r\n        super(message);\r\n        this.name = \"AbortError\";\r\n        BaseError._setPrototypeOf(this, AbortError.prototype);\r\n    }\r\n}\r\n", "import { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { DataArray, FloatArray, IndicesArray, TypedArray, TypedArrayConstructor } from \"../types\";\r\n\r\n/**\r\n * Union of TypedArrays that can be used for vertex data.\r\n */\r\nexport type VertexDataTypedArray = Exclude<TypedArray, Float64Array | BigInt64Array | BigUint64Array>;\r\n\r\nfunction GetFloatValue(dataView: DataView, type: number, byteOffset: number, normalized: boolean): number {\r\n    switch (type) {\r\n        case Constants.BYTE: {\r\n            let value = dataView.getInt8(byteOffset);\r\n            if (normalized) {\r\n                value = Math.max(value / 127, -1);\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.UNSIGNED_BYTE: {\r\n            let value = dataView.getUint8(byteOffset);\r\n            if (normalized) {\r\n                value = value / 255;\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.SHORT: {\r\n            let value = dataView.getInt16(byteOffset, true);\r\n            if (normalized) {\r\n                value = Math.max(value / 32767, -1);\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.UNSIGNED_SHORT: {\r\n            let value = dataView.getUint16(byteOffset, true);\r\n            if (normalized) {\r\n                value = value / 65535;\r\n            }\r\n            return value;\r\n        }\r\n        case Constants.INT: {\r\n            return dataView.getInt32(byteOffset, true);\r\n        }\r\n        case Constants.UNSIGNED_INT: {\r\n            return dataView.getUint32(byteOffset, true);\r\n        }\r\n        case Constants.FLOAT: {\r\n            return dataView.getFloat32(byteOffset, true);\r\n        }\r\n        default: {\r\n            throw new Error(`Invalid component type ${type}`);\r\n        }\r\n    }\r\n}\r\n\r\nfunction SetFloatValue(dataView: DataView, type: number, byteOffset: number, normalized: boolean, value: number): void {\r\n    switch (type) {\r\n        case Constants.BYTE: {\r\n            if (normalized) {\r\n                value = Math.round(value * 127.0);\r\n            }\r\n            dataView.setInt8(byteOffset, value);\r\n            break;\r\n        }\r\n        case Constants.UNSIGNED_BYTE: {\r\n            if (normalized) {\r\n                value = Math.round(value * 255);\r\n            }\r\n            dataView.setUint8(byteOffset, value);\r\n            break;\r\n        }\r\n        case Constants.SHORT: {\r\n            if (normalized) {\r\n                value = Math.round(value * 32767);\r\n            }\r\n            dataView.setInt16(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.UNSIGNED_SHORT: {\r\n            if (normalized) {\r\n                value = Math.round(value * 65535);\r\n            }\r\n            dataView.setUint16(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.INT: {\r\n            dataView.setInt32(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.UNSIGNED_INT: {\r\n            dataView.setUint32(byteOffset, value, true);\r\n            break;\r\n        }\r\n        case Constants.FLOAT: {\r\n            dataView.setFloat32(byteOffset, value, true);\r\n            break;\r\n        }\r\n        default: {\r\n            throw new Error(`Invalid component type ${type}`);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the byte length of the given type.\r\n * @param type the type\r\n * @returns the number of bytes\r\n */\r\nexport function GetTypeByteLength(type: number): number {\r\n    switch (type) {\r\n        case Constants.BYTE:\r\n        case Constants.UNSIGNED_BYTE:\r\n            return 1;\r\n        case Constants.SHORT:\r\n        case Constants.UNSIGNED_SHORT:\r\n            return 2;\r\n        case Constants.INT:\r\n        case Constants.UNSIGNED_INT:\r\n        case Constants.FLOAT:\r\n            return 4;\r\n        default:\r\n            throw new Error(`Invalid type '${type}'`);\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the appropriate TypedArray constructor for the given component type.\r\n * @param componentType the component type\r\n * @returns the constructor object\r\n */\r\nexport function GetTypedArrayConstructor(componentType: number): TypedArrayConstructor<VertexDataTypedArray> {\r\n    switch (componentType) {\r\n        case Constants.BYTE:\r\n            return Int8Array;\r\n        case Constants.UNSIGNED_BYTE:\r\n            return Uint8Array;\r\n        case Constants.SHORT:\r\n            return Int16Array;\r\n        case Constants.UNSIGNED_SHORT:\r\n            return Uint16Array;\r\n        case Constants.INT:\r\n            return Int32Array;\r\n        case Constants.UNSIGNED_INT:\r\n            return Uint32Array;\r\n        case Constants.FLOAT:\r\n            return Float32Array;\r\n        default:\r\n            throw new Error(`Invalid component type '${componentType}'`);\r\n    }\r\n}\r\n\r\n/**\r\n * Enumerates each value of the data array and calls the given callback.\r\n * @param data the data to enumerate\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param componentCount the number of components per element\r\n * @param componentType the type of the component\r\n * @param count the number of values to enumerate\r\n * @param normalized whether the data is normalized\r\n * @param callback the callback function called for each group of component values\r\n */\r\nexport function EnumerateFloatValues(\r\n    data: DataArray,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    componentCount: number,\r\n    componentType: number,\r\n    count: number,\r\n    normalized: boolean,\r\n    callback: (values: number[], index: number) => void\r\n): void {\r\n    const oldValues = new Array<number>(componentCount);\r\n    const newValues = new Array<number>(componentCount);\r\n\r\n    if (data instanceof Array) {\r\n        let offset = byteOffset / 4;\r\n        const stride = byteStride / 4;\r\n        for (let index = 0; index < count; index += componentCount) {\r\n            for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                oldValues[componentIndex] = newValues[componentIndex] = data[offset + componentIndex];\r\n            }\r\n\r\n            callback(newValues, index);\r\n\r\n            for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                if (oldValues[componentIndex] !== newValues[componentIndex]) {\r\n                    data[offset + componentIndex] = newValues[componentIndex];\r\n                }\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n    } else {\r\n        const dataView = !ArrayBuffer.isView(data) ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n        const componentByteLength = GetTypeByteLength(componentType);\r\n        for (let index = 0; index < count; index += componentCount) {\r\n            for (let componentIndex = 0, componentByteOffset = byteOffset; componentIndex < componentCount; componentIndex++, componentByteOffset += componentByteLength) {\r\n                oldValues[componentIndex] = newValues[componentIndex] = GetFloatValue(dataView, componentType, componentByteOffset, normalized);\r\n            }\r\n\r\n            callback(newValues, index);\r\n\r\n            for (let componentIndex = 0, componentByteOffset = byteOffset; componentIndex < componentCount; componentIndex++, componentByteOffset += componentByteLength) {\r\n                if (oldValues[componentIndex] !== newValues[componentIndex]) {\r\n                    SetFloatValue(dataView, componentType, componentByteOffset, normalized, newValues[componentIndex]);\r\n                }\r\n            }\r\n\r\n            byteOffset += byteStride;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the given data array as a float array. Float data is constructed if the data array cannot be returned directly.\r\n * @param data the input data array\r\n * @param size the number of components\r\n * @param type the component type\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param normalized whether the data is normalized\r\n * @param totalVertices number of vertices in the buffer to take into account\r\n * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n * @returns a float array containing vertex data\r\n */\r\nexport function GetFloatData(\r\n    data: DataArray,\r\n    size: number,\r\n    type: number,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    normalized: boolean,\r\n    totalVertices: number,\r\n    forceCopy?: boolean\r\n): FloatArray {\r\n    const tightlyPackedByteStride = size * GetTypeByteLength(type);\r\n    const count = totalVertices * size;\r\n\r\n    if (type !== Constants.FLOAT || byteStride !== tightlyPackedByteStride) {\r\n        const copy = new Float32Array(count);\r\n        EnumerateFloatValues(data, byteOffset, byteStride, size, type, count, normalized, (values, index) => {\r\n            for (let i = 0; i < size; i++) {\r\n                copy[index + i] = values[i];\r\n            }\r\n        });\r\n        return copy;\r\n    }\r\n\r\n    if (!(data instanceof Array || data instanceof Float32Array) || byteOffset !== 0 || data.length !== count) {\r\n        if (data instanceof Array) {\r\n            const offset = byteOffset / 4;\r\n            return data.slice(offset, offset + count);\r\n        } else if (ArrayBuffer.isView(data)) {\r\n            const offset = data.byteOffset + byteOffset;\r\n            if ((offset & 3) !== 0) {\r\n                Logger.Warn(\"Float array must be aligned to 4-bytes border\");\r\n                forceCopy = true;\r\n            }\r\n\r\n            if (forceCopy) {\r\n                return new Float32Array(data.buffer.slice(offset, offset + count * Float32Array.BYTES_PER_ELEMENT));\r\n            } else {\r\n                return new Float32Array(data.buffer, offset, count);\r\n            }\r\n        } else {\r\n            return new Float32Array(data, byteOffset, count);\r\n        }\r\n    }\r\n\r\n    if (forceCopy) {\r\n        return data.slice();\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\n/**\r\n * Gets the given data array as a typed array that matches the component type. If the data cannot be used directly, a copy is made to support the new typed array.\r\n * If the data is number[], byteOffset and byteStride must be a multiple of 4, as data will be treated like a list of floats.\r\n * @param data the input data array\r\n * @param size the number of components\r\n * @param type the component type\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param totalVertices number of vertices in the buffer to take into account\r\n * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n * @returns a typed array containing vertex data\r\n */\r\nexport function GetTypedArrayData(\r\n    data: DataArray,\r\n    size: number,\r\n    type: number,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    totalVertices: number,\r\n    forceCopy?: boolean\r\n): VertexDataTypedArray {\r\n    const typeByteLength = GetTypeByteLength(type);\r\n    const constructor = GetTypedArrayConstructor(type);\r\n    const count = totalVertices * size;\r\n\r\n    // Handle number[]\r\n    if (Array.isArray(data)) {\r\n        if ((byteOffset & 3) !== 0 || (byteStride & 3) !== 0) {\r\n            throw new Error(\"byteOffset and byteStride must be a multiple of 4 for number[] data.\");\r\n        }\r\n\r\n        const offset = byteOffset / 4;\r\n        const stride = byteStride / 4;\r\n\r\n        const lastIndex = offset + (totalVertices - 1) * stride + size;\r\n        if (lastIndex > data.length) {\r\n            throw new Error(\"Last accessed index is out of bounds.\");\r\n        }\r\n\r\n        if (stride < size) {\r\n            throw new Error(\"Data stride cannot be smaller than the component size.\");\r\n        }\r\n        if (stride !== size) {\r\n            const copy = new constructor(count);\r\n            EnumerateFloatValues(data, byteOffset, byteStride, size, type, count, false, (values, index) => {\r\n                for (let i = 0; i < size; i++) {\r\n                    copy[index + i] = values[i];\r\n                }\r\n            });\r\n            return copy;\r\n        }\r\n\r\n        return new constructor(data.slice(offset, offset + count));\r\n    }\r\n\r\n    // Handle ArrayBuffer and ArrayBufferView\r\n    let buffer: ArrayBufferLike;\r\n    let adjustedByteOffset = byteOffset;\r\n\r\n    if (ArrayBuffer.isView(data)) {\r\n        buffer = data.buffer;\r\n        adjustedByteOffset += data.byteOffset;\r\n    } else {\r\n        buffer = data;\r\n    }\r\n\r\n    const lastByteOffset = adjustedByteOffset + (totalVertices - 1) * byteStride + size * typeByteLength;\r\n    if (lastByteOffset > buffer.byteLength) {\r\n        throw new Error(\"Last accessed byte is out of bounds.\");\r\n    }\r\n\r\n    const tightlyPackedByteStride = size * typeByteLength;\r\n    if (byteStride < tightlyPackedByteStride) {\r\n        throw new Error(\"Byte stride cannot be smaller than the component's byte size.\");\r\n    }\r\n    if (byteStride !== tightlyPackedByteStride) {\r\n        const copy = new constructor(count);\r\n        EnumerateFloatValues(buffer, adjustedByteOffset, byteStride, size, type, count, false, (values, index) => {\r\n            for (let i = 0; i < size; i++) {\r\n                copy[index + i] = values[i];\r\n            }\r\n        });\r\n        return copy;\r\n    }\r\n\r\n    if (typeByteLength !== 1 && (adjustedByteOffset & (typeByteLength - 1)) !== 0) {\r\n        Logger.Warn(\"Array must be aligned to border of element size. Data will be copied.\");\r\n        forceCopy = true;\r\n    }\r\n\r\n    if (forceCopy) {\r\n        return new constructor(buffer.slice(adjustedByteOffset, adjustedByteOffset + count * typeByteLength));\r\n    }\r\n\r\n    return new constructor(buffer, adjustedByteOffset, count);\r\n}\r\n\r\n/**\r\n * Copies the given data array to the given float array.\r\n * @param input the input data array\r\n * @param size the number of components\r\n * @param type the component type\r\n * @param byteOffset the byte offset of the data\r\n * @param byteStride the byte stride of the data\r\n * @param normalized whether the data is normalized\r\n * @param totalVertices number of vertices in the buffer to take into account\r\n * @param output the output float array\r\n */\r\nexport function CopyFloatData(\r\n    input: DataArray,\r\n    size: number,\r\n    type: number,\r\n    byteOffset: number,\r\n    byteStride: number,\r\n    normalized: boolean,\r\n    totalVertices: number,\r\n    output: Float32Array\r\n): void {\r\n    const tightlyPackedByteStride = size * GetTypeByteLength(type);\r\n    const count = totalVertices * size;\r\n\r\n    if (output.length !== count) {\r\n        throw new Error(\"Output length is not valid\");\r\n    }\r\n\r\n    if (type !== Constants.FLOAT || byteStride !== tightlyPackedByteStride) {\r\n        EnumerateFloatValues(input, byteOffset, byteStride, size, type, count, normalized, (values, index) => {\r\n            for (let i = 0; i < size; i++) {\r\n                output[index + i] = values[i];\r\n            }\r\n        });\r\n        return;\r\n    }\r\n\r\n    if (input instanceof Array) {\r\n        const offset = byteOffset / 4;\r\n        output.set(input, offset);\r\n    } else if (ArrayBuffer.isView(input)) {\r\n        const offset = input.byteOffset + byteOffset;\r\n        if ((offset & 3) !== 0) {\r\n            Logger.Warn(\"Float array must be aligned to 4-bytes border\");\r\n            output.set(new Float32Array(input.buffer.slice(offset, offset + count * Float32Array.BYTES_PER_ELEMENT)));\r\n            return;\r\n        }\r\n\r\n        const floatData = new Float32Array(input.buffer, offset, count);\r\n        output.set(floatData);\r\n    } else {\r\n        const floatData = new Float32Array(input, byteOffset, count);\r\n        output.set(floatData);\r\n    }\r\n}\r\n\r\n/**\r\n * Utility function to determine if an IndicesArray is an Uint32Array. If indices is an Array, determines whether at least one index is 32 bits.\r\n * @param indices The IndicesArray to check.\r\n * @param count The number of indices. Only used if indices is an Array.\r\n * @param start The offset to start at (default: 0). Only used if indices is an Array.\r\n * @param offset The offset to substract from the indices before testing (default: 0). Only used if indices is an Array.\r\n * @returns True if the indices use 32 bits\r\n */\r\nexport function AreIndices32Bits(indices: IndicesArray, count: number, start = 0, offset = 0): boolean {\r\n    if (Array.isArray(indices)) {\r\n        for (let index = 0; index < count; index++) {\r\n            if (indices[start + index] - offset > 65535) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    return indices.BYTES_PER_ELEMENT === 4;\r\n}\r\n\r\n/**\r\n * Creates a typed array suitable for GPU buffer operations, as some engines require CPU buffer sizes to be aligned to specific boundaries (e.g., 4 bytes).\r\n * The use of non-aligned arrays still works but may result in a performance penalty.\r\n * @param type The type of the array. For instance, Float32Array or Uint8Array\r\n * @param elementCount The number of elements to store in the array\r\n * @returns The aligned typed array\r\n */\r\nexport function CreateAlignedTypedArray<T extends TypedArray>(type: TypedArrayConstructor<T>, elementCount: number): T {\r\n    let byteSize = elementCount * type.BYTES_PER_ELEMENT;\r\n\r\n    if ((byteSize & 3) === 0) {\r\n        return new type(elementCount);\r\n    }\r\n\r\n    byteSize = (byteSize + 3) & ~3;\r\n\r\n    const backingBuffer = new ArrayBuffer(byteSize);\r\n\r\n    return new type(backingBuffer, 0, elementCount);\r\n}\r\n\r\n/**\r\n * Gets a BufferSource from an ArrayBufferView, ensuring that the returned ArrayBuffer is not a SharedArrayBuffer.\r\n * If the input view's buffer is a SharedArrayBuffer, a new ArrayBuffer is created and the data is copied over.\r\n * @param view The input ArrayBufferView\r\n * @returns An ArrayBuffer containing the data from the view\r\n */\r\nexport function GetBlobBufferSource(view: ArrayBufferView): BufferSource {\r\n    const buffer = view.buffer;\r\n    if (buffer instanceof ArrayBuffer) {\r\n        // Safely cast here because we know bytes is not a SharedArrayBuffer\r\n        return view as ArrayBufferView<ArrayBuffer>;\r\n    }\r\n\r\n    // We are dealing with a SharedArrayBuffer, so we need to create a new ArrayBuffer and copy the data over\r\n    const unsharedBuffer = new ArrayBuffer(view.byteLength);\r\n    const copyView = new Uint8Array(unsharedBuffer);\r\n    copyView.set(new Uint8Array(buffer, view.byteOffset, view.byteLength));\r\n    return unsharedBuffer;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
