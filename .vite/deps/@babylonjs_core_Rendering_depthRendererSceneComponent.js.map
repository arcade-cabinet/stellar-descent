{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Rendering/depthRendererSceneComponent.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { SmartArrayNoDuplicate } from \"../Misc/smartArray\";\r\nimport { DepthRenderer } from \"./depthRenderer\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _depthRenderer: { [id: string]: DepthRenderer };\r\n\r\n        /**\r\n         * Creates a depth renderer a given camera which contains a depth map which can be used for post processing.\r\n         * @param camera The camera to create the depth renderer on (default: scene's active camera)\r\n         * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\r\n         * @param force32bitsFloat Forces 32 bits float when supported (else 16 bits float is prioritized over 32 bits float if supported)\r\n         * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...)\r\n         * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)\r\n         * @param existingRenderTargetTexture An existing render target texture to use (default: undefined). If not provided, a new render target texture will be created.\r\n         * @returns the created depth renderer\r\n         */\r\n        enableDepthRenderer(\r\n            camera?: Nullable<Camera>,\r\n            storeNonLinearDepth?: boolean,\r\n            force32bitsFloat?: boolean,\r\n            samplingMode?: number,\r\n            storeCameraSpaceZ?: boolean,\r\n            existingRenderTargetTexture?: RenderTargetTexture\r\n        ): DepthRenderer;\r\n\r\n        /**\r\n         * Disables a depth renderer for a given camera\r\n         * @param camera The camera to disable the depth renderer on (default: scene's active camera)\r\n         */\r\n        disableDepthRenderer(camera?: Nullable<Camera>): void;\r\n    }\r\n}\r\n\r\nScene.prototype.enableDepthRenderer = function (\r\n    camera?: Nullable<Camera>,\r\n    storeNonLinearDepth = false,\r\n    force32bitsFloat: boolean = false,\r\n    samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    storeCameraSpaceZ: boolean = false,\r\n    existingRenderTargetTexture?: RenderTargetTexture\r\n): DepthRenderer {\r\n    camera = camera || this.activeCamera;\r\n    if (!camera) {\r\n        // eslint-disable-next-line no-throw-literal\r\n        throw \"No camera available to enable depth renderer\";\r\n    }\r\n    if (!this._depthRenderer) {\r\n        this._depthRenderer = {};\r\n    }\r\n    if (!this._depthRenderer[camera.id]) {\r\n        const supportFullfloat = !!this.getEngine().getCaps().textureFloatRender;\r\n        let textureType = 0;\r\n        if (this.getEngine().getCaps().textureHalfFloatRender && (!force32bitsFloat || !supportFullfloat)) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else if (supportFullfloat) {\r\n            textureType = Constants.TEXTURETYPE_FLOAT;\r\n        } else {\r\n            textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        }\r\n        this._depthRenderer[camera.id] = new DepthRenderer(this, textureType, camera, storeNonLinearDepth, samplingMode, storeCameraSpaceZ, undefined, existingRenderTargetTexture);\r\n    }\r\n\r\n    return this._depthRenderer[camera.id];\r\n};\r\n\r\nScene.prototype.disableDepthRenderer = function (camera?: Nullable<Camera>): void {\r\n    camera = camera || this.activeCamera;\r\n    if (!camera || !this._depthRenderer || !this._depthRenderer[camera.id]) {\r\n        return;\r\n    }\r\n\r\n    this._depthRenderer[camera.id].dispose();\r\n};\r\n\r\n/**\r\n * Defines the Depth Renderer scene component responsible to manage a depth buffer useful\r\n * in several rendering techniques.\r\n */\r\nexport class DepthRendererSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_DEPTHRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER, this, this._gatherRenderTargets);\r\n        this.scene._gatherActiveCameraRenderTargetsStage.registerStep(\r\n            SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER,\r\n            this,\r\n            this._gatherActiveCameraRenderTargets\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        for (const key in this.scene._depthRenderer) {\r\n            this.scene._depthRenderer[key].dispose();\r\n        }\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        if (this.scene._depthRenderer) {\r\n            for (const key in this.scene._depthRenderer) {\r\n                const depthRenderer = this.scene._depthRenderer[key];\r\n                if (depthRenderer.enabled && !depthRenderer.useOnlyInActiveCamera) {\r\n                    renderTargets.push(depthRenderer.getDepthMap());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _gatherActiveCameraRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        if (this.scene._depthRenderer) {\r\n            for (const key in this.scene._depthRenderer) {\r\n                const depthRenderer = this.scene._depthRenderer[key];\r\n                if (depthRenderer.enabled && depthRenderer.useOnlyInActiveCamera && this.scene.activeCamera!.id === key) {\r\n                    renderTargets.push(depthRenderer.getDepthMap());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nDepthRenderer._SceneComponentInitialization = (scene: Scene) => {\r\n    // Register the G Buffer component to the scene.\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_DEPTHRENDERER) as DepthRendererSceneComponent;\r\n    if (!component) {\r\n        component = new DepthRendererSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA,MAAM,UAAU,sBAAsB,SAClC,QACA,sBAAsB,OACtB,mBAA4B,OAC5B,eAAe,GAAA,oBAAU,OAAA,6BACzB;AAGA,WAAS,UAAU,KAAK;AACxB,MAAI,CAAC,QAAQ;AAET,UAAM;EACV;AACA,MAAI,CAAC,KAAK,gBAAgB;AACtB,SAAK,iBAAiB,CAAA;EAC1B;AACA,MAAI,CAAC,KAAK,eAAe,OAAO,EAAE,GAAG;AACjC,UAAM,mBAAmB,CAAC,CAAC,KAAK,UAAS,EAAG,QAAO,EAAG;AACtD,QAAI,cAAc;AAClB,QAAI,KAAK,UAAS,EAAG,QAAO,EAAG,2BAA2B,CAAC,oBAAoB,CAAC,mBAAmB;AAC/F,oBAAc;IAClB,WAAW,kBAAkB;AACzB,oBAAc;IAClB,OAAO;AACH,oBAAc;IAClB;AACA,SAAK,eAAe,OAAO,EAAE,IAAI,IAAI,cAAc,MAAM,aAAa,QAAQ,qBAAqB,cAAc,mBAAmB,QAAW,2BAA2B;EAC9K;AAEA,SAAO,KAAK,eAAe,OAAO,EAAE;AACxC;AAEA,MAAM,UAAU,uBAAuB,SAAU,QAAyB;AACtE,WAAS,UAAU,KAAK;AACxB,MAAI,CAAC,UAAU,CAAC,KAAK,kBAAkB,CAAC,KAAK,eAAe,OAAO,EAAE,GAAG;AACpE;EACJ;AAEA,OAAK,eAAe,OAAO,EAAE,EAAE,QAAO;AAC1C;AAMM,IAAO,8BAAP,MAAkC;;;;;EAepC,YAAY,OAAY;AAXR,SAAA,OAAO,wBAAwB;AAY3C,SAAK,QAAQ;EACjB;;;;EAKO,WAAQ;AACX,SAAK,MAAM,0BAA0B,aAAa,wBAAwB,wCAAwC,MAAM,KAAK,oBAAoB;AACjJ,SAAK,MAAM,sCAAsC,aAC7C,wBAAwB,oDACxB,MACA,KAAK,gCAAgC;EAE7C;;;;;EAMO,UAAO;EAEd;;;;EAKO,UAAO;AACV,eAAW,OAAO,KAAK,MAAM,gBAAgB;AACzC,WAAK,MAAM,eAAe,GAAG,EAAE,QAAO;IAC1C;EACJ;EAEQ,qBAAqB,eAAyD;AAClF,QAAI,KAAK,MAAM,gBAAgB;AAC3B,iBAAW,OAAO,KAAK,MAAM,gBAAgB;AACzC,cAAM,gBAAgB,KAAK,MAAM,eAAe,GAAG;AACnD,YAAI,cAAc,WAAW,CAAC,cAAc,uBAAuB;AAC/D,wBAAc,KAAK,cAAc,YAAW,CAAE;QAClD;MACJ;IACJ;EACJ;EAEQ,iCAAiC,eAAyD;AAC9F,QAAI,KAAK,MAAM,gBAAgB;AAC3B,iBAAW,OAAO,KAAK,MAAM,gBAAgB;AACzC,cAAM,gBAAgB,KAAK,MAAM,eAAe,GAAG;AACnD,YAAI,cAAc,WAAW,cAAc,yBAAyB,KAAK,MAAM,aAAc,OAAO,KAAK;AACrG,wBAAc,KAAK,cAAc,YAAW,CAAE;QAClD;MACJ;IACJ;EACJ;;AAGJ,cAAc,gCAAgC,CAAC,UAAgB;AAE3D,MAAI,YAAY,MAAM,cAAc,wBAAwB,kBAAkB;AAC9E,MAAI,CAAC,WAAW;AACZ,gBAAY,IAAI,4BAA4B,KAAK;AACjD,UAAM,cAAc,SAAS;EACjC;AACJ;",
  "names": []
}
