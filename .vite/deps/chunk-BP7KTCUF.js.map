{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Rendering/depthRenderer.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/depth.fragment\";\r\nimport \"../Shaders/depth.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { AddClipPlaneUniforms, BindClipPlane, PrepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { BindBonesParameters, BindMorphTargetParameters, PrepareDefinesAndAttributesForMorphTargets, PushAttributesForInstances } from \"../Materials/materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\nimport type { IEffectCreationOptions } from \"core/Materials/effect\";\r\nimport type { GaussianSplattingMaterial } from \"../Materials/GaussianSplatting/gaussianSplattingMaterial\";\r\n\r\n/**\r\n * This represents a depth renderer in Babylon.\r\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\r\n */\r\nexport class DepthRenderer {\r\n    private _scene: Scene;\r\n    private _depthMap: RenderTargetTexture;\r\n    private readonly _storeNonLinearDepth: boolean;\r\n    private readonly _storeCameraSpaceZ: boolean;\r\n\r\n    /** Shader language used by the material */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * Force all the depth renderer to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /** Color used to clear the depth texture. Default: (1,0,0,1) */\r\n    public clearColor: Color4;\r\n\r\n    /** Get if the depth renderer is using packed depth or not */\r\n    public readonly isPacked: boolean;\r\n\r\n    private _camera: Nullable<Camera>;\r\n\r\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\r\n    public enabled = true;\r\n\r\n    /** Force writing the transparent objects into the depth map */\r\n    public forceDepthWriteTransparentMeshes = false;\r\n\r\n    /**\r\n     * Specifies that the depth renderer will only be used within\r\n     * the camera it is created for.\r\n     * This can help forcing its rendering during the camera processing.\r\n     */\r\n    public useOnlyInActiveCamera: boolean = false;\r\n\r\n    /** If true, reverse the culling of materials before writing to the depth texture.\r\n     * So, basically, when \"true\", back facing instead of front facing faces are rasterized into the texture\r\n     */\r\n    public reverseCulling = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"DepthRendererSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._depthMap.setMaterialForRendering(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a depth renderer\r\n     * @param scene The scene the renderer belongs to\r\n     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\r\n     * @param camera The camera to be used to render the depth map (default: scene's active camera)\r\n     * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\r\n     * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)\r\n     * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)\r\n     * @param name Name of the render target (default: DepthRenderer)\r\n     * @param existingRenderTargetTexture An existing render target texture to use (default: undefined). If not provided, a new render target texture will be created.\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        type: number = Constants.TEXTURETYPE_FLOAT,\r\n        camera: Nullable<Camera> = null,\r\n        storeNonLinearDepth = false,\r\n        samplingMode = Texture.TRILINEAR_SAMPLINGMODE,\r\n        storeCameraSpaceZ = false,\r\n        name?: string,\r\n        existingRenderTargetTexture?: RenderTargetTexture\r\n    ) {\r\n        this._scene = scene;\r\n        this._storeNonLinearDepth = storeNonLinearDepth;\r\n        this._storeCameraSpaceZ = storeCameraSpaceZ;\r\n        this.isPacked = type === Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (this.isPacked) {\r\n            this.clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        } else {\r\n            this.clearColor = new Color4(storeCameraSpaceZ ? 0.0 : 1.0, 0.0, 0.0, 1.0);\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._initShaderSourceAsync();\r\n\r\n        DepthRenderer._SceneComponentInitialization(this._scene);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._camera = camera;\r\n\r\n        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\r\n            if (type === Constants.TEXTURETYPE_FLOAT && !engine._caps.textureFloatLinearFiltering) {\r\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\r\n            }\r\n            if (type === Constants.TEXTURETYPE_HALF_FLOAT && !engine._caps.textureHalfFloatLinearFiltering) {\r\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\r\n            }\r\n        }\r\n\r\n        // Render target\r\n        const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_R;\r\n        this._depthMap =\r\n            existingRenderTargetTexture ??\r\n            new RenderTargetTexture(\r\n                name ?? \"DepthRenderer\",\r\n                { width: engine.getRenderWidth(), height: engine.getRenderHeight() },\r\n                this._scene,\r\n                false,\r\n                true,\r\n                type,\r\n                false,\r\n                samplingMode,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                format\r\n            );\r\n        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.refreshRate = 1;\r\n        this._depthMap.renderParticles = false;\r\n        this._depthMap.renderList = null;\r\n        this._depthMap.noPrePassRenderer = true;\r\n\r\n        // Camera to get depth map from to support multiple concurrent cameras\r\n        this._depthMap.activeCamera = this._camera;\r\n        this._depthMap.ignoreCameraViewport = true;\r\n        this._depthMap.useCameraPostProcesses = false;\r\n\r\n        // set default depth value to 1.0 (far away)\r\n        this._depthMap.onClearObservable.add((engine) => {\r\n            engine.clear(this.clearColor, true, true, true);\r\n        });\r\n\r\n        this._depthMap.onBeforeBindObservable.add(() => {\r\n            if (engine._enableGPUDebugMarkers) {\r\n                engine.restoreDefaultFramebuffer();\r\n                engine._debugPushGroup?.(`Depth renderer`);\r\n            }\r\n        });\r\n\r\n        this._depthMap.onAfterUnbindObservable.add(() => {\r\n            if (engine._enableGPUDebugMarkers) {\r\n                engine._debugPopGroup?.();\r\n            }\r\n        });\r\n\r\n        this._depthMap.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering =\r\n                        engine.getCaps().instancedArrays &&\r\n                        ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        const renderSubMesh = (subMesh: SubMesh): void => {\r\n            const renderingMesh = subMesh.getRenderingMesh();\r\n            const effectiveMesh = subMesh.getEffectiveMesh();\r\n            const scene = this._scene;\r\n            const engine = scene.getEngine();\r\n            const material = subMesh.getMaterial();\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\r\n                return;\r\n            }\r\n\r\n            // Culling\r\n            const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\r\n            let sideOrientation = material._getEffectiveOrientation(renderingMesh);\r\n\r\n            if (detNeg) {\r\n                sideOrientation =\r\n                    sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation\r\n                        ? Constants.MATERIAL_CounterClockWiseSideOrientation\r\n                        : Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n            const reverseSideOrientation = sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n            engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);\r\n\r\n            // Managing instances\r\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            const hardwareInstancedRendering =\r\n                engine.getCaps().instancedArrays &&\r\n                ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n            const camera = this._camera || scene.activeCamera;\r\n            if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\r\n                subMesh._renderId = scene.getRenderId();\r\n\r\n                let renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n                if (renderingMaterial === undefined && effectiveMesh.getClassName() === \"GaussianSplattingMesh\") {\r\n                    const gsMaterial = effectiveMesh.material! as GaussianSplattingMaterial;\r\n                    renderingMaterial = gsMaterial.makeDepthRenderingMaterial(this._scene, this._shaderLanguage);\r\n                    this.setMaterialForRendering(effectiveMesh, renderingMaterial);\r\n                    if (!renderingMaterial.isReady()) {\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                let drawWrapper = subMesh._getDrawWrapper();\r\n                if (!drawWrapper && renderingMaterial) {\r\n                    drawWrapper = renderingMaterial._getDrawWrapper();\r\n                }\r\n                const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\r\n\r\n                if (!drawWrapper) {\r\n                    return;\r\n                }\r\n\r\n                const effect = drawWrapper.effect!;\r\n\r\n                engine.enableEffect(drawWrapper);\r\n\r\n                if (!hardwareInstancedRendering) {\r\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\r\n                }\r\n\r\n                if (!renderingMaterial) {\r\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                    if (this._storeCameraSpaceZ) {\r\n                        effect.setMatrix(\"view\", scene.getViewMatrix());\r\n                    }\r\n                } else {\r\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n                }\r\n\r\n                let minZ: number, maxZ: number;\r\n\r\n                if (cameraIsOrtho) {\r\n                    minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n                } else {\r\n                    minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\r\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\r\n                }\r\n\r\n                effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\r\n\r\n                if (!renderingMaterial) {\r\n                    // Alpha test\r\n                    if (material.needAlphaTestingForMesh(effectiveMesh)) {\r\n                        const alphaTexture = material.getAlphaTestTexture();\r\n\r\n                        if (alphaTexture) {\r\n                            effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bones\r\n                    BindBonesParameters(renderingMesh, effect);\r\n\r\n                    // Clip planes\r\n                    BindClipPlane(effect, material, scene);\r\n\r\n                    // Morph targets\r\n                    BindMorphTargetParameters(renderingMesh, effect);\r\n                    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                        renderingMesh.morphTargetManager._bind(effect);\r\n                    }\r\n\r\n                    // Baked vertex animations\r\n                    const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;\r\n                    if (bvaManager && bvaManager.isEnabled) {\r\n                        bvaManager.bind(effect, hardwareInstancedRendering);\r\n                    }\r\n\r\n                    // Points cloud rendering\r\n                    if (material.pointsCloud) {\r\n                        effect.setFloat(\"pointSize\", material.pointSize);\r\n                    }\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                    effect.setMatrix(\"world\", world)\r\n                );\r\n            }\r\n        };\r\n\r\n        this._depthMap.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            let index;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (this.forceDepthWriteTransparentMeshes) {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    renderSubMesh(transparentSubMeshes.data[index]);\r\n                }\r\n            } else {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private _shadersLoaded = false;\r\n    private async _initShaderSourceAsync(forceGLSL = false) {\r\n        const engine = this._scene.getEngine();\r\n\r\n        if (engine.isWebGPU && !forceGLSL && !DepthRenderer.ForceGLSL) {\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n\r\n            await Promise.all([import(\"../ShadersWGSL/depth.vertex\"), import(\"../ShadersWGSL/depth.fragment\")]);\r\n        } else {\r\n            await Promise.all([import(\"../Shaders/depth.vertex\"), import(\"../Shaders/depth.fragment\")]);\r\n        }\r\n\r\n        this._shadersLoaded = true;\r\n    }\r\n\r\n    /**\r\n     * Creates the depth rendering effect and checks if the effect is ready.\r\n     * @param subMesh The submesh to be used to render the depth map of\r\n     * @param useInstances If multiple world instances should be used\r\n     * @returns if the depth renderer is ready to render the depth map\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        if (!this._shadersLoaded) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n        const scene = mesh.getScene();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        if (!material || material.disableDepthWrite) {\r\n            return false;\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        let uv1 = false;\r\n        let uv2 = false;\r\n        const color = false;\r\n\r\n        // Alpha test\r\n        if (material.needAlphaTestingForMesh(mesh) && material.getAlphaTestTexture()) {\r\n            defines.push(\"#define ALPHATEST\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n                uv1 = true;\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n                uv2 = true;\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const numMorphInfluencers = mesh.morphTargetManager\r\n            ? PrepareDefinesAndAttributesForMorphTargets(\r\n                  mesh.morphTargetManager,\r\n                  defines,\r\n                  attribs,\r\n                  mesh,\r\n                  true, // usePositionMorph\r\n                  false, // useNormalMorph\r\n                  false, // useTangentMorph\r\n                  uv1, // useUVMorph\r\n                  uv2, // useUV2Morph\r\n                  color // useColorMorph\r\n              )\r\n            : 0;\r\n\r\n        // Points cloud rendering\r\n        if (material.pointsCloud) {\r\n            defines.push(\"#define POINTSIZE\");\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Baked vertex animations\r\n        const bvaManager = mesh.bakedVertexAnimationManager;\r\n        if (bvaManager && bvaManager.isEnabled) {\r\n            defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n            if (useInstances) {\r\n                attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n            }\r\n        }\r\n\r\n        // None linear depth\r\n        if (this._storeNonLinearDepth) {\r\n            defines.push(\"#define NONLINEARDEPTH\");\r\n        }\r\n\r\n        // Store camera space Z coordinate instead of NDC Z\r\n        if (this._storeCameraSpaceZ) {\r\n            defines.push(\"#define STORE_CAMERASPACE_Z\");\r\n        }\r\n\r\n        // Float Mode\r\n        if (this.isPacked) {\r\n            defines.push(\"#define PACKED\");\r\n        }\r\n\r\n        // Clip planes\r\n        PrepareStringDefinesForClipPlanes(material, scene, defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"boneTextureWidth\",\r\n                \"pointSize\",\r\n                \"viewProjection\",\r\n                \"view\",\r\n                \"diffuseMatrix\",\r\n                \"depthValues\",\r\n                \"morphTargetInfluences\",\r\n                \"morphTargetCount\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n                \"bakedVertexAnimationSettings\",\r\n                \"bakedVertexAnimationTextureSizeInverted\",\r\n                \"bakedVertexAnimationTime\",\r\n                \"bakedVertexAnimationTexture\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\", \"morphTargets\", \"boneSampler\", \"bakedVertexAnimationTexture\"];\r\n\r\n            AddClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                engine.createEffect(\r\n                    \"depth\",\r\n                    <IEffectCreationOptions>{\r\n                        attributes: attribs,\r\n                        uniformsNames: uniforms,\r\n                        uniformBuffersNames: [],\r\n                        samplers: samplers,\r\n                        defines: join,\r\n                        fallbacks: fallbacks,\r\n                        onCompiled: null,\r\n                        onError: null,\r\n                        indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },\r\n                        shaderLanguage: this._shaderLanguage,\r\n                    },\r\n                    engine\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture which the depth map will be written to.\r\n     * @returns The depth map texture\r\n     */\r\n    public getDepthMap(): RenderTargetTexture {\r\n        return this._depthMap;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the depth renderer.\r\n     */\r\n    public dispose(): void {\r\n        const keysToDelete = [];\r\n        for (const key in this._scene._depthRenderer) {\r\n            const depthRenderer = this._scene._depthRenderer[key];\r\n            if (depthRenderer === this) {\r\n                keysToDelete.push(key);\r\n            }\r\n        }\r\n\r\n        if (keysToDelete.length > 0) {\r\n            this._depthMap.dispose();\r\n\r\n            for (const key of keysToDelete) {\r\n                delete this._scene._depthRenderer[key];\r\n            }\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["engine", "scene", "camera"]
}
