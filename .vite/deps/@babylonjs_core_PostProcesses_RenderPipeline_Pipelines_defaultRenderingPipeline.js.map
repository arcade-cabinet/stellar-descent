{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinSharpenPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/sharpenPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinImageProcessingPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/imageProcessingPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinChromaticAberrationPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/chromaticAberrationPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinGrainPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/grainPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinFXAAPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/fxaaPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/RenderPipeline/postProcessRenderPipeline.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinExtractHighlightsPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/extractHighlightsPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinBloomMergePostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/bloomMergePostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinBloomEffect.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/bloomEffect.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline.ts"],
  "sourcesContent": ["import type { Nullable, AbstractEngine, EffectWrapperCreationOptions } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Post process used to apply a sharpen effect\r\n */\r\nexport class ThinSharpenPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"sharpen\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"sharpnessAmounts\", \"screenSize\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/sharpen.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/sharpen.fragment\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructs a new sharpen post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinSharpenPostProcess.FragmentUrl,\r\n            uniforms: ThinSharpenPostProcess.Uniforms,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)\r\n     */\r\n    public colorAmount: number = 1.0;\r\n    /**\r\n     * How much sharpness should be applied (default: 0.3)\r\n     */\r\n    public edgeAmount: number = 0.3;\r\n\r\n    /**\r\n     * The width of the source texture\r\n     */\r\n    public textureWidth: number = 0;\r\n\r\n    /**\r\n     * The height of the source texture\r\n     */\r\n    public textureHeight: number = 0;\r\n\r\n    public override bind(noDefaultBindings = false) {\r\n        super.bind(noDefaultBindings);\r\n\r\n        const effect = this._drawWrapper.effect!;\r\n\r\n        effect.setFloat2(\"screenSize\", this.textureWidth, this.textureHeight);\r\n        effect.setFloat2(\"sharpnessAmounts\", this.edgeAmount, this.colorAmount);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/sharpen.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport { ThinSharpenPostProcess } from \"./thinSharpenPostProcess\";\r\n\r\n/**\r\n * The SharpenPostProcess applies a sharpen kernel to every pixel\r\n * See http://en.wikipedia.org/wiki/Kernel_(image_processing)\r\n */\r\nexport class SharpenPostProcess extends PostProcess {\r\n    /**\r\n     * How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)\r\n     */\r\n    @serialize()\r\n    public get colorAmount() {\r\n        return this._effectWrapper.colorAmount;\r\n    }\r\n\r\n    public set colorAmount(value: number) {\r\n        this._effectWrapper.colorAmount = value;\r\n    }\r\n\r\n    /**\r\n     * How much sharpness should be applied (default: 0.3)\r\n     */\r\n    @serialize()\r\n    public get edgeAmount() {\r\n        return this._effectWrapper.edgeAmount;\r\n    }\r\n\r\n    public set edgeAmount(value: number) {\r\n        this._effectWrapper.edgeAmount = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"SharpenPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"SharpenPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinSharpenPostProcess;\r\n\r\n    /**\r\n     * Creates a new instance ConvolutionPostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            uniforms: ThinSharpenPostProcess.Uniforms,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinSharpenPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinSharpenPostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this.onApply = (_effect: Effect) => {\r\n            this._effectWrapper.textureWidth = this.width;\r\n            this._effectWrapper.textureHeight = this.height;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new SharpenPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.textureType,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SharpenPostProcess\", SharpenPostProcess);\r\n", "import type { Nullable, AbstractEngine, EffectWrapperCreationOptions, Observer, NonNullableFields, Scene, ColorCurves, BaseTexture, Color4 } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IImageProcessingConfigurationDefines } from \"../Materials/imageProcessingConfiguration.defines\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\n\r\n/**\r\n * Options used to create a ThinImageProcessingPostProcessOptions.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface ThinImageProcessingPostProcessOptions extends EffectWrapperCreationOptions {\r\n    /**\r\n     * An existing image processing configuration to use. If not provided, the scene one will be used.\r\n     */\r\n    imageProcessingConfiguration?: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * The scene to retrieve the image processing configuration from if not provided in the options.\r\n     * If not provided, the last created scene will be used.\r\n     */\r\n    scene?: Nullable<Scene>;\r\n}\r\n\r\n/**\r\n * Post process used to apply image processing to a scene\r\n */\r\nexport class ThinImageProcessingPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"imageProcessing\";\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/imageProcessing.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/imageProcessing.fragment\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the PBR Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        // We are almost sure it is applied by post process as\r\n        // We are in the post process :-)\r\n        value.applyByPostProcess = true;\r\n        this._attachImageProcessingConfiguration(value);\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the PBR Material.\r\n     * @param configuration\r\n     * @param doNotBuild\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>, doNotBuild = false): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            let scene = this.options.scene;\r\n\r\n            if (!scene) {\r\n                const engine = this.options.engine;\r\n                if (engine && engine.scenes) {\r\n                    const scenes = engine.scenes;\r\n                    scene = scenes[scenes.length - 1];\r\n                } else {\r\n                    scene = EngineStore.LastCreatedScene!;\r\n                }\r\n            }\r\n\r\n            if (scene) {\r\n                this._imageProcessingConfiguration = scene.imageProcessingConfiguration;\r\n            } else {\r\n                this._imageProcessingConfiguration = new ImageProcessingConfiguration();\r\n            }\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._updateParameters();\r\n            });\r\n        }\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        if (!doNotBuild) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .\r\n     */\r\n    public get colorCurves(): Nullable<ColorCurves> {\r\n        return this.imageProcessingConfiguration.colorCurves;\r\n    }\r\n    /**\r\n     * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .\r\n     */\r\n    public set colorCurves(value: Nullable<ColorCurves>) {\r\n        this.imageProcessingConfiguration.colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color curves effect is enabled.\r\n     */\r\n    public get colorCurvesEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the color curves effect is enabled.\r\n     */\r\n    public set colorCurvesEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\r\n     */\r\n    public get colorGradingTexture(): Nullable<BaseTexture> {\r\n        return this.imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\r\n     */\r\n    public set colorGradingTexture(value: Nullable<BaseTexture>) {\r\n        this.imageProcessingConfiguration.colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public get colorGradingEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public set colorGradingEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets exposure used in the effect.\r\n     */\r\n    public get exposure(): number {\r\n        return this.imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * Sets exposure used in the effect.\r\n     */\r\n    public set exposure(value: number) {\r\n        this.imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether tonemapping is enabled or not.\r\n     */\r\n    public get toneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets whether tonemapping is enabled or not\r\n     */\r\n    public set toneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the type of tone mapping effect.\r\n     */\r\n    public get toneMappingType(): number {\r\n        return this._imageProcessingConfiguration.toneMappingType;\r\n    }\r\n    /**\r\n     * Sets the type of tone mapping effect.\r\n     */\r\n    public set toneMappingType(value: number) {\r\n        this._imageProcessingConfiguration.toneMappingType = value;\r\n    }\r\n\r\n    /**\r\n     * Gets contrast used in the effect.\r\n     */\r\n    public get contrast(): number {\r\n        return this.imageProcessingConfiguration.contrast;\r\n    }\r\n    /**\r\n     * Sets contrast used in the effect.\r\n     */\r\n    public set contrast(value: number) {\r\n        this.imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette stretch size.\r\n     */\r\n    public get vignetteStretch(): number {\r\n        return this.imageProcessingConfiguration.vignetteStretch;\r\n    }\r\n    /**\r\n     * Sets Vignette stretch size.\r\n     */\r\n    public set vignetteStretch(value: number) {\r\n        this.imageProcessingConfiguration.vignetteStretch = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette center X Offset.\r\n     * @deprecated use vignetteCenterX instead\r\n     */\r\n    public get vignetteCentreX(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterX;\r\n    }\r\n    /**\r\n     * Sets Vignette center X Offset.\r\n     * @deprecated use vignetteCenterX instead\r\n     */\r\n    public set vignetteCentreX(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette center Y Offset.\r\n     * @deprecated use vignetteCenterY instead\r\n     */\r\n    public get vignetteCentreY(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterY;\r\n    }\r\n    /**\r\n     * Sets Vignette center Y Offset.\r\n     * @deprecated use vignetteCenterY instead\r\n     */\r\n    public set vignetteCentreY(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterY = value;\r\n    }\r\n\r\n    /**\r\n     * Vignette center Y Offset.\r\n     */\r\n    public get vignetteCenterY(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterY;\r\n    }\r\n    public set vignetteCenterY(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterY = value;\r\n    }\r\n\r\n    /**\r\n     * Vignette center X Offset.\r\n     */\r\n    public get vignetteCenterX(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterX;\r\n    }\r\n    public set vignetteCenterX(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette weight or intensity of the vignette effect.\r\n     */\r\n    public get vignetteWeight(): number {\r\n        return this.imageProcessingConfiguration.vignetteWeight;\r\n    }\r\n    /**\r\n     * Sets Vignette weight or intensity of the vignette effect.\r\n     */\r\n    public set vignetteWeight(value: number) {\r\n        this.imageProcessingConfiguration.vignetteWeight = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\r\n     * if vignetteEnabled is set to true.\r\n     */\r\n    public get vignetteColor(): Color4 {\r\n        return this.imageProcessingConfiguration.vignetteColor;\r\n    }\r\n    /**\r\n     * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\r\n     * if vignetteEnabled is set to true.\r\n     */\r\n    public set vignetteColor(value: Color4) {\r\n        this.imageProcessingConfiguration.vignetteColor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Camera field of view used by the Vignette effect.\r\n     */\r\n    public get vignetteCameraFov(): number {\r\n        return this.imageProcessingConfiguration.vignetteCameraFov;\r\n    }\r\n    /**\r\n     * Sets Camera field of view used by the Vignette effect.\r\n     */\r\n    public set vignetteCameraFov(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCameraFov = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the vignette blend mode allowing different kind of effect.\r\n     */\r\n    public get vignetteBlendMode(): number {\r\n        return this.imageProcessingConfiguration.vignetteBlendMode;\r\n    }\r\n    /**\r\n     * Sets the vignette blend mode allowing different kind of effect.\r\n     */\r\n    public set vignetteBlendMode(value: number) {\r\n        this.imageProcessingConfiguration.vignetteBlendMode = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the vignette effect is enabled.\r\n     */\r\n    public get vignetteEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.vignetteEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the vignette effect is enabled.\r\n     */\r\n    public set vignetteEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.vignetteEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets intensity of the dithering effect.\r\n     */\r\n    public get ditheringIntensity(): number {\r\n        return this.imageProcessingConfiguration.ditheringIntensity;\r\n    }\r\n    /**\r\n     * Sets intensity of the dithering effect.\r\n     */\r\n    public set ditheringIntensity(value: number) {\r\n        this.imageProcessingConfiguration.ditheringIntensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the dithering effect is enabled.\r\n     */\r\n    public get ditheringEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.ditheringEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the dithering effect is enabled.\r\n     */\r\n    public set ditheringEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.ditheringEnabled = value;\r\n    }\r\n\r\n    private _fromLinearSpace = true;\r\n    /**\r\n     * Gets whether the input of the processing is in Gamma or Linear Space.\r\n     */\r\n    public get fromLinearSpace(): boolean {\r\n        return this._fromLinearSpace;\r\n    }\r\n    /**\r\n     * Sets whether the input of the processing is in Gamma or Linear Space.\r\n     */\r\n    public set fromLinearSpace(value: boolean) {\r\n        if (this._fromLinearSpace === value) {\r\n            return;\r\n        }\r\n\r\n        this._fromLinearSpace = value;\r\n        this._updateParameters();\r\n    }\r\n\r\n    /**\r\n     * * Gets the width of the output texture used to store the result of the post process.\r\n     */\r\n    public get outputTextureWidth() {\r\n        return this.imageProcessingConfiguration.outputTextureWidth;\r\n    }\r\n\r\n    /**\r\n     * * Sets the width of the output texture used to store the result of the post process.\r\n     */\r\n    public set outputTextureWidth(value: number) {\r\n        this.imageProcessingConfiguration.outputTextureWidth = value;\r\n    }\r\n\r\n    /**\r\n     * * Gets the height of the output texture used to store the result of the post process.\r\n     */\r\n    public get outputTextureHeight() {\r\n        return this.imageProcessingConfiguration.outputTextureHeight;\r\n    }\r\n\r\n    /**\r\n     * * Sets the height of the output texture used to store the result of the post process.\r\n     */\r\n    public set outputTextureHeight(value: number) {\r\n        this.imageProcessingConfiguration.outputTextureHeight = value;\r\n    }\r\n\r\n    /**\r\n     * Gets/sets the aspect ratio used to override the default one.\r\n     */\r\n    public overrideAspectRatio?: number;\r\n\r\n    /**\r\n     * Defines cache preventing GC.\r\n     */\r\n    private _defines: IImageProcessingConfigurationDefines & { FROMLINEARSPACE: boolean } = {\r\n        IMAGEPROCESSING: false,\r\n        VIGNETTE: false,\r\n        VIGNETTEBLENDMODEMULTIPLY: false,\r\n        VIGNETTEBLENDMODEOPAQUE: false,\r\n        TONEMAPPING: 0,\r\n        CONTRAST: false,\r\n        COLORCURVES: false,\r\n        COLORGRADING: false,\r\n        COLORGRADING3D: false,\r\n        FROMLINEARSPACE: false,\r\n        SAMPLER3DGREENDEPTH: false,\r\n        SAMPLER3DBGRMAP: false,\r\n        DITHER: false,\r\n        IMAGEPROCESSINGPOSTPROCESS: false,\r\n        EXPOSURE: false,\r\n        SKIPFINALCOLORCLAMP: false,\r\n    };\r\n\r\n    public override readonly options: Required<NonNullableFields<ThinImageProcessingPostProcessOptions>>;\r\n\r\n    /**\r\n     * Constructs a new image processing post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: ThinImageProcessingPostProcessOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinImageProcessingPostProcess.FragmentUrl,\r\n        });\r\n\r\n        const imageProcessingConfiguration = options?.imageProcessingConfiguration;\r\n\r\n        // Setup the configuration as forced by the constructor. This would then not force the\r\n        // scene materials output in linear space and let untouched the default forward pass.\r\n        if (imageProcessingConfiguration) {\r\n            imageProcessingConfiguration.applyByPostProcess = true;\r\n            this._attachImageProcessingConfiguration(imageProcessingConfiguration, true);\r\n            // This will cause the shader to be compiled\r\n            this._updateParameters();\r\n        }\r\n        // Setup the default processing configuration to the scene.\r\n        else {\r\n            this._attachImageProcessingConfiguration(null, true);\r\n            this.imageProcessingConfiguration.applyByPostProcess = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateParameters(): void {\r\n        this._defines.FROMLINEARSPACE = this._fromLinearSpace;\r\n        this.imageProcessingConfiguration.prepareDefines(this._defines, true);\r\n        let defines = \"\";\r\n        for (const prop in this._defines) {\r\n            const value = (<any>this._defines)[prop];\r\n            const type = typeof value;\r\n\r\n            switch (type) {\r\n                case \"number\":\r\n                case \"string\":\r\n                    defines += `#define ${prop} ${value};\\n`;\r\n                    break;\r\n                default:\r\n                    if (value) {\r\n                        defines += `#define ${prop};\\n`;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        const samplers = [\"textureSampler\"];\r\n        const uniforms = [\"scale\"];\r\n\r\n        if (ImageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._defines);\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._defines);\r\n        }\r\n\r\n        this.updateEffect(defines, uniforms, samplers);\r\n    }\r\n\r\n    public override bind(noDefaultBindings = false) {\r\n        super.bind(noDefaultBindings);\r\n        this.imageProcessingConfiguration.bind(this.effect, this.overrideAspectRatio);\r\n    }\r\n\r\n    public override dispose(): void {\r\n        super.dispose();\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this.imageProcessingConfiguration.applyByPostProcess = false;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport type { Color4 } from \"../Maths/math.color\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { ColorCurves } from \"../Materials/colorCurves\";\r\nimport type { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { ThinImageProcessingPostProcess } from \"./thinImageProcessingPostProcess\";\r\n\r\n/**\r\n * ImageProcessingPostProcess\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#imageprocessing\r\n */\r\nexport class ImageProcessingPostProcess extends PostProcess {\r\n    protected get _imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._effectWrapper.imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._effectWrapper.imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._effectWrapper.imageProcessingConfiguration = value;\r\n    }\r\n\r\n    /**\r\n     * If the post process is supported.\r\n     */\r\n    public override get isSupported(): boolean {\r\n        const effect = this.getEffect();\r\n        return !effect || effect.isSupported;\r\n    }\r\n\r\n    /**\r\n     * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .\r\n     */\r\n    public get colorCurves(): Nullable<ColorCurves> {\r\n        return this.imageProcessingConfiguration.colorCurves;\r\n    }\r\n    /**\r\n     * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .\r\n     */\r\n    public set colorCurves(value: Nullable<ColorCurves>) {\r\n        this.imageProcessingConfiguration.colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color curves effect is enabled.\r\n     */\r\n    public get colorCurvesEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the color curves effect is enabled.\r\n     */\r\n    public set colorCurvesEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\r\n     */\r\n    public get colorGradingTexture(): Nullable<BaseTexture> {\r\n        return this.imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\r\n     */\r\n    public set colorGradingTexture(value: Nullable<BaseTexture>) {\r\n        this.imageProcessingConfiguration.colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public get colorGradingEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public set colorGradingEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets exposure used in the effect.\r\n     */\r\n    public get exposure(): number {\r\n        return this.imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * Sets exposure used in the effect.\r\n     */\r\n    public set exposure(value: number) {\r\n        this.imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether tonemapping is enabled or not.\r\n     */\r\n    public get toneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets whether tonemapping is enabled or not\r\n     */\r\n    public set toneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the type of tone mapping effect.\r\n     */\r\n    public get toneMappingType(): number {\r\n        return this._imageProcessingConfiguration.toneMappingType;\r\n    }\r\n    /**\r\n     * Sets the type of tone mapping effect.\r\n     */\r\n    public set toneMappingType(value: number) {\r\n        this._imageProcessingConfiguration.toneMappingType = value;\r\n    }\r\n\r\n    /**\r\n     * Gets contrast used in the effect.\r\n     */\r\n    public get contrast(): number {\r\n        return this.imageProcessingConfiguration.contrast;\r\n    }\r\n    /**\r\n     * Sets contrast used in the effect.\r\n     */\r\n    public set contrast(value: number) {\r\n        this.imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette stretch size.\r\n     */\r\n    public get vignetteStretch(): number {\r\n        return this.imageProcessingConfiguration.vignetteStretch;\r\n    }\r\n    /**\r\n     * Sets Vignette stretch size.\r\n     */\r\n    public set vignetteStretch(value: number) {\r\n        this.imageProcessingConfiguration.vignetteStretch = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette center X Offset.\r\n     * @deprecated use vignetteCenterX instead\r\n     */\r\n    public get vignetteCentreX(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterX;\r\n    }\r\n    /**\r\n     * Sets Vignette center X Offset.\r\n     * @deprecated use vignetteCenterX instead\r\n     */\r\n    public set vignetteCentreX(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette center Y Offset.\r\n     * @deprecated use vignetteCenterY instead\r\n     */\r\n    public get vignetteCentreY(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterY;\r\n    }\r\n    /**\r\n     * Sets Vignette center Y Offset.\r\n     * @deprecated use vignetteCenterY instead\r\n     */\r\n    public set vignetteCentreY(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterY = value;\r\n    }\r\n\r\n    /**\r\n     * Vignette center Y Offset.\r\n     */\r\n    public get vignetteCenterY(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterY;\r\n    }\r\n    public set vignetteCenterY(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterY = value;\r\n    }\r\n\r\n    /**\r\n     * Vignette center X Offset.\r\n     */\r\n    public get vignetteCenterX(): number {\r\n        return this.imageProcessingConfiguration.vignetteCenterX;\r\n    }\r\n    public set vignetteCenterX(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCenterX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Vignette weight or intensity of the vignette effect.\r\n     */\r\n    public get vignetteWeight(): number {\r\n        return this.imageProcessingConfiguration.vignetteWeight;\r\n    }\r\n    /**\r\n     * Sets Vignette weight or intensity of the vignette effect.\r\n     */\r\n    public set vignetteWeight(value: number) {\r\n        this.imageProcessingConfiguration.vignetteWeight = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\r\n     * if vignetteEnabled is set to true.\r\n     */\r\n    public get vignetteColor(): Color4 {\r\n        return this.imageProcessingConfiguration.vignetteColor;\r\n    }\r\n    /**\r\n     * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\r\n     * if vignetteEnabled is set to true.\r\n     */\r\n    public set vignetteColor(value: Color4) {\r\n        this.imageProcessingConfiguration.vignetteColor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets Camera field of view used by the Vignette effect.\r\n     */\r\n    public get vignetteCameraFov(): number {\r\n        return this.imageProcessingConfiguration.vignetteCameraFov;\r\n    }\r\n    /**\r\n     * Sets Camera field of view used by the Vignette effect.\r\n     */\r\n    public set vignetteCameraFov(value: number) {\r\n        this.imageProcessingConfiguration.vignetteCameraFov = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the vignette blend mode allowing different kind of effect.\r\n     */\r\n    public get vignetteBlendMode(): number {\r\n        return this.imageProcessingConfiguration.vignetteBlendMode;\r\n    }\r\n    /**\r\n     * Sets the vignette blend mode allowing different kind of effect.\r\n     */\r\n    public set vignetteBlendMode(value: number) {\r\n        this.imageProcessingConfiguration.vignetteBlendMode = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the vignette effect is enabled.\r\n     */\r\n    public get vignetteEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.vignetteEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the vignette effect is enabled.\r\n     */\r\n    public set vignetteEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.vignetteEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets intensity of the dithering effect.\r\n     */\r\n    public get ditheringIntensity(): number {\r\n        return this.imageProcessingConfiguration.ditheringIntensity;\r\n    }\r\n    /**\r\n     * Sets intensity of the dithering effect.\r\n     */\r\n    public set ditheringIntensity(value: number) {\r\n        this.imageProcessingConfiguration.ditheringIntensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the dithering effect is enabled.\r\n     */\r\n    public get ditheringEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.ditheringEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the dithering effect is enabled.\r\n     */\r\n    public set ditheringEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.ditheringEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the input of the processing is in Gamma or Linear Space.\r\n     */\r\n    @serialize()\r\n    public get fromLinearSpace(): boolean {\r\n        return this._effectWrapper.fromLinearSpace;\r\n    }\r\n    /**\r\n     * Sets whether the input of the processing is in Gamma or Linear Space.\r\n     */\r\n    public set fromLinearSpace(value: boolean) {\r\n        this._effectWrapper.fromLinearSpace = value;\r\n    }\r\n\r\n    protected override _effectWrapper: ThinImageProcessingPostProcess;\r\n\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        imageProcessingConfiguration?: ImageProcessingConfiguration\r\n    ) {\r\n        const localOptions = {\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            imageProcessingConfiguration,\r\n            scene: camera?.getScene(),\r\n            ...(options as PostProcessOptions),\r\n            blockCompilation: true,\r\n        };\r\n\r\n        super(name, ThinImageProcessingPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinImageProcessingPostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this.onApply = () => {\r\n            this._effectWrapper.overrideAspectRatio = this.aspectRatio;\r\n        };\r\n    }\r\n\r\n    /**\r\n     *  \"ImageProcessingPostProcess\"\r\n     * @returns \"ImageProcessingPostProcess\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ImageProcessingPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateParameters(): void {\r\n        this._effectWrapper._updateParameters();\r\n    }\r\n    public override dispose(camera?: Camera): void {\r\n        super.dispose(camera);\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this.imageProcessingConfiguration.applyByPostProcess = false;\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable, AbstractEngine, EffectWrapperCreationOptions } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen\r\n */\r\nexport class ThinChromaticAberrationPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"chromaticAberration\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"chromatic_aberration\", \"screen_width\", \"screen_height\", \"direction\", \"radialIntensity\", \"centerPosition\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/chromaticAberration.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/chromaticAberration.fragment\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructs a new chromatic aberration post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinChromaticAberrationPostProcess.FragmentUrl,\r\n            uniforms: ThinChromaticAberrationPostProcess.Uniforms,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The amount of separation of rgb channels (default: 30)\r\n     */\r\n    public aberrationAmount = 30;\r\n\r\n    /**\r\n     * The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)\r\n     */\r\n    public radialIntensity = 0;\r\n\r\n    /**\r\n     * The normalized direction in which the rgb channels should be separated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))\r\n     */\r\n    public direction = new Vector2(0.707, 0.707);\r\n\r\n    /**\r\n     * The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corner] (default: Vector2(0.5 ,0.5))\r\n     */\r\n    public centerPosition = new Vector2(0.5, 0.5);\r\n\r\n    /** The width of the source texture to which the effect is applied */\r\n    public screenWidth: number;\r\n\r\n    /** The height of the source texture to which the effect is applied */\r\n    public screenHeight: number;\r\n\r\n    public override bind(noDefaultBindings = false) {\r\n        super.bind(noDefaultBindings);\r\n\r\n        const effect = this._drawWrapper.effect!;\r\n\r\n        effect.setFloat(\"chromatic_aberration\", this.aberrationAmount);\r\n        effect.setFloat(\"screen_width\", this.screenWidth);\r\n        effect.setFloat(\"screen_height\", this.screenHeight);\r\n        effect.setFloat(\"radialIntensity\", this.radialIntensity);\r\n        effect.setFloat2(\"direction\", this.direction.x, this.direction.y);\r\n        effect.setFloat2(\"centerPosition\", this.centerPosition.x, this.centerPosition.y);\r\n    }\r\n}\r\n", "import type { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport { ThinChromaticAberrationPostProcess } from \"./thinChromaticAberrationPostProcess\";\r\n\r\n/**\r\n * The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen\r\n */\r\nexport class ChromaticAberrationPostProcess extends PostProcess {\r\n    /**\r\n     * The amount of separation of rgb channels (default: 30)\r\n     */\r\n    @serialize()\r\n    public get aberrationAmount() {\r\n        return this._effectWrapper.aberrationAmount;\r\n    }\r\n\r\n    public set aberrationAmount(value: number) {\r\n        this._effectWrapper.aberrationAmount = value;\r\n    }\r\n\r\n    /**\r\n     * The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)\r\n     */\r\n    @serialize()\r\n    public get radialIntensity() {\r\n        return this._effectWrapper.radialIntensity;\r\n    }\r\n\r\n    public set radialIntensity(value: number) {\r\n        this._effectWrapper.radialIntensity = value;\r\n    }\r\n\r\n    /**\r\n     * The normalized direction in which the rgb channels should be separated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))\r\n     */\r\n    @serialize()\r\n    public get direction() {\r\n        return this._effectWrapper.direction;\r\n    }\r\n\r\n    public set direction(value: Vector2) {\r\n        this._effectWrapper.direction = value;\r\n    }\r\n\r\n    /**\r\n     * The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corner] (default: Vector2(0.5 ,0.5))\r\n     */\r\n    @serialize()\r\n    public get centerPosition() {\r\n        return this._effectWrapper.centerPosition;\r\n    }\r\n\r\n    public set centerPosition(value: Vector2) {\r\n        this._effectWrapper.centerPosition = value;\r\n    }\r\n\r\n    /** The width of the screen to apply the effect on */\r\n    @serialize()\r\n    public get screenWidth() {\r\n        return this._effectWrapper.screenWidth;\r\n    }\r\n\r\n    public set screenWidth(value: number) {\r\n        this._effectWrapper.screenWidth = value;\r\n    }\r\n\r\n    /** The height of the screen to apply the effect on */\r\n    @serialize()\r\n    public get screenHeight() {\r\n        return this._effectWrapper.screenHeight;\r\n    }\r\n\r\n    public set screenHeight(value: number) {\r\n        this._effectWrapper.screenHeight = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"ChromaticAberrationPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ChromaticAberrationPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinChromaticAberrationPostProcess;\r\n\r\n    /**\r\n     * Creates a new instance ChromaticAberrationPostProcess\r\n     * @param name The name of the effect.\r\n     * @param screenWidth The width of the screen to apply the effect on.\r\n     * @param screenHeight The height of the screen to apply the effect on.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        screenWidth: number,\r\n        screenHeight: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            uniforms: ThinChromaticAberrationPostProcess.Uniforms,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinChromaticAberrationPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinChromaticAberrationPostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this.screenWidth = screenWidth;\r\n        this.screenHeight = screenHeight;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<ChromaticAberrationPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new ChromaticAberrationPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.screenWidth,\r\n                    parsedPostProcess.screenHeight,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ChromaticAberrationPostProcess\", ChromaticAberrationPostProcess);\r\n", "import type { Nullable, AbstractEngine, EffectWrapperCreationOptions } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Post process used to render a grain effect\r\n */\r\nexport class ThinGrainPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"grain\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"intensity\", \"animatedSeed\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/grain.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/grain.fragment\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructs a new grain post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinGrainPostProcess.FragmentUrl,\r\n            uniforms: ThinGrainPostProcess.Uniforms,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The intensity of the grain added (default: 30)\r\n     */\r\n    public intensity = 30;\r\n\r\n    /**\r\n     * If the grain should be randomized on every frame\r\n     */\r\n    public animated = false;\r\n\r\n    public override bind(noDefaultBindings = false) {\r\n        super.bind(noDefaultBindings);\r\n        this._drawWrapper.effect!.setFloat(\"intensity\", this.intensity);\r\n        this._drawWrapper.effect!.setFloat(\"animatedSeed\", this.animated ? Math.random() + 1 : 1);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport { ThinGrainPostProcess } from \"./thinGrainPostProcess\";\r\n\r\n/**\r\n * The GrainPostProcess adds noise to the image at mid luminance levels\r\n */\r\nexport class GrainPostProcess extends PostProcess {\r\n    /**\r\n     * The intensity of the grain added (default: 30)\r\n     */\r\n    @serialize()\r\n    public get intensity() {\r\n        return this._effectWrapper.intensity;\r\n    }\r\n\r\n    public set intensity(value: number) {\r\n        this._effectWrapper.intensity = value;\r\n    }\r\n\r\n    /**\r\n     * If the grain should be randomized on every frame\r\n     */\r\n    @serialize()\r\n    public get animated() {\r\n        return this._effectWrapper.animated;\r\n    }\r\n\r\n    public set animated(value: boolean) {\r\n        this._effectWrapper.animated = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"GrainPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GrainPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinGrainPostProcess;\r\n\r\n    /**\r\n     * Creates a new instance of @see GrainPostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            uniforms: ThinGrainPostProcess.Uniforms,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinGrainPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinGrainPostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new GrainPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GrainPostProcess\", GrainPostProcess);\r\n", "import type { Nullable, AbstractEngine, EffectWrapperCreationOptions } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Postprocess used to apply FXAA (antialiasing) to the scene\r\n */\r\nexport class ThinFXAAPostProcess extends EffectWrapper {\r\n    private static _GetDefines(engine: AbstractEngine): Nullable<string> {\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const driverInfo = engine.extractDriverInfo();\r\n        if (driverInfo.toLowerCase().indexOf(\"mali\") > -1) {\r\n            return \"#define MALI 1\\n\";\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * The vertex shader url\r\n     */\r\n    public static readonly VertexUrl = \"fxaa\";\r\n\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"fxaa\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"texelSize\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/fxaa.fragment\"), import(\"../ShadersWGSL/fxaa.vertex\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/fxaa.fragment\"), import(\"../Shaders/fxaa.vertex\")]));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructs a new FXAA post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        const localOptions = {\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            vertexShader: ThinFXAAPostProcess.VertexUrl,\r\n            fragmentShader: ThinFXAAPostProcess.FragmentUrl,\r\n            uniforms: ThinFXAAPostProcess.Uniforms,\r\n        };\r\n\r\n        super({\r\n            ...localOptions,\r\n            defines: ThinFXAAPostProcess._GetDefines(localOptions.engine),\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The texel size of the texture to apply FXAA on\r\n     */\r\n    public texelSize = new Vector2(0, 0);\r\n\r\n    public override bind(noDefaultBindings = false) {\r\n        super.bind(noDefaultBindings);\r\n        this._drawWrapper.effect!.setFloat2(\"texelSize\", this.texelSize.x, this.texelSize.y);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { ThinFXAAPostProcess } from \"./thinFXAAPostProcess\";\r\n\r\nimport type { Scene } from \"../scene\";\r\n/**\r\n * Fxaa post process\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#fxaa\r\n */\r\nexport class FxaaPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"FxaaPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FxaaPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinFXAAPostProcess;\r\n\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    ) {\r\n        const localOptions = {\r\n            uniforms: ThinFXAAPostProcess.Uniforms,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode: samplingMode || Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinFXAAPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinFXAAPostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this.onApplyObservable.add((_effect: Effect) => {\r\n            this._effectWrapper.texelSize = this.texelSize;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new FxaaPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.FxaaPostProcess\", FxaaPostProcess);\r\n", "import type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport { UniqueIdGenerator } from \"core/Misc/uniqueIdGenerator\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { PostProcessRenderEffect } from \"./postProcessRenderEffect\";\r\nimport type { IInspectable } from \"../../Misc/iInspectable\";\r\n\r\nimport type { PrePassRenderer } from \"../../Rendering/prePassRenderer\";\r\n\r\n/**\r\n * PostProcessRenderPipeline\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n */\r\nexport class PostProcessRenderPipeline {\r\n    protected _renderEffects: { [key: string]: PostProcessRenderEffect };\r\n    protected _renderEffectsForIsolatedPass: PostProcessRenderEffect[];\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _cameras: Camera[];\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _name: string;\r\n\r\n    /**\r\n     * Gets pipeline name\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Gets the unique id of the post process rendering pipeline\r\n     */\r\n    public readonly uniqueId = UniqueIdGenerator.UniqueId;\r\n\r\n    /** Gets the list of attached cameras */\r\n    public get cameras() {\r\n        return this._cameras;\r\n    }\r\n\r\n    /**\r\n     * Gets the active engine\r\n     */\r\n    public get engine(): AbstractEngine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Initializes a PostProcessRenderPipeline\r\n     * @param _engine engine to add the pipeline to\r\n     * @param name name of the pipeline\r\n     */\r\n    constructor(\r\n        private _engine: AbstractEngine,\r\n        name: string\r\n    ) {\r\n        this._name = name;\r\n\r\n        this._renderEffects = {};\r\n        this._renderEffectsForIsolatedPass = new Array<PostProcessRenderEffect>();\r\n\r\n        this._cameras = [];\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns \"PostProcessRenderPipeline\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"PostProcessRenderPipeline\";\r\n    }\r\n\r\n    /**\r\n     * If all the render effects in the pipeline are supported\r\n     */\r\n    public get isSupported(): boolean {\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                if (!this._renderEffects[renderEffectName].isSupported) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Adds an effect to the pipeline\r\n     * @param renderEffect the effect to add\r\n     */\r\n    public addEffect(renderEffect: PostProcessRenderEffect): void {\r\n        (<any>this._renderEffects)[renderEffect._name] = renderEffect;\r\n    }\r\n\r\n    // private\r\n\r\n    /** @internal */\r\n    public _rebuild() {}\r\n\r\n    /** @internal */\r\n    public _enableEffect(renderEffectName: string, cameras: Camera): void;\r\n    /** @internal */\r\n    public _enableEffect(renderEffectName: string, cameras: Camera[]): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _enableEffect(renderEffectName: string, cameras: any): void {\r\n        const renderEffects: PostProcessRenderEffect = (<any>this._renderEffects)[renderEffectName];\r\n\r\n        if (!renderEffects) {\r\n            return;\r\n        }\r\n\r\n        renderEffects._enable(Tools.MakeArray(cameras || this._cameras));\r\n    }\r\n\r\n    /** @internal */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;\r\n    /** @internal */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void {\r\n        const renderEffects: PostProcessRenderEffect = (<any>this._renderEffects)[renderEffectName];\r\n\r\n        if (!renderEffects) {\r\n            return;\r\n        }\r\n\r\n        renderEffects._disable(Tools.MakeArray(cameras || this._cameras));\r\n    }\r\n\r\n    /** @internal */\r\n    public _attachCameras(cameras: Camera, unique: boolean): void;\r\n    /** @internal */\r\n    public _attachCameras(cameras: Camera[], unique: boolean): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: any, unique: boolean): void {\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        const indicesToDelete = [];\r\n        let i: number;\r\n        for (i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            if (!camera) {\r\n                continue;\r\n            }\r\n\r\n            if (this._cameras.indexOf(camera) === -1) {\r\n                this._cameras.push(camera);\r\n            } else if (unique) {\r\n                indicesToDelete.push(i);\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < indicesToDelete.length; i++) {\r\n            cams.splice(indicesToDelete[i], 1);\r\n        }\r\n\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._attachCameras(cams);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _detachCameras(cameras: Camera): void;\r\n    /** @internal */\r\n    public _detachCameras(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: any): void {\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._detachCameras(cams);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            this._cameras.splice(this._cameras.indexOf(cams[i]), 1);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _update(): void {\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._update();\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            if (!this._cameras[i]) {\r\n                continue;\r\n            }\r\n            const cameraName = this._cameras[i].name;\r\n            if ((<any>this._renderEffectsForIsolatedPass)[cameraName]) {\r\n                (<any>this._renderEffectsForIsolatedPass)[cameraName]._update();\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _reset(): void {\r\n        this._renderEffects = {};\r\n        this._renderEffectsForIsolatedPass = new Array<PostProcessRenderEffect>();\r\n    }\r\n\r\n    protected _enableMSAAOnFirstPostProcess(sampleCount: number): boolean {\r\n        if (!this._engine._features.supportMSAA) {\r\n            return false;\r\n        }\r\n\r\n        // Set samples of the very first post process to 4 to enable native anti-aliasing in browsers that support webGL 2.0 (See: https://github.com/BabylonJS/Babylon.js/issues/3754)\r\n        const effectKeys = Object.keys(this._renderEffects);\r\n        if (effectKeys.length > 0) {\r\n            const postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();\r\n            if (postProcesses) {\r\n                postProcesses[0].samples = sampleCount;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Ensures that all post processes in the pipeline are the correct size according to the\r\n     * the viewport's required size\r\n     */\r\n    protected _adaptPostProcessesToViewPort(): void {\r\n        const effectKeys = Object.keys(this._renderEffects);\r\n        for (const effectKey of effectKeys) {\r\n            const postProcesses = this._renderEffects[effectKey].getPostProcesses();\r\n            if (postProcesses) {\r\n                for (const postProcess of postProcesses) {\r\n                    postProcess.adaptScaleToCurrentViewport = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the pipeline\r\n     */\r\n    public dispose() {\r\n        // Must be implemented by children\r\n    }\r\n}\r\n", "import type { Nullable, AbstractEngine, EffectWrapperCreationOptions } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { ToGammaSpace } from \"../Maths/math.constants\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Post process used to extract highlights.\r\n */\r\nexport class ThinExtractHighlightsPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"extractHighlights\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"threshold\", \"exposure\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/extractHighlights.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/extractHighlights.fragment\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructs a new extract highlights post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinExtractHighlightsPostProcess.FragmentUrl,\r\n            uniforms: ThinExtractHighlightsPostProcess.Uniforms,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The luminance threshold, pixels below this value will be set to black.\r\n     */\r\n    public threshold = 0.9;\r\n\r\n    /** @internal */\r\n    public _exposure = 1;\r\n\r\n    public override bind(noDefaultBindings = false) {\r\n        super.bind(noDefaultBindings);\r\n\r\n        const effect = this._drawWrapper.effect!;\r\n\r\n        effect.setFloat(\"threshold\", Math.pow(this.threshold, ToGammaSpace));\r\n        effect.setFloat(\"exposure\", this._exposure);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { ThinExtractHighlightsPostProcess } from \"./thinExtractHighlightsPostProcess\";\r\n\r\n/**\r\n * The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.\r\n */\r\nexport class ExtractHighlightsPostProcess extends PostProcess {\r\n    /**\r\n     * The luminance threshold, pixels below this value will be set to black.\r\n     */\r\n    @serialize()\r\n    public get threshold() {\r\n        return this._effectWrapper.threshold;\r\n    }\r\n\r\n    public set threshold(value: number) {\r\n        this._effectWrapper.threshold = value;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _exposure() {\r\n        return this._effectWrapper._exposure;\r\n    }\r\n\r\n    /** @internal */\r\n    public set _exposure(value: number) {\r\n        this._effectWrapper._exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Post process which has the input texture to be used when performing highlight extraction\r\n     * @internal\r\n     */\r\n    public _inputPostProcess: Nullable<PostProcess> = null;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"ExtractHighlightsPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ExtractHighlightsPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinExtractHighlightsPostProcess;\r\n\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            uniforms: ThinExtractHighlightsPostProcess.Uniforms,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinExtractHighlightsPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinExtractHighlightsPostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            this.externalTextureSamplerBinding = !!this._inputPostProcess;\r\n            if (this._inputPostProcess) {\r\n                effect.setTextureFromPostProcess(\"textureSampler\", this._inputPostProcess);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ExtractHighlightsPostProcess\", ExtractHighlightsPostProcess);\r\n", "import type { Nullable, AbstractEngine, EffectWrapperCreationOptions } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ThinBloomMergePostProcess extends EffectWrapper {\r\n    public static readonly FragmentUrl = \"bloomMerge\";\r\n\r\n    public static readonly Uniforms = [\"bloomWeight\"];\r\n\r\n    public static readonly Samplers = [\"bloomBlur\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/bloomMerge.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/bloomMerge.fragment\"));\r\n        }\r\n    }\r\n\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinBloomMergePostProcess.FragmentUrl,\r\n            uniforms: ThinBloomMergePostProcess.Uniforms,\r\n            samplers: ThinBloomMergePostProcess.Samplers,\r\n        });\r\n    }\r\n\r\n    /** Weight of the bloom to be added to the original input. */\r\n    public weight = 1;\r\n\r\n    public override bind(noDefaultBindings = false) {\r\n        super.bind(noDefaultBindings);\r\n        this._drawWrapper.effect!.setFloat(\"bloomWeight\", this.weight);\r\n    }\r\n}\r\n", "import type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { ThinBloomMergePostProcess } from \"./thinBloomMergePostProcess\";\r\n\r\n/**\r\n * The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.\r\n */\r\nexport class BloomMergePostProcess extends PostProcess {\r\n    /** Weight of the bloom to be added to the original input. */\r\n    @serialize()\r\n    public get weight() {\r\n        return this._effectWrapper.weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        this._effectWrapper.weight = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"BloomMergePostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"BloomMergePostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinBloomMergePostProcess;\r\n\r\n    /**\r\n     * Creates a new instance of @see BloomMergePostProcess\r\n     * @param name The name of the effect.\r\n     * @param originalFromInput Post process which's input will be used for the merge.\r\n     * @param blurred Blurred highlights post process which's output will be used.\r\n     * @param weight Weight of the bloom to be added to the original input.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        originalFromInput: PostProcess,\r\n        blurred: PostProcess,\r\n        weight: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const blockCompilationFinal = typeof options === \"number\" ? blockCompilation : !!options.blockCompilation;\r\n        const localOptions = {\r\n            uniforms: ThinBloomMergePostProcess.Uniforms,\r\n            samplers: ThinBloomMergePostProcess.Samplers,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            ...(options as PostProcessOptions),\r\n            blockCompilation: true,\r\n        };\r\n\r\n        super(name, ThinBloomMergePostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinBloomMergePostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this.weight = weight;\r\n        this.externalTextureSamplerBinding = true;\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureSampler\", originalFromInput);\r\n            effect.setTextureFromPostProcessOutput(\"bloomBlur\", blurred);\r\n        });\r\n\r\n        if (!blockCompilationFinal) {\r\n            this.updateEffect();\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BloomMergePostProcess\", BloomMergePostProcess);\r\n", "import type { Nullable, AbstractEngine } from \"core/index\";\r\nimport { ThinBloomMergePostProcess } from \"./thinBloomMergePostProcess\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { ThinBlurPostProcess } from \"./thinBlurPostProcess\";\r\nimport { ThinExtractHighlightsPostProcess } from \"./thinExtractHighlightsPostProcess\";\r\n\r\n/**\r\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\r\n */\r\nexport class ThinBloomEffect {\r\n    /** @internal */\r\n    public _downscale: ThinExtractHighlightsPostProcess;\r\n    /** @internal */\r\n    public _blurX: ThinBlurPostProcess;\r\n    /** @internal */\r\n    public _blurY: ThinBlurPostProcess;\r\n    /** @internal */\r\n    public _merge: ThinBloomMergePostProcess;\r\n\r\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\r\n    public get threshold(): number {\r\n        return this._downscale.threshold;\r\n    }\r\n    public set threshold(value: number) {\r\n        this._downscale.threshold = value;\r\n    }\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public get weight(): number {\r\n        return this._merge.weight;\r\n    }\r\n    public set weight(value: number) {\r\n        this._merge.weight = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\r\n    public get kernel(): number {\r\n        return this._blurX.kernel / this.scale;\r\n    }\r\n    public set kernel(value: number) {\r\n        this._blurX.kernel = value * this.scale;\r\n        this._blurY.kernel = value * this.scale;\r\n    }\r\n\r\n    /**\r\n     * The ratio of the blur texture to the input texture that should be used to compute the bloom.\r\n     */\r\n    public readonly scale: number;\r\n\r\n    /**\r\n     * Creates a new instance of @see ThinBloomEffect\r\n     * @param name The name of the bloom render effect\r\n     * @param engine The engine which the render effect will be applied. (default: current engine)\r\n     * @param scale The ratio of the blur texture to the input texture that should be used to compute the bloom.\r\n     * @param blockCompilation If shaders should not be compiled when the effect is created (default: false)\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine>, scale: number, blockCompilation = false) {\r\n        this.scale = scale;\r\n        this._downscale = new ThinExtractHighlightsPostProcess(name + \"_downscale\", engine, { blockCompilation });\r\n        this._blurX = new ThinBlurPostProcess(name + \"_blurX\", engine, new Vector2(1, 0), 10, { blockCompilation });\r\n        this._blurY = new ThinBlurPostProcess(name + \"_blurY\", engine, new Vector2(0, 1), 10, { blockCompilation });\r\n        this._merge = new ThinBloomMergePostProcess(name + \"_merge\", engine, { blockCompilation });\r\n    }\r\n\r\n    /**\r\n     * Checks if the effect is ready to be used\r\n     * @returns if the effect is ready\r\n     */\r\n    public isReady() {\r\n        return this._downscale.isReady() && this._blurX.isReady() && this._blurY.isReady() && this._merge.isReady();\r\n    }\r\n}\r\n", "import { PostProcessRenderEffect } from \"../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport type { PostProcess } from \"./postProcess\";\r\nimport { ExtractHighlightsPostProcess } from \"./extractHighlightsPostProcess\";\r\nimport { BlurPostProcess } from \"./blurPostProcess\";\r\nimport { BloomMergePostProcess } from \"./bloomMergePostProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { ThinBloomEffect } from \"./thinBloomEffect\";\r\n\r\n/**\r\n * The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras\r\n */\r\nexport class BloomEffect extends PostProcessRenderEffect {\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _effects: Array<PostProcess> = [];\r\n\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _downscale: ExtractHighlightsPostProcess;\r\n    private _blurX: BlurPostProcess;\r\n    private _blurY: BlurPostProcess;\r\n    private _merge: BloomMergePostProcess;\r\n\r\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\r\n    public get threshold(): number {\r\n        return this._thinBloomEffect.threshold;\r\n    }\r\n    public set threshold(value: number) {\r\n        this._thinBloomEffect.threshold = value;\r\n    }\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public get weight(): number {\r\n        return this._thinBloomEffect.weight;\r\n    }\r\n    public set weight(value: number) {\r\n        this._thinBloomEffect.weight = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\r\n    public get kernel(): number {\r\n        return this._thinBloomEffect.kernel;\r\n    }\r\n    public set kernel(value: number) {\r\n        this._thinBloomEffect.kernel = value;\r\n    }\r\n\r\n    public get bloomScale() {\r\n        return this._thinBloomEffect.scale;\r\n    }\r\n\r\n    private _thinBloomEffect: ThinBloomEffect;\r\n\r\n    /**\r\n     * Creates a new instance of @see BloomEffect\r\n     * @param sceneOrEngine The scene or engine the effect belongs to.\r\n     * @param bloomScale The ratio of the blur texture to the input texture that should be used to compute the bloom.\r\n     * @param bloomWeight The strength of bloom.\r\n     * @param bloomKernel The size of the kernel to be used when applying the blur.\r\n     * @param pipelineTextureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(sceneOrEngine: Scene | AbstractEngine, bloomScale: number, bloomWeight: number, bloomKernel: number, pipelineTextureType = 0, blockCompilation = false) {\r\n        const engine = (sceneOrEngine as Scene)._renderForCamera ? (sceneOrEngine as Scene).getEngine() : (sceneOrEngine as AbstractEngine);\r\n        super(\r\n            engine,\r\n            \"bloom\",\r\n            () => {\r\n                return this._effects;\r\n            },\r\n            true\r\n        );\r\n\r\n        this._thinBloomEffect = new ThinBloomEffect(\"bloom\", engine, bloomScale, blockCompilation);\r\n\r\n        this._downscale = new ExtractHighlightsPostProcess(\"highlights\", {\r\n            size: 1.0,\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            textureType: pipelineTextureType,\r\n            blockCompilation,\r\n            effectWrapper: this._thinBloomEffect._downscale,\r\n        });\r\n\r\n        this._blurX = new BlurPostProcess(\"horizontal blur\", this._thinBloomEffect._blurX.direction, this._thinBloomEffect._blurX.kernel, {\r\n            size: bloomScale,\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            textureType: pipelineTextureType,\r\n            blockCompilation,\r\n            effectWrapper: this._thinBloomEffect._blurX,\r\n        });\r\n        this._blurX.alwaysForcePOT = true;\r\n        this._blurX.autoClear = false;\r\n\r\n        this._blurY = new BlurPostProcess(\"vertical blur\", this._thinBloomEffect._blurY.direction, this._thinBloomEffect._blurY.kernel, {\r\n            size: bloomScale,\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            textureType: pipelineTextureType,\r\n            blockCompilation,\r\n            effectWrapper: this._thinBloomEffect._blurY,\r\n        });\r\n        this._blurY.alwaysForcePOT = true;\r\n        this._blurY.autoClear = false;\r\n\r\n        this.kernel = bloomKernel;\r\n\r\n        this._effects = [this._downscale, this._blurX, this._blurY];\r\n\r\n        this._merge = new BloomMergePostProcess(\"bloomMerge\", this._downscale, this._blurY, bloomWeight, {\r\n            size: bloomScale,\r\n            samplingMode: Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            textureType: pipelineTextureType,\r\n            blockCompilation,\r\n            effectWrapper: this._thinBloomEffect._merge,\r\n        });\r\n        this._merge.autoClear = false;\r\n        this._effects.push(this._merge);\r\n    }\r\n\r\n    /**\r\n     * Disposes each of the internal effects for a given camera.\r\n     * @param camera The camera to dispose the effect on.\r\n     */\r\n    public disposeEffects(camera?: Camera) {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].dispose(camera);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal Internal\r\n     */\r\n    public _updateEffects() {\r\n        for (let effectIndex = 0; effectIndex < this._effects.length; effectIndex++) {\r\n            this._effects[effectIndex].updateEffect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal\r\n     * @returns if all the contained post processes are ready.\r\n     * @internal\r\n     */\r\n    public _isReady() {\r\n        return this._thinBloomEffect.isReady();\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../../types\";\r\nimport { serialize } from \"../../../Misc/decorators\";\r\nimport { SerializationHelper } from \"../../../Misc/decorators.serialization\";\r\nimport type { Observer } from \"../../../Misc/observable\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { IAnimatable } from \"../../../Animations/animatable.interface\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Camera } from \"../../../Cameras/camera\";\r\nimport type { ImageProcessingConfiguration } from \"../../../Materials/imageProcessingConfiguration\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport type { AbstractEngine } from \"../../../Engines/abstractEngine\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport type { IDisposable, Scene } from \"../../../scene\";\r\nimport { GlowLayer } from \"../../../Layers/glowLayer\";\r\n\r\nimport type { PostProcess } from \"../../../PostProcesses/postProcess\";\r\nimport { SharpenPostProcess } from \"../../../PostProcesses/sharpenPostProcess\";\r\nimport { ImageProcessingPostProcess } from \"../../../PostProcesses/imageProcessingPostProcess\";\r\nimport { ChromaticAberrationPostProcess } from \"../../../PostProcesses/chromaticAberrationPostProcess\";\r\nimport { GrainPostProcess } from \"../../../PostProcesses/grainPostProcess\";\r\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess\";\r\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\r\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { DepthOfFieldEffect, DepthOfFieldEffectBlurLevel } from \"../../../PostProcesses/depthOfFieldEffect\";\r\nimport { BloomEffect } from \"../../../PostProcesses/bloomEffect\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent\";\r\n\r\nimport type { Animation } from \"../../../Animations/animation\";\r\n\r\n/**\r\n * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/defaultRenderingPipeline\r\n */\r\nexport class DefaultRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {\r\n    private _scene: Scene;\r\n    private _camerasToBeAttached: Array<Camera> = [];\r\n    /**\r\n     * ID of the sharpen post process,\r\n     */\r\n    private readonly SharpenPostProcessId = \"SharpenPostProcessEffect\";\r\n    /**\r\n     * @ignore\r\n     * ID of the image processing post process;\r\n     */\r\n    readonly ImageProcessingPostProcessId = \"ImageProcessingPostProcessEffect\";\r\n    /**\r\n     * @ignore\r\n     * ID of the Fast Approximate Anti-Aliasing post process;\r\n     */\r\n    readonly FxaaPostProcessId = \"FxaaPostProcessEffect\";\r\n    /**\r\n     * ID of the chromatic aberration post process,\r\n     */\r\n    private readonly ChromaticAberrationPostProcessId = \"ChromaticAberrationPostProcessEffect\";\r\n    /**\r\n     * ID of the grain post process\r\n     */\r\n    private readonly GrainPostProcessId = \"GrainPostProcessEffect\";\r\n\r\n    // Post-processes\r\n    /**\r\n     * Sharpen post process which will apply a sharpen convolution to enhance edges\r\n     */\r\n    public sharpen: SharpenPostProcess;\r\n    private _sharpenEffect: PostProcessRenderEffect;\r\n    private bloom: BloomEffect;\r\n    /**\r\n     * Depth of field effect, applies a blur based on how far away objects are from the focus distance.\r\n     */\r\n    public depthOfField: DepthOfFieldEffect;\r\n    /**\r\n     * The Fast Approximate Anti-Aliasing post process which attempts to remove aliasing from an image.\r\n     */\r\n    public fxaa: FxaaPostProcess;\r\n    /**\r\n     * Image post processing pass used to perform operations such as tone mapping or color grading.\r\n     */\r\n    public imageProcessing: ImageProcessingPostProcess;\r\n    /**\r\n     * Chromatic aberration post process which will shift rgb colors in the image\r\n     */\r\n    public chromaticAberration: ChromaticAberrationPostProcess;\r\n    private _chromaticAberrationEffect: PostProcessRenderEffect;\r\n    /**\r\n     * Grain post process which add noise to the image\r\n     */\r\n    public grain: GrainPostProcess;\r\n    private _grainEffect: PostProcessRenderEffect;\r\n    /**\r\n     * Glow post process which adds a glow to emissive areas of the image\r\n     */\r\n    private _glowLayer: Nullable<GlowLayer> = null;\r\n\r\n    /**\r\n     * Animations which can be used to tweak settings over a period of time\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    private _imageProcessingConfigurationObserver: Nullable<Observer<ImageProcessingConfiguration>> = null;\r\n    // Values\r\n    private _sharpenEnabled: boolean = false;\r\n    private _bloomEnabled: boolean = false;\r\n    private _depthOfFieldEnabled: boolean = false;\r\n    private _depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;\r\n    private _fxaaEnabled: boolean = false;\r\n    private _imageProcessingEnabled: boolean = true;\r\n    private _defaultPipelineTextureType: number;\r\n    private _bloomScale: number = 0.5;\r\n    private _chromaticAberrationEnabled: boolean = false;\r\n    private _grainEnabled: boolean = false;\r\n\r\n    private _buildAllowed = true;\r\n\r\n    /**\r\n     * Enable or disable automatic building of the pipeline when effects are enabled and disabled.\r\n     * If false, you will have to manually call prepare() to update the pipeline.\r\n     */\r\n    public get automaticBuild() {\r\n        return this._buildAllowed;\r\n    }\r\n    public set automaticBuild(value: boolean) {\r\n        this._buildAllowed = value;\r\n    }\r\n\r\n    /**\r\n     * This is triggered each time the pipeline has been built.\r\n     */\r\n    public onBuildObservable = new Observable<DefaultRenderingPipeline>();\r\n\r\n    /**\r\n     * Gets active scene\r\n     */\r\n    public get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the sharpen process from the pipeline\r\n     */\r\n    public set sharpenEnabled(enabled: boolean) {\r\n        if (this._sharpenEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._sharpenEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get sharpenEnabled(): boolean {\r\n        return this._sharpenEnabled;\r\n    }\r\n\r\n    private _resizeObserver: Nullable<Observer<AbstractEngine>> = null;\r\n    private _hardwareScaleLevel = 1.0;\r\n    private _bloomKernel: number = 64;\r\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\r\n    @serialize()\r\n    public get bloomKernel(): number {\r\n        return this._bloomKernel;\r\n    }\r\n    public set bloomKernel(value: number) {\r\n        this._bloomKernel = value;\r\n        this.bloom.kernel = value / this._hardwareScaleLevel;\r\n    }\r\n\r\n    /**\r\n     * Specifies the weight of the bloom in the final rendering\r\n     */\r\n    @serialize()\r\n    private _bloomWeight: number = 0.15;\r\n    /**\r\n     * Specifies the luma threshold for the area that will be blurred by the bloom\r\n     */\r\n    @serialize()\r\n    private _bloomThreshold: number = 0.9;\r\n\r\n    @serialize()\r\n    private _hdr: boolean;\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public set bloomWeight(value: number) {\r\n        if (this._bloomWeight === value) {\r\n            return;\r\n        }\r\n        this.bloom.weight = value;\r\n\r\n        this._bloomWeight = value;\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomWeight(): number {\r\n        return this._bloomWeight;\r\n    }\r\n\r\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\r\n    public set bloomThreshold(value: number) {\r\n        if (this._bloomThreshold === value) {\r\n            return;\r\n        }\r\n        this.bloom.threshold = value;\r\n        this._bloomThreshold = value;\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomThreshold(): number {\r\n        return this._bloomThreshold;\r\n    }\r\n\r\n    /**\r\n     * The scale of the bloom, lower value will provide better performance.\r\n     */\r\n    public set bloomScale(value: number) {\r\n        if (this._bloomScale === value) {\r\n            return;\r\n        }\r\n        this._bloomScale = value;\r\n\r\n        // recreate bloom and dispose old as this setting is not dynamic\r\n        this._rebuildBloom();\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomScale(): number {\r\n        return this._bloomScale;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the bloom from the pipeline\r\n     */\r\n    public set bloomEnabled(enabled: boolean) {\r\n        if (this._bloomEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._bloomEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomEnabled(): boolean {\r\n        return this._bloomEnabled;\r\n    }\r\n\r\n    private _rebuildBloom() {\r\n        // recreate bloom and dispose old as this setting is not dynamic\r\n        const oldBloom = this.bloom;\r\n        this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, false);\r\n        this.bloom.threshold = oldBloom.threshold;\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            oldBloom.disposeEffects(this._cameras[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the depth of field is enabled.\r\n     */\r\n    @serialize()\r\n    public get depthOfFieldEnabled(): boolean {\r\n        return this._depthOfFieldEnabled;\r\n    }\r\n\r\n    public set depthOfFieldEnabled(enabled: boolean) {\r\n        if (this._depthOfFieldEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._depthOfFieldEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Blur level of the depth of field effect. (Higher blur will effect performance)\r\n     */\r\n    @serialize()\r\n    public get depthOfFieldBlurLevel(): DepthOfFieldEffectBlurLevel {\r\n        return this._depthOfFieldBlurLevel;\r\n    }\r\n\r\n    public set depthOfFieldBlurLevel(value: DepthOfFieldEffectBlurLevel) {\r\n        if (this._depthOfFieldBlurLevel === value) {\r\n            return;\r\n        }\r\n        this._depthOfFieldBlurLevel = value;\r\n\r\n        // recreate dof and dispose old as this setting is not dynamic\r\n        const oldDof = this.depthOfField;\r\n\r\n        this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);\r\n        this.depthOfField.focalLength = oldDof.focalLength;\r\n        this.depthOfField.focusDistance = oldDof.focusDistance;\r\n        this.depthOfField.fStop = oldDof.fStop;\r\n        this.depthOfField.lensSize = oldDof.lensSize;\r\n\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            oldDof.disposeEffects(this._cameras[i]);\r\n        }\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * If the anti aliasing is enabled.\r\n     */\r\n    public set fxaaEnabled(enabled: boolean) {\r\n        if (this._fxaaEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._fxaaEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get fxaaEnabled(): boolean {\r\n        return this._fxaaEnabled;\r\n    }\r\n\r\n    private _samples = 1;\r\n    /**\r\n     * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\r\n     */\r\n    public set samples(sampleCount: number) {\r\n        if (this._samples === sampleCount) {\r\n            return;\r\n        }\r\n        this._samples = sampleCount;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * If image processing is enabled.\r\n     */\r\n    public set imageProcessingEnabled(enabled: boolean) {\r\n        if (this._imageProcessingEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._scene.imageProcessingConfiguration.isEnabled = enabled;\r\n    }\r\n\r\n    @serialize()\r\n    public get imageProcessingEnabled(): boolean {\r\n        return this._imageProcessingEnabled;\r\n    }\r\n\r\n    /**\r\n     * If glow layer is enabled. (Adds a glow effect to emmissive materials)\r\n     */\r\n    public set glowLayerEnabled(enabled: boolean) {\r\n        if (enabled && !this._glowLayer) {\r\n            this._glowLayer = new GlowLayer(\"\", this._scene);\r\n        } else if (!enabled && this._glowLayer) {\r\n            this._glowLayer.dispose();\r\n            this._glowLayer = null;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get glowLayerEnabled(): boolean {\r\n        return this._glowLayer != null;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow layer (or null if not defined)\r\n     */\r\n    public get glowLayer() {\r\n        return this._glowLayer;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the chromaticAberration process from the pipeline\r\n     */\r\n    public set chromaticAberrationEnabled(enabled: boolean) {\r\n        if (this._chromaticAberrationEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._chromaticAberrationEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get chromaticAberrationEnabled(): boolean {\r\n        return this._chromaticAberrationEnabled;\r\n    }\r\n    /**\r\n     * Enable or disable the grain process from the pipeline\r\n     */\r\n    public set grainEnabled(enabled: boolean) {\r\n        if (this._grainEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._grainEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get grainEnabled(): boolean {\r\n        return this._grainEnabled;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a DefaultRenderingPipeline.\r\n     * @param name The rendering pipeline name (default: \"\")\r\n     * @param hdr If high dynamic range textures should be used (default: true)\r\n     * @param scene The scene linked to this pipeline (default: the last created scene)\r\n     * @param cameras The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)\r\n     * @param automaticBuild If false, you will have to manually call prepare() to update the pipeline (default: true)\r\n     */\r\n    constructor(name = \"\", hdr = true, scene: Scene = EngineStore.LastCreatedScene!, cameras?: Camera[], automaticBuild = true) {\r\n        super(scene.getEngine(), name);\r\n        this._cameras = cameras || scene.cameras;\r\n        this._cameras = this._cameras.slice();\r\n        this._camerasToBeAttached = this._cameras.slice();\r\n\r\n        this._buildAllowed = automaticBuild;\r\n\r\n        // Initialize\r\n        this._scene = scene;\r\n        const caps = this._scene.getEngine().getCaps();\r\n        this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);\r\n\r\n        // Misc\r\n        if (this._hdr) {\r\n            if (caps.textureHalfFloatRender) {\r\n                this._defaultPipelineTextureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n            } else if (caps.textureFloatRender) {\r\n                this._defaultPipelineTextureType = Constants.TEXTURETYPE_FLOAT;\r\n            }\r\n        } else {\r\n            this._defaultPipelineTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        }\r\n\r\n        // Attach\r\n        scene.postProcessRenderPipelineManager.addPipeline(this);\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Create post processes before hand so they can be modified before enabled.\r\n        // Block compilation flag is set to true to avoid compilation prior to use, these will be updated on first use in build pipeline.\r\n        this.sharpen = new SharpenPostProcess(\"sharpen\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\r\n        this._sharpenEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.SharpenPostProcessId,\r\n            () => {\r\n                return this.sharpen;\r\n            },\r\n            true\r\n        );\r\n\r\n        this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, true);\r\n\r\n        // To keep the bloom sizes consistent across different display densities, factor in the hardware scaling level.\r\n        this._hardwareScaleLevel = engine.getHardwareScalingLevel();\r\n        this._resizeObserver = engine.onResizeObservable.add(() => {\r\n            this._hardwareScaleLevel = engine.getHardwareScalingLevel();\r\n            this.bloomKernel = this._bloomKernel;\r\n        });\r\n\r\n        this.bloom = new BloomEffect(this._scene, this._bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, true);\r\n\r\n        this.chromaticAberration = new ChromaticAberrationPostProcess(\r\n            \"ChromaticAberration\",\r\n            engine.getRenderWidth(),\r\n            engine.getRenderHeight(),\r\n            1.0,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            this._defaultPipelineTextureType,\r\n            true\r\n        );\r\n        this._chromaticAberrationEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.ChromaticAberrationPostProcessId,\r\n            () => {\r\n                return this.chromaticAberration;\r\n            },\r\n            true\r\n        );\r\n\r\n        this.grain = new GrainPostProcess(\"Grain\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\r\n        this._grainEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.GrainPostProcessId,\r\n            () => {\r\n                return this.grain;\r\n            },\r\n            true\r\n        );\r\n\r\n        let avoidReentrancyAtConstructionTime = true;\r\n\r\n        this._imageProcessingConfigurationObserver = this._scene.imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n            this.bloom._downscale._exposure = this._scene.imageProcessingConfiguration.exposure;\r\n\r\n            if (this.imageProcessingEnabled !== this._scene.imageProcessingConfiguration.isEnabled) {\r\n                this._imageProcessingEnabled = this._scene.imageProcessingConfiguration.isEnabled;\r\n                // Avoid re-entrant problems by deferring the call to _buildPipeline because the call to _buildPipeline\r\n                // at the end of the constructor could end up triggering imageProcessingConfiguration.onUpdateParameters!\r\n                // Note that the pipeline could have been disposed before the deferred call was executed, but in that case\r\n                // _buildAllowed will have been set to false, preventing _buildPipeline from being executed.\r\n                if (avoidReentrancyAtConstructionTime) {\r\n                    Tools.SetImmediate(() => {\r\n                        this._buildPipeline();\r\n                    });\r\n                } else {\r\n                    this._buildPipeline();\r\n                }\r\n            }\r\n        });\r\n\r\n        this._buildPipeline();\r\n\r\n        avoidReentrancyAtConstructionTime = false;\r\n    }\r\n\r\n    /**\r\n     * Get the class name\r\n     * @returns \"DefaultRenderingPipeline\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"DefaultRenderingPipeline\";\r\n    }\r\n\r\n    /**\r\n     * Force the compilation of the entire pipeline.\r\n     */\r\n    public prepare(): void {\r\n        const previousState = this._buildAllowed;\r\n        this._buildAllowed = true;\r\n        this._buildPipeline();\r\n        this._buildAllowed = previousState;\r\n    }\r\n\r\n    private _hasCleared = false;\r\n    private _prevPostProcess: Nullable<PostProcess> = null;\r\n    private _prevPrevPostProcess: Nullable<PostProcess> = null;\r\n\r\n    private _setAutoClearAndTextureSharing(postProcess: PostProcess, skipTextureSharing = false) {\r\n        if (this._hasCleared) {\r\n            postProcess.autoClear = false;\r\n        } else {\r\n            postProcess.autoClear = true;\r\n            this._scene.autoClear = false;\r\n            this._hasCleared = true;\r\n        }\r\n\r\n        if (!skipTextureSharing) {\r\n            if (this._prevPrevPostProcess) {\r\n                postProcess.shareOutputWith(this._prevPrevPostProcess);\r\n            } else {\r\n                postProcess.useOwnOutput();\r\n            }\r\n\r\n            if (this._prevPostProcess) {\r\n                this._prevPrevPostProcess = this._prevPostProcess;\r\n            }\r\n            this._prevPostProcess = postProcess;\r\n        }\r\n    }\r\n\r\n    private _depthOfFieldSceneObserver: Nullable<Observer<Scene>> = null;\r\n    private _activeCameraChangedObserver: Nullable<Observer<Scene>> = null;\r\n    private _activeCamerasChangedObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    private _buildPipeline() {\r\n        if (!this._buildAllowed) {\r\n            return;\r\n        }\r\n        this._scene.autoClear = true;\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._disposePostProcesses();\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n            // get back cameras to be used to reattach pipeline\r\n            this._cameras = this._camerasToBeAttached.slice();\r\n        }\r\n        this._reset();\r\n        this._prevPostProcess = null;\r\n        this._prevPrevPostProcess = null;\r\n        this._hasCleared = false;\r\n\r\n        if (this.depthOfFieldEnabled) {\r\n            // Multi camera suport\r\n            if (this._cameras.length > 1) {\r\n                for (const camera of this._cameras) {\r\n                    const depthRenderer = this._scene.enableDepthRenderer(camera);\r\n                    depthRenderer.useOnlyInActiveCamera = true;\r\n                }\r\n\r\n                this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add((scene) => {\r\n                    if (this._cameras.indexOf(scene.activeCamera!) > -1) {\r\n                        this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();\r\n                    }\r\n                });\r\n            } else {\r\n                this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n                const depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);\r\n                this.depthOfField.depthTexture = depthRenderer.getDepthMap();\r\n            }\r\n\r\n            if (!this.depthOfField._isReady()) {\r\n                this.depthOfField._updateEffects();\r\n            }\r\n            this.addEffect(this.depthOfField);\r\n            this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);\r\n        } else {\r\n            this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n        }\r\n\r\n        if (this.bloomEnabled) {\r\n            if (!this.bloom._isReady()) {\r\n                this.bloom._updateEffects();\r\n            }\r\n            this.addEffect(this.bloom);\r\n            this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);\r\n        }\r\n\r\n        if (this._imageProcessingEnabled) {\r\n            this.imageProcessing = new ImageProcessingPostProcess(\r\n                \"imageProcessing\",\r\n                1.0,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                this._defaultPipelineTextureType,\r\n                this.scene.imageProcessingConfiguration\r\n            );\r\n            if (this._hdr) {\r\n                this.addEffect(\r\n                    new PostProcessRenderEffect(\r\n                        engine,\r\n                        this.ImageProcessingPostProcessId,\r\n                        () => {\r\n                            return this.imageProcessing;\r\n                        },\r\n                        true\r\n                    )\r\n                );\r\n                this._setAutoClearAndTextureSharing(this.imageProcessing);\r\n            } else {\r\n                this._scene.imageProcessingConfiguration.applyByPostProcess = false;\r\n            }\r\n\r\n            if (!this._cameras || this._cameras.length === 0) {\r\n                this._scene.imageProcessingConfiguration.applyByPostProcess = false;\r\n            }\r\n\r\n            if (!this.imageProcessing.getEffect()) {\r\n                this.imageProcessing._updateParameters();\r\n            }\r\n        }\r\n\r\n        if (this.sharpenEnabled) {\r\n            if (!this.sharpen.isReady()) {\r\n                this.sharpen.updateEffect();\r\n            }\r\n            this.addEffect(this._sharpenEffect);\r\n            this._setAutoClearAndTextureSharing(this.sharpen);\r\n        }\r\n\r\n        if (this.grainEnabled) {\r\n            if (!this.grain.isReady()) {\r\n                this.grain.updateEffect();\r\n            }\r\n            this.addEffect(this._grainEffect);\r\n            this._setAutoClearAndTextureSharing(this.grain);\r\n        }\r\n\r\n        if (this.chromaticAberrationEnabled) {\r\n            if (!this.chromaticAberration.isReady()) {\r\n                this.chromaticAberration.updateEffect();\r\n            }\r\n            this.addEffect(this._chromaticAberrationEffect);\r\n            this._setAutoClearAndTextureSharing(this.chromaticAberration);\r\n        }\r\n\r\n        if (this.fxaaEnabled) {\r\n            this.fxaa = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    engine,\r\n                    this.FxaaPostProcessId,\r\n                    () => {\r\n                        return this.fxaa;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n            this._setAutoClearAndTextureSharing(this.fxaa, true);\r\n        }\r\n\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\r\n        }\r\n\r\n        // In multicamera mode, the scene needs to autoclear in between cameras.\r\n        if ((this._scene.activeCameras && this._scene.activeCameras.length > 1) || (this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1)) {\r\n            this._scene.autoClear = true;\r\n        }\r\n        // The active camera on the scene can be changed anytime\r\n        if (!this._activeCameraChangedObserver) {\r\n            this._activeCameraChangedObserver = this._scene.onActiveCameraChanged.add(() => {\r\n                if (this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {\r\n                    this._scene.autoClear = true;\r\n                }\r\n            });\r\n        }\r\n        if (!this._activeCamerasChangedObserver) {\r\n            this._activeCamerasChangedObserver = this._scene.onActiveCamerasChanged.add(() => {\r\n                if (this._scene.activeCameras && this._scene.activeCameras.length > 1) {\r\n                    this._scene.autoClear = true;\r\n                }\r\n            });\r\n        }\r\n\r\n        this._adaptPostProcessesToViewPort();\r\n\r\n        if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {\r\n            Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\r\n        }\r\n\r\n        this.onBuildObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _disposePostProcesses(disposeNonRecreated = false): void {\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            const camera = this._cameras[i];\r\n\r\n            if (this.imageProcessing) {\r\n                this.imageProcessing.dispose(camera);\r\n            }\r\n\r\n            if (this.fxaa) {\r\n                this.fxaa.dispose(camera);\r\n            }\r\n\r\n            // These are created in the constructor and should not be disposed on every pipeline change\r\n            if (disposeNonRecreated) {\r\n                if (this.sharpen) {\r\n                    this.sharpen.dispose(camera);\r\n                }\r\n\r\n                if (this.depthOfField) {\r\n                    this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n                    this.depthOfField.disposeEffects(camera);\r\n                }\r\n\r\n                if (this.bloom) {\r\n                    this.bloom.disposeEffects(camera);\r\n                }\r\n\r\n                if (this.chromaticAberration) {\r\n                    this.chromaticAberration.dispose(camera);\r\n                }\r\n\r\n                if (this.grain) {\r\n                    this.grain.dispose(camera);\r\n                }\r\n                if (this._glowLayer) {\r\n                    this._glowLayer.dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        (<any>this.imageProcessing) = null;\r\n        (<any>this.fxaa) = null;\r\n\r\n        if (disposeNonRecreated) {\r\n            (<any>this.sharpen) = null;\r\n            (<any>this._sharpenEffect) = null;\r\n            (<any>this.depthOfField) = null;\r\n            (<any>this.bloom) = null;\r\n            (<any>this.chromaticAberration) = null;\r\n            (<any>this._chromaticAberrationEffect) = null;\r\n            (<any>this.grain) = null;\r\n            (<any>this._grainEffect) = null;\r\n            this._glowLayer = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a camera to the pipeline\r\n     * @param camera the camera to be added\r\n     */\r\n    public addCamera(camera: Camera): void {\r\n        this._camerasToBeAttached.push(camera);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Removes a camera from the pipeline\r\n     * @param camera the camera to remove\r\n     */\r\n    public removeCamera(camera: Camera): void {\r\n        const index = this._camerasToBeAttached.indexOf(camera);\r\n        this._camerasToBeAttached.splice(index, 1);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Dispose of the pipeline and stop all post processes\r\n     */\r\n    public override dispose(): void {\r\n        this._buildAllowed = false;\r\n        this.onBuildObservable.clear();\r\n        this._disposePostProcesses(true);\r\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n        this._scene._postProcessRenderPipelineManager.removePipeline(this.name);\r\n        this._scene.autoClear = true;\r\n        if (this._resizeObserver) {\r\n            this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n\r\n        this._scene.onActiveCameraChanged.remove(this._activeCameraChangedObserver);\r\n        this._scene.onActiveCamerasChanged.remove(this._activeCamerasChangedObserver);\r\n\r\n        this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the rendering pipeline (Used when exporting)\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"DefaultRenderingPipeline\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the serialized pipeline\r\n     * @param source Source pipeline.\r\n     * @param scene The scene to load the pipeline to.\r\n     * @param rootUrl The URL of the serialized pipeline.\r\n     * @returns An instantiated pipeline from the serialized object.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): DefaultRenderingPipeline {\r\n        return SerializationHelper.Parse(() => new DefaultRenderingPipeline(source._name, source._name._hdr, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DefaultRenderingPipeline\", DefaultRenderingPipeline);\r\n"],
  "mappings": "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",
  "names": []
}
