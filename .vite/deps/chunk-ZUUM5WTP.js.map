{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Layers/effectLayerSceneComponent.ts"],
  "sourcesContent": ["import { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AddParser } from \"core/Loading/Plugins/babylonFileParser.function\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n// Adds the parser to the scene parsers.\r\nAddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    if (parsedData.effectLayers) {\r\n        if (!container.effectLayers) {\r\n            container.effectLayers = [] as EffectLayer[];\r\n        }\r\n\r\n        for (let index = 0; index < parsedData.effectLayers.length; index++) {\r\n            const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\r\n            container.effectLayers.push(effectLayer);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any effect layers\r\n * in a given scene.\r\n */\r\nexport class EffectLayerSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_EFFECTLAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: AbstractEngine;\r\n    private _renderEffects = false;\r\n    private _needStencil = false;\r\n    private _previousStencilState = false;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\r\n\r\n        this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\r\n\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\r\n\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            effectLayer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Effect layers\r\n        serializationObject.effectLayers = [];\r\n\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            if (effectLayer.serialize) {\r\n                serializationObject.effectLayers.push(effectLayer.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: IAssetContainer): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        for (const o of container.effectLayers) {\r\n            this.scene.addEffectLayer(o);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: IAssetContainer, dispose?: boolean): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        for (const o of container.effectLayers) {\r\n            this.scene.removeEffectLayer(o);\r\n            if (dispose) {\r\n                o.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.effectLayers;\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _isReadyForMesh(mesh: AbstractMesh, hardwareInstancedRendering: boolean): boolean {\r\n        const currentRenderPassId = this._engine.currentRenderPassId;\r\n        const layers = this.scene.effectLayers;\r\n        for (const layer of layers) {\r\n            if (!layer.hasMesh(mesh)) {\r\n                continue;\r\n            }\r\n\r\n            const renderTarget = <RenderTargetTexture>(<any>layer)._mainTexture;\r\n            this._engine.currentRenderPassId = renderTarget.renderPassId;\r\n\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\r\n                    this._engine.currentRenderPassId = currentRenderPassId;\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        this._engine.currentRenderPassId = currentRenderPassId;\r\n        return true;\r\n    }\r\n\r\n    private _renderMainTexture(camera: Camera): boolean {\r\n        this._renderEffects = false;\r\n        this._needStencil = false;\r\n\r\n        let needRebind = false;\r\n\r\n        const layers = this.scene.effectLayers;\r\n        if (layers && layers.length > 0) {\r\n            this._previousStencilState = this._engine.getStencilBuffer();\r\n            for (const effectLayer of layers) {\r\n                if (\r\n                    effectLayer.shouldRender() &&\r\n                    (!effectLayer.camera ||\r\n                        (effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera) ||\r\n                        (effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1))\r\n                ) {\r\n                    this._renderEffects = true;\r\n                    this._needStencil = this._needStencil || effectLayer.needStencil();\r\n\r\n                    const renderTarget = <RenderTargetTexture>(<any>effectLayer)._mainTexture;\r\n                    if (renderTarget._shouldRender()) {\r\n                        this.scene.incrementRenderId();\r\n                        renderTarget.render(false, false);\r\n                        needRebind = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.scene.incrementRenderId();\r\n        }\r\n\r\n        return needRebind;\r\n    }\r\n\r\n    private _setStencil() {\r\n        // Activate effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _setStencilBack() {\r\n        // Restore effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(this._previousStencilState);\r\n        }\r\n    }\r\n\r\n    private _draw(renderingGroupId: number): void {\r\n        if (this._renderEffects) {\r\n            this._engine.setDepthBuffer(false);\r\n\r\n            const layers = this.scene.effectLayers;\r\n            for (let i = 0; i < layers.length; i++) {\r\n                const effectLayer = layers[i];\r\n                if (effectLayer.renderingGroupId === renderingGroupId) {\r\n                    if (effectLayer.shouldRender()) {\r\n                        effectLayer.render();\r\n                    }\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCamera(): void {\r\n        if (this._renderEffects) {\r\n            this._draw(-1);\r\n        }\r\n    }\r\n    private _drawRenderingGroup(index: number): void {\r\n        if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\r\n            this._draw(index);\r\n        }\r\n    }\r\n}\r\n\r\nEffectLayer._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER) as EffectLayerSceneComponent;\r\n    if (!component) {\r\n        component = new EffectLayerSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
