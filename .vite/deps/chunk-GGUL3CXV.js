import {
  PrepareSamplersForImageProcessing,
  PrepareUniformsForColorCurves,
  PrepareUniformsForImageProcessing
} from "./chunk-4CFWIRXS.js";
import {
  Mix
} from "./chunk-N5T6XPNQ.js";
import {
  SerializationHelper
} from "./chunk-ZKYT7Q6J.js";
import {
  __decorate,
  serialize,
  serializeAsColor4,
  serializeAsColorCurves,
  serializeAsTexture
} from "./chunk-STIKNZXL.js";
import {
  Color4
} from "./chunk-I3IYKWNG.js";
import {
  RegisterClass
} from "./chunk-LUXUKJKM.js";
import {
  Observable
} from "./chunk-3EU3L2QH.js";

// node_modules/.pnpm/@babylonjs+core@8.49.1/node_modules/@babylonjs/core/Materials/colorCurves.js
var ColorCurves = class _ColorCurves {
  constructor() {
    this._dirty = true;
    this._tempColor = new Color4(0, 0, 0, 0);
    this._globalCurve = new Color4(0, 0, 0, 0);
    this._highlightsCurve = new Color4(0, 0, 0, 0);
    this._midtonesCurve = new Color4(0, 0, 0, 0);
    this._shadowsCurve = new Color4(0, 0, 0, 0);
    this._positiveCurve = new Color4(0, 0, 0, 0);
    this._negativeCurve = new Color4(0, 0, 0, 0);
    this._globalHue = 30;
    this._globalDensity = 0;
    this._globalSaturation = 0;
    this._globalExposure = 0;
    this._highlightsHue = 30;
    this._highlightsDensity = 0;
    this._highlightsSaturation = 0;
    this._highlightsExposure = 0;
    this._midtonesHue = 30;
    this._midtonesDensity = 0;
    this._midtonesSaturation = 0;
    this._midtonesExposure = 0;
    this._shadowsHue = 30;
    this._shadowsDensity = 0;
    this._shadowsSaturation = 0;
    this._shadowsExposure = 0;
  }
  /**
   * Gets the global Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get globalHue() {
    return this._globalHue;
  }
  /**
   * Sets the global Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set globalHue(value) {
    this._globalHue = value;
    this._dirty = true;
  }
  /**
   * Gets the global Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get globalDensity() {
    return this._globalDensity;
  }
  /**
   * Sets the global Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set globalDensity(value) {
    this._globalDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the global Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get globalSaturation() {
    return this._globalSaturation;
  }
  /**
   * Sets the global Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set globalSaturation(value) {
    this._globalSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the global Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get globalExposure() {
    return this._globalExposure;
  }
  /**
   * Sets the global Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set globalExposure(value) {
    this._globalExposure = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get highlightsHue() {
    return this._highlightsHue;
  }
  /**
   * Sets the highlights Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set highlightsHue(value) {
    this._highlightsHue = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get highlightsDensity() {
    return this._highlightsDensity;
  }
  /**
   * Sets the highlights Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set highlightsDensity(value) {
    this._highlightsDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get highlightsSaturation() {
    return this._highlightsSaturation;
  }
  /**
   * Sets the highlights Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set highlightsSaturation(value) {
    this._highlightsSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get highlightsExposure() {
    return this._highlightsExposure;
  }
  /**
   * Sets the highlights Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set highlightsExposure(value) {
    this._highlightsExposure = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get midtonesHue() {
    return this._midtonesHue;
  }
  /**
   * Sets the midtones Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set midtonesHue(value) {
    this._midtonesHue = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get midtonesDensity() {
    return this._midtonesDensity;
  }
  /**
   * Sets the midtones Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set midtonesDensity(value) {
    this._midtonesDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get midtonesSaturation() {
    return this._midtonesSaturation;
  }
  /**
   * Sets the midtones Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set midtonesSaturation(value) {
    this._midtonesSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get midtonesExposure() {
    return this._midtonesExposure;
  }
  /**
   * Sets the midtones Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set midtonesExposure(value) {
    this._midtonesExposure = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get shadowsHue() {
    return this._shadowsHue;
  }
  /**
   * Sets the shadows Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set shadowsHue(value) {
    this._shadowsHue = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get shadowsDensity() {
    return this._shadowsDensity;
  }
  /**
   * Sets the shadows Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set shadowsDensity(value) {
    this._shadowsDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get shadowsSaturation() {
    return this._shadowsSaturation;
  }
  /**
   * Sets the shadows Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set shadowsSaturation(value) {
    this._shadowsSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get shadowsExposure() {
    return this._shadowsExposure;
  }
  /**
   * Sets the shadows Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set shadowsExposure(value) {
    this._shadowsExposure = value;
    this._dirty = true;
  }
  /**
   * Returns the class name
   * @returns The class name
   */
  getClassName() {
    return "ColorCurves";
  }
  /**
   * Binds the color curves to the shader.
   * @param colorCurves The color curve to bind
   * @param effect The effect to bind to
   * @param positiveUniform The positive uniform shader parameter
   * @param neutralUniform The neutral uniform shader parameter
   * @param negativeUniform The negative uniform shader parameter
   */
  static Bind(colorCurves, effect, positiveUniform = "vCameraColorCurvePositive", neutralUniform = "vCameraColorCurveNeutral", negativeUniform = "vCameraColorCurveNegative") {
    if (colorCurves._dirty) {
      colorCurves._dirty = false;
      colorCurves._getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);
      colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);
      colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);
    }
    if (effect) {
      effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);
      effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);
      effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);
    }
  }
  /**
   * Returns color grading data based on a hue, density, saturation and exposure value.
   * @param hue
   * @param density
   * @param saturation The saturation.
   * @param exposure The exposure.
   * @param result The result data container.
   */
  _getColorGradingDataToRef(hue, density, saturation, exposure, result) {
    if (hue == null) {
      return;
    }
    hue = _ColorCurves._Clamp(hue, 0, 360);
    density = _ColorCurves._Clamp(density, -100, 100);
    saturation = _ColorCurves._Clamp(saturation, -100, 100);
    exposure = _ColorCurves._Clamp(exposure, -100, 100);
    density = _ColorCurves._ApplyColorGradingSliderNonlinear(density);
    density *= 0.5;
    exposure = _ColorCurves._ApplyColorGradingSliderNonlinear(exposure);
    if (density < 0) {
      density *= -1;
      hue = (hue + 180) % 360;
    }
    _ColorCurves._FromHSBToRef(hue, density, 50 + 0.25 * exposure, result);
    result.scaleToRef(2, result);
    result.a = 1 + 0.01 * saturation;
  }
  /**
   * Takes an input slider value and returns an adjusted value that provides extra control near the centre.
   * @param value The input slider value in range [-100,100].
   * @returns Adjusted value.
   */
  static _ApplyColorGradingSliderNonlinear(value) {
    value /= 100;
    let x = Math.abs(value);
    x = Math.pow(x, 2);
    if (value < 0) {
      x *= -1;
    }
    x *= 100;
    return x;
  }
  /**
   * Returns an RGBA Color4 based on Hue, Saturation and Brightness (also referred to as value, HSV).
   * @param hue The hue (H) input.
   * @param saturation The saturation (S) input.
   * @param brightness The brightness (B) input.
   * @param result An RGBA color represented as Vector4.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static _FromHSBToRef(hue, saturation, brightness, result) {
    let h = _ColorCurves._Clamp(hue, 0, 360);
    const s = _ColorCurves._Clamp(saturation / 100, 0, 1);
    const v = _ColorCurves._Clamp(brightness / 100, 0, 1);
    if (s === 0) {
      result.r = v;
      result.g = v;
      result.b = v;
    } else {
      h /= 60;
      const i = Math.floor(h);
      const f = h - i;
      const p = v * (1 - s);
      const q = v * (1 - s * f);
      const t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          result.r = v;
          result.g = t;
          result.b = p;
          break;
        case 1:
          result.r = q;
          result.g = v;
          result.b = p;
          break;
        case 2:
          result.r = p;
          result.g = v;
          result.b = t;
          break;
        case 3:
          result.r = p;
          result.g = q;
          result.b = v;
          break;
        case 4:
          result.r = t;
          result.g = p;
          result.b = v;
          break;
        default:
          result.r = v;
          result.g = p;
          result.b = q;
          break;
      }
    }
    result.a = 1;
  }
  /**
   * Returns a value clamped between min and max
   * @param value The value to clamp
   * @param min The minimum of value
   * @param max The maximum of value
   * @returns The clamped value.
   */
  static _Clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  /**
   * Clones the current color curve instance.
   * @returns The cloned curves
   */
  clone() {
    return SerializationHelper.Clone(() => new _ColorCurves(), this);
  }
  /**
   * Serializes the current color curve instance to a json representation.
   * @returns a JSON representation
   */
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  /**
   * Parses the color curve from a json representation.
   * @param source the JSON source to parse
   * @returns The parsed curves
   */
  static Parse(source) {
    return SerializationHelper.Parse(() => new _ColorCurves(), source, null, null);
  }
};
ColorCurves.PrepareUniforms = PrepareUniformsForColorCurves;
__decorate([
  serialize()
], ColorCurves.prototype, "_globalHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalExposure", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsExposure", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesExposure", void 0);
SerializationHelper._ColorCurvesParser = ColorCurves.Parse;

// node_modules/.pnpm/@babylonjs+core@8.49.1/node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js
var ImageProcessingConfiguration = class _ImageProcessingConfiguration {
  constructor() {
    this.colorCurves = new ColorCurves();
    this._colorCurvesEnabled = false;
    this._colorGradingEnabled = false;
    this._colorGradingWithGreenDepth = true;
    this._colorGradingBGR = true;
    this._exposure = 1;
    this._toneMappingEnabled = false;
    this._toneMappingType = _ImageProcessingConfiguration.TONEMAPPING_STANDARD;
    this._contrast = 1;
    this.vignetteStretch = 0;
    this.vignetteCenterX = 0;
    this.vignetteCenterY = 0;
    this.vignetteWeight = 1.5;
    this.vignetteColor = new Color4(0, 0, 0, 0);
    this.vignetteCameraFov = 0.5;
    this._vignetteBlendMode = _ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY;
    this._vignetteEnabled = false;
    this._ditheringEnabled = false;
    this._ditheringIntensity = 1 / 255;
    this._skipFinalColorClamp = false;
    this._applyByPostProcess = false;
    this._isEnabled = true;
    this.outputTextureWidth = 0;
    this.outputTextureHeight = 0;
    this.onUpdateParameters = new Observable();
  }
  /**
   * Gets whether the color curves effect is enabled.
   */
  get colorCurvesEnabled() {
    return this._colorCurvesEnabled;
  }
  /**
   * Sets whether the color curves effect is enabled.
   */
  set colorCurvesEnabled(value) {
    if (this._colorCurvesEnabled === value) {
      return;
    }
    this._colorCurvesEnabled = value;
    this._updateParameters();
  }
  /**
   * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
   */
  get colorGradingTexture() {
    return this._colorGradingTexture;
  }
  /**
   * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
   */
  set colorGradingTexture(value) {
    if (this._colorGradingTexture === value) {
      return;
    }
    this._colorGradingTexture = value;
    this._updateParameters();
  }
  /**
   * Gets whether the color grading effect is enabled.
   */
  get colorGradingEnabled() {
    return this._colorGradingEnabled;
  }
  /**
   * Sets whether the color grading effect is enabled.
   */
  set colorGradingEnabled(value) {
    if (this._colorGradingEnabled === value) {
      return;
    }
    this._colorGradingEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets whether the color grading effect is using a green depth for the 3d Texture.
   */
  get colorGradingWithGreenDepth() {
    return this._colorGradingWithGreenDepth;
  }
  /**
   * Sets whether the color grading effect is using a green depth for the 3d Texture.
   */
  set colorGradingWithGreenDepth(value) {
    if (this._colorGradingWithGreenDepth === value) {
      return;
    }
    this._colorGradingWithGreenDepth = value;
    this._updateParameters();
  }
  /**
   * Gets whether the color grading texture contains BGR values.
   */
  get colorGradingBGR() {
    return this._colorGradingBGR;
  }
  /**
   * Sets whether the color grading texture contains BGR values.
   */
  set colorGradingBGR(value) {
    if (this._colorGradingBGR === value) {
      return;
    }
    this._colorGradingBGR = value;
    this._updateParameters();
  }
  /**
   * Gets the Exposure used in the effect.
   */
  get exposure() {
    return this._exposure;
  }
  /**
   * Sets the Exposure used in the effect.
   */
  set exposure(value) {
    if (this._exposure === value) {
      return;
    }
    this._exposure = value;
    this._updateParameters();
  }
  /**
   * Gets whether the tone mapping effect is enabled.
   */
  get toneMappingEnabled() {
    return this._toneMappingEnabled;
  }
  /**
   * Sets whether the tone mapping effect is enabled.
   */
  set toneMappingEnabled(value) {
    if (this._toneMappingEnabled === value) {
      return;
    }
    this._toneMappingEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets the type of tone mapping effect.
   */
  get toneMappingType() {
    return this._toneMappingType;
  }
  /**
   * Sets the type of tone mapping effect used in BabylonJS.
   */
  set toneMappingType(value) {
    if (this._toneMappingType === value) {
      return;
    }
    this._toneMappingType = value;
    this._updateParameters();
  }
  /**
   * Gets the contrast used in the effect.
   */
  get contrast() {
    return this._contrast;
  }
  /**
   * Sets the contrast used in the effect.
   */
  set contrast(value) {
    if (this._contrast === value) {
      return;
    }
    this._contrast = value;
    this._updateParameters();
  }
  /**
   * Back Compat: Vignette center Y Offset.
   * @deprecated use vignetteCenterY instead
   */
  get vignetteCentreY() {
    return this.vignetteCenterY;
  }
  set vignetteCentreY(value) {
    this.vignetteCenterY = value;
  }
  /**
   * Back Compat: Vignette center X Offset.
   * @deprecated use vignetteCenterX instead
   */
  get vignetteCentreX() {
    return this.vignetteCenterX;
  }
  set vignetteCentreX(value) {
    this.vignetteCenterX = value;
  }
  /**
   * Gets the vignette blend mode allowing different kind of effect.
   */
  get vignetteBlendMode() {
    return this._vignetteBlendMode;
  }
  /**
   * Sets the vignette blend mode allowing different kind of effect.
   */
  set vignetteBlendMode(value) {
    if (this._vignetteBlendMode === value) {
      return;
    }
    this._vignetteBlendMode = value;
    this._updateParameters();
  }
  /**
   * Gets whether the vignette effect is enabled.
   */
  get vignetteEnabled() {
    return this._vignetteEnabled;
  }
  /**
   * Sets whether the vignette effect is enabled.
   */
  set vignetteEnabled(value) {
    if (this._vignetteEnabled === value) {
      return;
    }
    this._vignetteEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets whether the dithering effect is enabled.
   * The dithering effect can be used to reduce banding.
   */
  get ditheringEnabled() {
    return this._ditheringEnabled;
  }
  /**
   * Sets whether the dithering effect is enabled.
   * The dithering effect can be used to reduce banding.
   */
  set ditheringEnabled(value) {
    if (this._ditheringEnabled === value) {
      return;
    }
    this._ditheringEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets the dithering intensity. 0 is no dithering. Default is 1.0 / 255.0.
   */
  get ditheringIntensity() {
    return this._ditheringIntensity;
  }
  /**
   * Sets the dithering intensity. 0 is no dithering. Default is 1.0 / 255.0.
   */
  set ditheringIntensity(value) {
    if (this._ditheringIntensity === value) {
      return;
    }
    this._ditheringIntensity = value;
    this._updateParameters();
  }
  /**
   * If apply by post process is set to true, setting this to true will skip the final color clamp step in the fragment shader
   * Applies to PBR materials.
   */
  get skipFinalColorClamp() {
    return this._skipFinalColorClamp;
  }
  /**
   * If apply by post process is set to true, setting this to true will skip the final color clamp step in the fragment shader
   * Applies to PBR materials.
   */
  set skipFinalColorClamp(value) {
    if (this._skipFinalColorClamp === value) {
      return;
    }
    this._skipFinalColorClamp = value;
    this._updateParameters();
  }
  /**
   * Gets whether the image processing is applied through a post process or not.
   */
  get applyByPostProcess() {
    return this._applyByPostProcess;
  }
  /**
   * Sets whether the image processing is applied through a post process or not.
   */
  set applyByPostProcess(value) {
    if (this._applyByPostProcess === value) {
      return;
    }
    this._applyByPostProcess = value;
    this._updateParameters();
  }
  /**
   * Gets whether the image processing is enabled or not.
   */
  get isEnabled() {
    return this._isEnabled;
  }
  /**
   * Sets whether the image processing is enabled or not.
   */
  set isEnabled(value) {
    if (this._isEnabled === value) {
      return;
    }
    this._isEnabled = value;
    this._updateParameters();
  }
  /**
   * Method called each time the image processing information changes requires to recompile the effect.
   */
  _updateParameters() {
    this.onUpdateParameters.notifyObservers(this);
  }
  /**
   * Gets the current class name.
   * @returns "ImageProcessingConfiguration"
   */
  getClassName() {
    return "ImageProcessingConfiguration";
  }
  /**
   * Prepare the list of defines associated to the shader.
   * @param defines the list of defines to complete
   * @param forPostProcess Define if we are currently in post process mode or not
   */
  prepareDefines(defines, forPostProcess = false) {
    if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {
      defines.VIGNETTE = false;
      defines.TONEMAPPING = 0;
      defines.CONTRAST = false;
      defines.EXPOSURE = false;
      defines.COLORCURVES = false;
      defines.COLORGRADING = false;
      defines.COLORGRADING3D = false;
      defines.DITHER = false;
      defines.IMAGEPROCESSING = false;
      defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
      defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
      return;
    }
    defines.VIGNETTE = this.vignetteEnabled;
    defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === _ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY;
    defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;
    if (!this._toneMappingEnabled) {
      defines.TONEMAPPING = 0;
    } else {
      switch (this._toneMappingType) {
        case _ImageProcessingConfiguration.TONEMAPPING_KHR_PBR_NEUTRAL:
          defines.TONEMAPPING = 3;
          break;
        case _ImageProcessingConfiguration.TONEMAPPING_ACES:
          defines.TONEMAPPING = 2;
          break;
        default:
          defines.TONEMAPPING = 1;
          break;
      }
    }
    defines.CONTRAST = this.contrast !== 1;
    defines.EXPOSURE = this.exposure !== 1;
    defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;
    defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;
    if (defines.COLORGRADING) {
      defines.COLORGRADING3D = this.colorGradingTexture.is3D;
    } else {
      defines.COLORGRADING3D = false;
    }
    defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;
    defines.SAMPLER3DBGRMAP = this.colorGradingBGR;
    defines.DITHER = this._ditheringEnabled;
    defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;
    defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
    defines.IMAGEPROCESSING = defines.VIGNETTE || !!defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING || defines.DITHER;
  }
  /**
   * Returns true if all the image processing information are ready.
   * @returns True if ready, otherwise, false
   */
  isReady() {
    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
  }
  /**
   * Binds the image processing to the shader.
   * @param effect The effect to bind to
   * @param overrideAspectRatio Override the aspect ratio of the effect
   */
  bind(effect, overrideAspectRatio) {
    if (this._colorCurvesEnabled && this.colorCurves) {
      ColorCurves.Bind(this.colorCurves, effect);
    }
    if (this._vignetteEnabled || this._ditheringEnabled) {
      const inverseWidth = 1 / (this.outputTextureWidth || effect.getEngine().getRenderWidth());
      const inverseHeight = 1 / (this.outputTextureHeight || effect.getEngine().getRenderHeight());
      effect.setFloat2("vInverseScreenSize", inverseWidth, inverseHeight);
      if (this._ditheringEnabled) {
        effect.setFloat("ditherIntensity", 0.5 * this._ditheringIntensity);
      }
      if (this._vignetteEnabled) {
        const aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;
        let vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);
        let vignetteScaleX = vignetteScaleY * aspectRatio;
        const vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);
        vignetteScaleX = Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);
        vignetteScaleY = Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);
        effect.setFloat4("vignetteSettings1", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCenterX, -vignetteScaleY * this.vignetteCenterY);
        const vignettePower = -2 * this.vignetteWeight;
        effect.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);
      }
    }
    effect.setFloat("exposureLinear", this.exposure);
    effect.setFloat("contrast", this.contrast);
    if (this.colorGradingTexture) {
      effect.setTexture("txColorTransform", this.colorGradingTexture);
      const textureSize = this.colorGradingTexture.getSize().height;
      effect.setFloat4(
        "colorTransformSettings",
        (textureSize - 1) / textureSize,
        // textureScale
        0.5 / textureSize,
        // textureOffset
        textureSize,
        // textureSize
        this.colorGradingTexture.level
        // weight
      );
    }
  }
  /**
   * Clones the current image processing instance.
   * @returns The cloned image processing
   */
  clone() {
    return SerializationHelper.Clone(() => new _ImageProcessingConfiguration(), this);
  }
  /**
   * Serializes the current image processing instance to a json representation.
   * @returns a JSON representation
   */
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  /**
   * Parses the image processing from a json representation.
   * @param source the JSON source to parse
   * @returns The parsed image processing
   */
  static Parse(source) {
    const parsed = SerializationHelper.Parse(() => new _ImageProcessingConfiguration(), source, null, null);
    if (source.vignetteCentreX !== void 0) {
      parsed.vignetteCenterX = source.vignetteCentreX;
    }
    if (source.vignetteCentreY !== void 0) {
      parsed.vignetteCenterY = source.vignetteCentreY;
    }
    return parsed;
  }
  /**
   * Used to apply the vignette as a mix with the pixel color.
   */
  static get VIGNETTEMODE_MULTIPLY() {
    return this._VIGNETTEMODE_MULTIPLY;
  }
  /**
   * Used to apply the vignette as a replacement of the pixel color.
   */
  static get VIGNETTEMODE_OPAQUE() {
    return this._VIGNETTEMODE_OPAQUE;
  }
};
ImageProcessingConfiguration.TONEMAPPING_STANDARD = 0;
ImageProcessingConfiguration.TONEMAPPING_ACES = 1;
ImageProcessingConfiguration.TONEMAPPING_KHR_PBR_NEUTRAL = 2;
ImageProcessingConfiguration.PrepareUniforms = PrepareUniformsForImageProcessing;
ImageProcessingConfiguration.PrepareSamplers = PrepareSamplersForImageProcessing;
ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY = 0;
ImageProcessingConfiguration._VIGNETTEMODE_OPAQUE = 1;
__decorate([
  serializeAsColorCurves()
], ImageProcessingConfiguration.prototype, "colorCurves", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorCurvesEnabled", void 0);
__decorate([
  serializeAsTexture("colorGradingTexture")
], ImageProcessingConfiguration.prototype, "_colorGradingTexture", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingWithGreenDepth", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingBGR", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_exposure", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_toneMappingEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_toneMappingType", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_contrast", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteStretch", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCenterX", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCenterY", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteWeight", void 0);
__decorate([
  serializeAsColor4()
], ImageProcessingConfiguration.prototype, "vignetteColor", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCameraFov", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_vignetteBlendMode", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_vignetteEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_ditheringEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_ditheringIntensity", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_skipFinalColorClamp", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_applyByPostProcess", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_isEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "outputTextureWidth", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "outputTextureHeight", void 0);
SerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;
RegisterClass("BABYLON.ImageProcessingConfiguration", ImageProcessingConfiguration);

export {
  ImageProcessingConfiguration
};
//# sourceMappingURL=chunk-GGUL3CXV.js.map
