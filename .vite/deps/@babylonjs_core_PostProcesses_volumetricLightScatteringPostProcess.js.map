{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Shaders/volumetricLightScattering.fragment.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Shaders/volumetricLightScatteringPass.vertex.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Shaders/volumetricLightScatteringPass.fragment.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/volumetricLightScatteringPostProcess.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"volumetricLightScatteringPixelShader\";\nconst shader = `uniform sampler2D textureSampler;uniform sampler2D lightScatteringSampler;uniform float decay;uniform float exposure;uniform float weight;uniform float density;uniform vec2 meshPositionOnScreen;varying vec2 vUV;\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec2 tc=vUV;vec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);deltaTexCoord*=1.0/float(NUM_SAMPLES)*density;float illuminationDecay=1.0;vec4 color=texture2D(lightScatteringSampler,tc)*0.4;for(int i=0; i<NUM_SAMPLES; i++) {tc-=deltaTexCoord;vec4 dataSample=texture2D(lightScatteringSampler,tc)*0.4;dataSample*=illuminationDecay*weight;color+=dataSample;illuminationDecay*=decay;}\nvec4 realColor=texture2D(textureSampler,vUV);gl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),realColor.a))+(realColor*(1.5-0.4)));\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const volumetricLightScatteringPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\n\nconst name = \"volumetricLightScatteringPassVertexShader\";\nconst shader = `attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\nuniform mat4 viewProjection;uniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;uniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;\n#if (defined(ALPHATEST) || defined(NEED_UV)) && defined(UV1)\nvec2 uvUpdated=uv;\n#endif\n#if (defined(ALPHATEST) || defined(NEED_UV)) && defined(UV2)\nvec2 uv2Updated=uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const volumetricLightScatteringPassVertexShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"volumetricLightScatteringPassPixelShader\";\nconst shader = `#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;\n#endif\n#if defined(ALPHATEST)\nuniform sampler2D diffuseSampler;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#if defined(ALPHATEST)\nvec4 diffuseColor=texture2D(diffuseSampler,vUV);if (diffuseColor.a<0.4)\ndiscard;\n#endif\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const volumetricLightScatteringPassPixelShader = { name, shader };\n", "import { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect, IEffectCreationOptions } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\n\r\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\r\n\r\nimport \"../Shaders/depth.vertex\";\r\nimport \"../Shaders/volumetricLightScattering.fragment\";\r\nimport \"../Shaders/volumetricLightScatteringPass.vertex\";\r\nimport \"../Shaders/volumetricLightScatteringPass.fragment\";\r\nimport { Color4, Color3 } from \"../Maths/math.color\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Nullable } from \"../types\";\r\n\r\nimport { BindBonesParameters, BindMorphTargetParameters, PrepareDefinesAndAttributesForMorphTargets, PushAttributesForInstances } from \"../Materials/materialHelper.functions\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EffectFallbacks } from \"core/Materials/effectFallbacks\";\r\n\r\n/**\r\n *  Inspired by https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process\r\n */\r\nexport class VolumetricLightScatteringPostProcess extends PostProcess {\r\n    // Members\r\n    private _volumetricLightScatteringRTT: RenderTargetTexture;\r\n    private _viewPort: Viewport;\r\n    private _screenCoordinates: Vector2 = Vector2.Zero();\r\n\r\n    /**\r\n     * If not undefined, the mesh position is computed from the attached node position\r\n     */\r\n    public attachedNode: { position: Vector3 };\r\n\r\n    /**\r\n     * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\r\n     */\r\n    @serializeAsVector3()\r\n    public customMeshPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\r\n     */\r\n    @serialize()\r\n    public useCustomMeshPosition: boolean = false;\r\n\r\n    /**\r\n     * If the post-process should inverse the light scattering direction\r\n     */\r\n    @serialize()\r\n    public invert: boolean = true;\r\n\r\n    /**\r\n     * The internal mesh used by the post-process\r\n     */\r\n    @serializeAsMeshReference()\r\n    public mesh: Mesh;\r\n\r\n    /**\r\n     * @internal\r\n     * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\r\n     */\r\n    public get useDiffuseColor(): boolean {\r\n        Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\r\n        return false;\r\n    }\r\n\r\n    public set useDiffuseColor(useDiffuseColor: boolean) {\r\n        Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\r\n    }\r\n\r\n    /**\r\n     * Array containing the excluded meshes not rendered in the internal pass\r\n     */\r\n    @serialize()\r\n    public excludedMeshes: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * Array containing the only meshes rendered in the internal pass.\r\n     * If this array is not empty, only the meshes from this array are rendered in the internal pass\r\n     */\r\n    @serialize()\r\n    public includedMeshes: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * Controls the overall intensity of the post-process\r\n     */\r\n    @serialize()\r\n    public exposure = 0.3;\r\n\r\n    /**\r\n     * Dissipates each sample's contribution in range [0, 1]\r\n     */\r\n    @serialize()\r\n    public decay = 0.96815;\r\n\r\n    /**\r\n     * Controls the overall intensity of each sample\r\n     */\r\n    @serialize()\r\n    public weight = 0.58767;\r\n\r\n    /**\r\n     * Controls the density of each sample\r\n     */\r\n    @serialize()\r\n    public density = 0.926;\r\n\r\n    /**\r\n     * @constructor\r\n     * @param name The post-process name\r\n     * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n     * @param camera The camera that the post-process will be attached to\r\n     * @param mesh The mesh used to create the light scattering\r\n     * @param samples The post-process quality, default 100\r\n     * @param samplingMode The post-process filtering mode\r\n     * @param engine The babylon engine\r\n     * @param reusable If the post-process is reusable\r\n     * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\r\n     */\r\n    constructor(\r\n        name: string,\r\n        ratio: any,\r\n        camera: Nullable<Camera>,\r\n        mesh?: Mesh,\r\n        samples: number = 100,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        scene?: Scene\r\n    ) {\r\n        super(\r\n            name,\r\n            \"volumetricLightScattering\",\r\n            [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"],\r\n            [\"lightScatteringSampler\"],\r\n            ratio.postProcessRatio || ratio,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define NUM_SAMPLES \" + samples\r\n        );\r\n        scene = camera?.getScene() ?? scene ?? this._scene; // parameter \"scene\" can be null.\r\n\r\n        engine = scene.getEngine();\r\n        this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n        // Configure mesh\r\n        this.mesh = mesh ?? VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene);\r\n        // Configure\r\n        this._createPass(scene, ratio.passRatio || ratio);\r\n\r\n        this.onActivate = (camera: Camera) => {\r\n            if (!this.isSupported) {\r\n                this.dispose(camera);\r\n            }\r\n\r\n            this.onActivate = null;\r\n        };\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            this._updateMeshScreenCoordinates(scene);\r\n\r\n            effect.setTexture(\"lightScatteringSampler\", this._volumetricLightScatteringRTT);\r\n            effect.setFloat(\"exposure\", this.exposure);\r\n            effect.setFloat(\"decay\", this.decay);\r\n            effect.setFloat(\"weight\", this.weight);\r\n            effect.setFloat(\"density\", this.density);\r\n            effect.setVector2(\"meshPositionOnScreen\", this._screenCoordinates);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"VolumetricLightScatteringPostProcess\"\r\n     * @returns \"VolumetricLightScatteringPostProcess\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"VolumetricLightScatteringPostProcess\";\r\n    }\r\n\r\n    private _isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const mesh = subMesh.getMesh();\r\n\r\n        // Render this.mesh as default\r\n        if (mesh === this.mesh && mesh.material) {\r\n            return mesh.material.isReady(mesh);\r\n        }\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[this._scene.getEngine().currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const defines = [];\r\n        const attribs = [VertexBuffer.PositionKind];\r\n        const material = subMesh.getMaterial();\r\n\r\n        let uv1 = false;\r\n        let uv2 = false;\r\n        const color = false;\r\n\r\n        // Alpha test\r\n        if (material) {\r\n            const needAlphaTesting = material.needAlphaTestingForMesh(mesh);\r\n            if (needAlphaTesting) {\r\n                defines.push(\"#define ALPHATEST\");\r\n            }\r\n\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n                uv1 = needAlphaTesting;\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n                uv2 = needAlphaTesting;\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const numMorphInfluencers = mesh.morphTargetManager\r\n            ? PrepareDefinesAndAttributesForMorphTargets(\r\n                  mesh.morphTargetManager,\r\n                  defines,\r\n                  attribs,\r\n                  mesh,\r\n                  true, // usePositionMorph\r\n                  false, // useNormalMorph\r\n                  false, // useTangentMorph\r\n                  uv1, // useUVMorph\r\n                  uv2, // useUV2Morph\r\n                  color // useColorMorph\r\n              )\r\n            : 0;\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Baked vertex animations\r\n        const bvaManager = mesh.bakedVertexAnimationManager;\r\n        if (bvaManager && bvaManager.isEnabled) {\r\n            defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n            if (useInstances) {\r\n                attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n            }\r\n        }\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"boneTextureWidth\",\r\n                \"viewProjection\",\r\n                \"diffuseMatrix\",\r\n                \"morphTargetInfluences\",\r\n                \"morphTargetCount\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n                \"bakedVertexAnimationSettings\",\r\n                \"bakedVertexAnimationTextureSizeInverted\",\r\n                \"bakedVertexAnimationTime\",\r\n                \"bakedVertexAnimationTexture\",\r\n            ];\r\n            const samplers = [\"diffuseSampler\", \"morphTargets\", \"boneSampler\", \"bakedVertexAnimationTexture\"];\r\n\r\n            drawWrapper.setEffect(\r\n                mesh\r\n                    .getScene()\r\n                    .getEngine()\r\n                    .createEffect(\r\n                        \"volumetricLightScatteringPass\",\r\n                        <IEffectCreationOptions>{\r\n                            attributes: attribs,\r\n                            uniformsNames: uniforms,\r\n                            uniformBuffersNames: [],\r\n                            samplers: samplers,\r\n                            defines: join,\r\n                            fallbacks: fallbacks,\r\n                            onCompiled: null,\r\n                            onError: null,\r\n                            indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },\r\n                        },\r\n                        mesh.getScene().getEngine()\r\n                    ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Sets the new light position for light scattering effect\r\n     * @param position The new custom light position\r\n     */\r\n    public setCustomMeshPosition(position: Vector3): void {\r\n        this.customMeshPosition = position;\r\n    }\r\n\r\n    /**\r\n     * Returns the light position for light scattering effect\r\n     * @returns Vector3 The custom light position\r\n     */\r\n    public getCustomMeshPosition(): Vector3 {\r\n        return this.customMeshPosition;\r\n    }\r\n\r\n    /**\r\n     * Disposes the internal assets and detaches the post-process from the camera\r\n     * @param camera The camera from which to detach the post-process\r\n     */\r\n    public override dispose(camera: Camera): void {\r\n        const rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\r\n        if (rttIndex !== -1) {\r\n            camera.getScene().customRenderTargets.splice(rttIndex, 1);\r\n        }\r\n\r\n        this._volumetricLightScatteringRTT.dispose();\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Returns the render target texture used by the post-process\r\n     * @returns the render target texture used by the post-process\r\n     */\r\n    public getPass(): RenderTargetTexture {\r\n        return this._volumetricLightScatteringRTT;\r\n    }\r\n\r\n    // Private methods\r\n    private _meshExcluded(mesh: AbstractMesh) {\r\n        if ((this.includedMeshes.length > 0 && this.includedMeshes.indexOf(mesh) === -1) || (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _createPass(scene: Scene, ratio: number): void {\r\n        const engine = scene.getEngine();\r\n\r\n        this._volumetricLightScatteringRTT = new RenderTargetTexture(\r\n            \"volumetricLightScatteringMap\",\r\n            { width: engine.getRenderWidth() * ratio, height: engine.getRenderHeight() * ratio },\r\n            scene,\r\n            false,\r\n            true,\r\n            Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n        );\r\n        this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._volumetricLightScatteringRTT.renderList = null;\r\n        this._volumetricLightScatteringRTT.renderParticles = false;\r\n        this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\r\n\r\n        const camera = this.getCamera();\r\n        if (camera) {\r\n            camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\r\n        } else {\r\n            scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\r\n        }\r\n\r\n        // Custom render function for submeshes\r\n        const renderSubMesh = (subMesh: SubMesh): void => {\r\n            const renderingMesh = subMesh.getRenderingMesh();\r\n            const effectiveMesh = subMesh.getEffectiveMesh();\r\n            if (this._meshExcluded(renderingMesh)) {\r\n                return;\r\n            }\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            const material = subMesh.getMaterial();\r\n\r\n            if (!material) {\r\n                return;\r\n            }\r\n\r\n            const scene = renderingMesh.getScene();\r\n            const engine = scene.getEngine();\r\n\r\n            // Culling\r\n            engine.setState(material.backFaceCulling, undefined, undefined, undefined, material.cullBackFaces);\r\n\r\n            // Managing instances\r\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n\r\n            if (this._isReady(subMesh, hardwareInstancedRendering)) {\r\n                const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n                let drawWrapper = subMesh._getDrawWrapper();\r\n                if (renderingMesh === this.mesh && !drawWrapper) {\r\n                    drawWrapper = material._getDrawWrapper();\r\n                }\r\n\r\n                if (!drawWrapper) {\r\n                    return;\r\n                }\r\n\r\n                const effect = drawWrapper.effect!;\r\n\r\n                engine.enableEffect(drawWrapper);\r\n                if (!hardwareInstancedRendering) {\r\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\r\n                }\r\n\r\n                if (renderingMesh === this.mesh) {\r\n                    material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\r\n                } else if (renderingMaterial) {\r\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n                } else {\r\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n                    // Alpha test\r\n                    if (material.needAlphaTestingForMesh(effectiveMesh)) {\r\n                        const alphaTexture = material.getAlphaTestTexture();\r\n\r\n                        if (alphaTexture) {\r\n                            effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bones\r\n                    BindBonesParameters(renderingMesh, effect);\r\n\r\n                    // Morph targets\r\n                    BindMorphTargetParameters(renderingMesh, effect);\r\n                    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                        renderingMesh.morphTargetManager._bind(effect);\r\n                    }\r\n\r\n                    // Baked vertex animations\r\n                    const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;\r\n                    if (bvaManager && bvaManager.isEnabled) {\r\n                        bvaManager.bind(effect, hardwareInstancedRendering);\r\n                    }\r\n                }\r\n\r\n                if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\r\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\r\n                    if (!isInstance) {\r\n                        effect.setMatrix(\"world\", world);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n        // Render target texture callbacks\r\n        let savedSceneClearColor: Color4;\r\n        const sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\r\n\r\n        this._volumetricLightScatteringRTT.onBeforeRenderObservable.add((): void => {\r\n            savedSceneClearColor = scene.clearColor;\r\n            scene.clearColor = sceneClearColor;\r\n        });\r\n\r\n        this._volumetricLightScatteringRTT.onAfterRenderObservable.add((): void => {\r\n            scene.clearColor = savedSceneClearColor;\r\n        });\r\n\r\n        this._volumetricLightScatteringRTT.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n\r\n                    if (!this._isReady(subMesh, hardwareInstancedRendering)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        this._volumetricLightScatteringRTT.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            const engine = scene.getEngine();\r\n            let index: number;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (transparentSubMeshes.length) {\r\n                // Sort sub meshes\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    const submesh = transparentSubMeshes.data[index];\r\n                    const boundingInfo = submesh.getBoundingInfo();\r\n\r\n                    if (boundingInfo && scene.activeCamera) {\r\n                        submesh._alphaIndex = submesh.getMesh().alphaIndex;\r\n                        submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\r\n                    }\r\n                }\r\n\r\n                const sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\r\n                sortedArray.sort((a, b) => {\r\n                    // Alpha index first\r\n                    if (a._alphaIndex > b._alphaIndex) {\r\n                        return 1;\r\n                    }\r\n                    if (a._alphaIndex < b._alphaIndex) {\r\n                        return -1;\r\n                    }\r\n\r\n                    // Then distance to camera\r\n                    if (a._distanceToCamera < b._distanceToCamera) {\r\n                        return 1;\r\n                    }\r\n                    if (a._distanceToCamera > b._distanceToCamera) {\r\n                        return -1;\r\n                    }\r\n\r\n                    return 0;\r\n                });\r\n\r\n                // Render sub meshes\r\n                engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                for (index = 0; index < sortedArray.length; index++) {\r\n                    renderSubMesh(sortedArray[index]);\r\n                }\r\n                engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n            }\r\n        };\r\n    }\r\n\r\n    private _updateMeshScreenCoordinates(scene: Scene): void {\r\n        const transform = scene.getTransformMatrix();\r\n        let meshPosition: Vector3;\r\n\r\n        if (this.useCustomMeshPosition) {\r\n            meshPosition = this.customMeshPosition;\r\n        } else if (this.attachedNode) {\r\n            meshPosition = this.attachedNode.position;\r\n        } else {\r\n            meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\r\n        }\r\n\r\n        const pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\r\n\r\n        this._screenCoordinates.x = pos.x / this._viewPort.width;\r\n        this._screenCoordinates.y = pos.y / this._viewPort.height;\r\n\r\n        if (this.invert) {\r\n            this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    // Static methods\r\n    /**\r\n     * Creates a default mesh for the Volumeric Light Scattering post-process\r\n     * @param name The mesh name\r\n     * @param scene The scene where to create the mesh\r\n     * @returns the default mesh\r\n     */\r\n    public static CreateDefaultMesh(name: string, scene: Scene): Mesh {\r\n        const mesh = CreatePlane(name, { size: 1 }, scene);\r\n        mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\r\n\r\n        const material = new StandardMaterial(name + \"Material\", scene);\r\n        material.emissiveColor = new Color3(1, 1, 1);\r\n\r\n        mesh.material = material;\r\n\r\n        return mesh;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VolumetricLightScatteringPostProcess\", VolumetricLightScatteringPostProcess);\r\n"],
  "mappings": "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",
  "names": ["name", "shader", "name", "shader", "name", "camera", "scene", "engine"]
}
