{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Layers/thinEffectLayer.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Layers/effectLayer.ts"],
  "sourcesContent": ["import type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { EffectWrapperCreationOptions } from \"core/Materials/effectRenderer\";\r\nimport { EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { AddClipPlaneUniforms, BindClipPlane, PrepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\nimport { BindMorphTargetParameters, PrepareDefinesAndAttributesForMorphTargets, PushAttributesForInstances } from \"../Materials/materialHelper.functions\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { ObjectRenderer } from \"core/Rendering/objectRenderer\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"core/Engines/engine\";\r\n\r\n/**\r\n * Special Glow Blur post process only blurring the alpha channel\r\n * It enforces keeping the most luminous color in the color channel.\r\n * @internal\r\n */\r\nexport class ThinGlowBlurPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"glowBlurPostProcess\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"screenSize\", \"direction\", \"blurWidth\"];\r\n\r\n    constructor(\r\n        name: string,\r\n        engine: Nullable<AbstractEngine> = null,\r\n        public direction: Vector2,\r\n        public kernel: number,\r\n        options?: EffectWrapperCreationOptions\r\n    ) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinGlowBlurPostProcess.FragmentUrl,\r\n            uniforms: ThinGlowBlurPostProcess.Uniforms,\r\n        });\r\n    }\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(import(\"../ShadersWGSL/glowBlurPostProcess.fragment\"));\r\n        } else {\r\n            list.push(import(\"../Shaders/glowBlurPostProcess.fragment\"));\r\n        }\r\n\r\n        super._gatherImports(useWebGPU, list);\r\n    }\r\n\r\n    public textureWidth: number = 0;\r\n\r\n    public textureHeight: number = 0;\r\n\r\n    public override bind() {\r\n        super.bind();\r\n        this._drawWrapper.effect!.setFloat2(\"screenSize\", this.textureWidth, this.textureHeight);\r\n        this._drawWrapper.effect!.setVector2(\"direction\", this.direction);\r\n        this._drawWrapper.effect!.setFloat(\"blurWidth\", this.kernel);\r\n    }\r\n}\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IThinEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the glowing objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio?: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure resize independent blur. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_BYTE\r\n     */\r\n    mainTextureType?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation. Default: ALPHA_COMBINE\r\n     */\r\n    alphaBlendingMode?: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera?: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId?: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class ThinEffectLayer {\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _mergeDrawWrapper: DrawWrapper[];\r\n    private _dontCheckIfReady = false;\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: AbstractEngine;\r\n    /** @internal */\r\n    public _options: Required<IThinEffectLayerOptions>;\r\n    protected _objectRenderer: ObjectRenderer;\r\n    /** @internal */\r\n    public _shouldRender = true;\r\n    /** @internal */\r\n    public _emissiveTextureAndColor: { texture: Nullable<BaseTexture>; color: Color4 } = { texture: null, color: new Color4() };\r\n    /** @internal */\r\n    public _effectIntensity: { [meshUniqueId: number]: number } = {};\r\n    /** @internal */\r\n    public _postProcesses: EffectWrapper[] = [];\r\n\r\n    /**\r\n     * Force all the effect layers to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    public neutralColor: Color4 = new Color4();\r\n\r\n    /**\r\n     * Specifies whether the effect layer is enabled or not.\r\n     */\r\n    public isEnabled: boolean = true;\r\n\r\n    /**\r\n     * Gets/sets the camera attached to the layer.\r\n     */\r\n    public get camera(): Nullable<Camera> {\r\n        return this._options.camera;\r\n    }\r\n\r\n    public set camera(camera: Nullable<Camera>) {\r\n        this._options.camera = camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._options.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._options.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    public disableBoundingBoxesFromEffectLayer = false;\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderLayerObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the layer is being blurred.\r\n     */\r\n    public onBeforeBlurObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the layer has been blurred.\r\n     */\r\n    public onAfterBlurObservable = new Observable<ThinEffectLayer>();\r\n\r\n    /**\r\n     * Gets the object renderer used to render objects in the layer\r\n     */\r\n    public get objectRenderer() {\r\n        return this._objectRenderer;\r\n    }\r\n\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    private _materialForRendering: { [id: string]: [AbstractMesh, Material] } = {};\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in the layer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._objectRenderer.setMaterialForRendering(mesh, material);\r\n        if (Array.isArray(mesh)) {\r\n            for (let i = 0; i < mesh.length; ++i) {\r\n                const currentMesh = mesh[i];\r\n                if (!material) {\r\n                    delete this._materialForRendering[currentMesh.uniqueId];\r\n                } else {\r\n                    this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\r\n                }\r\n            }\r\n        } else {\r\n            if (!material) {\r\n                delete this._materialForRendering[mesh.uniqueId];\r\n            } else {\r\n                this._materialForRendering[mesh.uniqueId] = [mesh, material];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to get the effect intensity for\r\n     * @returns The intensity of the effect for the mesh\r\n     */\r\n    public getEffectIntensity(mesh: AbstractMesh) {\r\n        return this._effectIntensity[mesh.uniqueId] ?? 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to set the effect intensity for\r\n     * @param intensity The intensity of the effect for the mesh\r\n     */\r\n    public setEffectIntensity(mesh: AbstractMesh, intensity: number): void {\r\n        this._effectIntensity[mesh.uniqueId] = intensity;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     * @param dontCheckIfReady Specifies if the layer should disable checking whether all the post processes are ready (default: false). To save performance, this should be set to true and you should call `isReady` manually before rendering to the layer.\r\n     * @param _additionalImportShadersAsync Additional shaders to import when the layer is created\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene?: Scene,\r\n        forceGLSL = false,\r\n        dontCheckIfReady = false,\r\n        private _additionalImportShadersAsync?: () => Promise<void>\r\n    ) {\r\n        this.name = name;\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        this._dontCheckIfReady = dontCheckIfReady;\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        if (engine.isWebGPU && !forceGLSL && !ThinEffectLayer.ForceGLSL) {\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n        }\r\n\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Generate Buffers\r\n        this._generateIndexBuffer();\r\n        this._generateVertexBuffer();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shadersLoaded = false;\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param _subMesh the mesh to check for\r\n     * @param _useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public isReady(_subMesh: SubMesh, _useInstances: boolean): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public needStencil(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createMergeEffect(): Effect {\r\n        throw new Error(\"Effect Layer: no merge effect defined\");\r\n    }\r\n\r\n    /** @internal */\r\n    public _createTextureAndPostProcesses(): void {}\r\n\r\n    /** @internal */\r\n    public bindTexturesForCompose: (effect: Effect) => void;\r\n\r\n    /** @internal */\r\n    public _internalCompose(_effect: Effect, _renderIndex: number): void {}\r\n\r\n    /** @internal */\r\n    public _setEmissiveTextureAndColor(_mesh: Mesh, _subMesh: SubMesh, _material: Material): void {}\r\n\r\n    /** @internal */\r\n    public _numInternalDraws(): number {\r\n        return 1;\r\n    }\r\n\r\n    /** @internal */\r\n    public _init(options: IThinEffectLayerOptions): void {\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            mainTextureFixedSize: 0,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            ...options,\r\n        };\r\n\r\n        this._createObjectRenderer();\r\n    }\r\n\r\n    private _generateIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    private _generateVertexBuffer(): void {\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n    }\r\n\r\n    protected _createObjectRenderer(): void {\r\n        this._objectRenderer = new ObjectRenderer(`ObjectRenderer for thin effect layer ${this.name}`, this._scene, {\r\n            doNotChangeAspectRatio: true,\r\n        });\r\n        this._objectRenderer.activeCamera = this._options.camera;\r\n        this._objectRenderer.renderParticles = false;\r\n        this._objectRenderer.renderList = null;\r\n\r\n        // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\r\n        const hasBoundingBoxRenderer = !!this._scene.getBoundingBoxRenderer;\r\n\r\n        let boundingBoxRendererEnabled = false;\r\n        if (hasBoundingBoxRenderer) {\r\n            this._objectRenderer.onBeforeRenderObservable.add(() => {\r\n                boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\r\n                this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\r\n            });\r\n\r\n            this._objectRenderer.onAfterRenderObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\r\n            });\r\n        }\r\n\r\n        this._objectRenderer.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n                    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n                    if (!this._isSubMeshReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        this._objectRenderer.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            this.onBeforeRenderLayerObservable.notifyObservers(this);\r\n\r\n            let index: number;\r\n\r\n            const engine = this._scene.getEngine();\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    this._renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                this._renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                this._renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            const previousAlphaMode = engine.getAlphaMode();\r\n\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                const subMesh = transparentSubMeshes.data[index];\r\n                const material = subMesh.getMaterial();\r\n                if (material && material.needDepthPrePass) {\r\n                    const engine = material.getScene().getEngine();\r\n                    engine.setColorWrite(false);\r\n                    this._renderSubMesh(subMesh);\r\n                    engine.setColorWrite(true);\r\n                }\r\n                this._renderSubMesh(subMesh, true);\r\n            }\r\n\r\n            engine.setAlphaMode(previousAlphaMode);\r\n        };\r\n    }\r\n\r\n    /** @internal */\r\n    public _addCustomEffectDefines(_defines: string[]): void {}\r\n\r\n    /** @internal */\r\n    public _internalIsSubMeshReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\r\n            return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\r\n        }\r\n\r\n        const defines: string[] = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        let uv1 = false;\r\n        let uv2 = false;\r\n        const color = false;\r\n\r\n        // Diffuse\r\n        if (material) {\r\n            const needAlphaTest = material.needAlphaTestingForMesh(mesh);\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse =\r\n                diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                defines.push(\"#define DIFFUSE\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define DIFFUSEUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define DIFFUSEUV1\");\r\n                    uv1 = true;\r\n                }\r\n\r\n                if (needAlphaTest) {\r\n                    defines.push(\"#define ALPHATEST\");\r\n                    defines.push(\"#define ALPHATESTVALUE 0.4\");\r\n                }\r\n                if (!diffuseTexture.gammaSpace) {\r\n                    defines.push(\"#define DIFFUSE_ISLINEAR\");\r\n                }\r\n            }\r\n\r\n            const opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                defines.push(\"#define OPACITY\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define OPACITYUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define OPACITYUV1\");\r\n                    uv1 = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emissive\r\n        if (emissiveTexture) {\r\n            defines.push(\"#define EMISSIVE\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\r\n                defines.push(\"#define EMISSIVEUV2\");\r\n                uv2 = true;\r\n            } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                defines.push(\"#define EMISSIVEUV1\");\r\n                uv1 = true;\r\n            }\r\n            if (!emissiveTexture.gammaSpace) {\r\n                defines.push(\"#define EMISSIVE_ISLINEAR\");\r\n            }\r\n        }\r\n\r\n        // Vertex\r\n        if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (uv1) {\r\n            attribs.push(VertexBuffer.UVKind);\r\n            defines.push(\"#define UV1\");\r\n        }\r\n        if (uv2) {\r\n            attribs.push(VertexBuffer.UV2Kind);\r\n            defines.push(\"#define UV2\");\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n\r\n            const skeleton = mesh.skeleton;\r\n            if (skeleton && skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\r\n            }\r\n\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const numMorphInfluencers = mesh.morphTargetManager\r\n            ? PrepareDefinesAndAttributesForMorphTargets(\r\n                  mesh.morphTargetManager,\r\n                  defines,\r\n                  attribs,\r\n                  mesh,\r\n                  true, // usePositionMorph\r\n                  false, // useNormalMorph\r\n                  false, // useTangentMorph\r\n                  uv1, // useUVMorph\r\n                  uv2, // useUV2Morph\r\n                  color // useColorMorph\r\n              )\r\n            : 0;\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // ClipPlanes\r\n        PrepareStringDefinesForClipPlanes(material, this._scene, defines);\r\n\r\n        this._addCustomEffectDefines(defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines as string;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"viewProjection\",\r\n                \"glowColor\",\r\n                \"morphTargetInfluences\",\r\n                \"morphTargetCount\",\r\n                \"boneTextureWidth\",\r\n                \"diffuseMatrix\",\r\n                \"emissiveMatrix\",\r\n                \"opacityMatrix\",\r\n                \"opacityIntensity\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n                \"glowIntensity\",\r\n            ];\r\n\r\n            AddClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                this._engine.createEffect(\r\n                    \"glowMapGeneration\",\r\n                    attribs,\r\n                    uniforms,\r\n                    [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"],\r\n                    join,\r\n                    fallbacks,\r\n                    undefined,\r\n                    undefined,\r\n                    { maxSimultaneousMorphTargets: numMorphInfluencers },\r\n                    this._shaderLanguage,\r\n                    this._shadersLoaded\r\n                        ? undefined\r\n                        : async () => {\r\n                              await this._importShadersAsync();\r\n                              this._shadersLoaded = true;\r\n                          }\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        const effectIsReady = drawWrapper.effect!.isReady();\r\n\r\n        return effectIsReady && (this._dontCheckIfReady || (!this._dontCheckIfReady && this.isLayerReady()));\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSubMeshReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        return this._internalIsSubMeshReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    protected async _importShadersAsync(): Promise<void> {\r\n        if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n            await Promise.all([import(\"../ShadersWGSL/glowMapGeneration.vertex\"), import(\"../ShadersWGSL/glowMapGeneration.fragment\")]);\r\n        } else {\r\n            await Promise.all([import(\"../Shaders/glowMapGeneration.vertex\"), import(\"../Shaders/glowMapGeneration.fragment\")]);\r\n        }\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._additionalImportShadersAsync?.();\r\n    }\r\n\r\n    /** @internal */\r\n    public _internalIsLayerReady(): boolean {\r\n        let isReady = true;\r\n\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            isReady = this._postProcesses[i].isReady() && isReady;\r\n        }\r\n\r\n        const numDraws = this._numInternalDraws();\r\n\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            let currentEffect = this._mergeDrawWrapper[i];\r\n            if (!currentEffect) {\r\n                currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\r\n                currentEffect.setEffect(this._createMergeEffect());\r\n            }\r\n            isReady = currentEffect.effect!.isReady() && isReady;\r\n        }\r\n\r\n        return isReady;\r\n    }\r\n\r\n    /**\r\n     * Checks if the layer is ready to be used.\r\n     * @returns true if the layer is ready to be used\r\n     */\r\n    public isLayerReady(): boolean {\r\n        return this._internalIsLayerReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     * @returns true if the rendering was successful\r\n     */\r\n    public compose(): boolean {\r\n        if (!this._dontCheckIfReady && !this.isLayerReady()) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const numDraws = this._numInternalDraws();\r\n\r\n        this.onBeforeComposeObservable.notifyObservers(this);\r\n\r\n        const previousAlphaMode = engine.getAlphaMode();\r\n\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            const currentEffect = this._mergeDrawWrapper[i];\r\n\r\n            // Render\r\n            engine.enableEffect(currentEffect);\r\n            engine.setState(false);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect!);\r\n\r\n            // Go Blend.\r\n            engine.setAlphaMode(this._options.alphaBlendingMode);\r\n\r\n            // Blends the map on the main canvas.\r\n            this._internalCompose(currentEffect.effect!, i);\r\n        }\r\n\r\n        // Restore Alpha\r\n        engine.setAlphaMode(previousAlphaMode);\r\n\r\n        this.onAfterComposeObservable.notifyObservers(this);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _internalHasMesh(mesh: AbstractMesh): boolean {\r\n        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        return this._internalHasMesh(mesh);\r\n    }\r\n\r\n    /** @internal */\r\n    public _internalShouldRender(): boolean {\r\n        return this.isEnabled && this._shouldRender;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this._internalShouldRender();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRenderMesh(_mesh: AbstractMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _internalCanRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return !material.needAlphaBlendingForMesh(mesh);\r\n    }\r\n\r\n    /** @internal */\r\n    public _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return this._internalCanRenderMesh(mesh, material);\r\n    }\r\n\r\n    protected _renderSubMesh(subMesh: SubMesh, enableAlphaMode: boolean = false): void {\r\n        if (!this._internalShouldRender()) {\r\n            return;\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        const ownerMesh = subMesh.getMesh();\r\n        const replacementMesh = subMesh.getReplacementMesh();\r\n        const renderingMesh = subMesh.getRenderingMesh();\r\n        const effectiveMesh = subMesh.getEffectiveMesh();\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n        if (!material) {\r\n            return;\r\n        }\r\n\r\n        // Do not block in blend mode.\r\n        if (!this._canRenderMesh(renderingMesh, material)) {\r\n            return;\r\n        }\r\n\r\n        // Culling\r\n        let sideOrientation = material._getEffectiveOrientation(renderingMesh);\r\n        const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n        if (mainDeterminant < 0) {\r\n            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        }\r\n\r\n        const reverse = sideOrientation === Material.ClockWiseSideOrientation;\r\n        engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\r\n\r\n        // Managing instances\r\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\r\n        if (batch.mustReturn) {\r\n            return;\r\n        }\r\n\r\n        // Early Exit per mesh\r\n        if (!this._shouldRenderMesh(renderingMesh)) {\r\n            return;\r\n        }\r\n\r\n        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\r\n\r\n        if (this._useMeshMaterial(renderingMesh)) {\r\n            subMesh.getMaterial()!._glowModeEnabled = true;\r\n            renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || undefined);\r\n            subMesh.getMaterial()!._glowModeEnabled = false;\r\n        } else if (this._isSubMeshReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n            const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n            let drawWrapper = subMesh._getDrawWrapper();\r\n            if (!drawWrapper && renderingMaterial) {\r\n                drawWrapper = renderingMaterial._getDrawWrapper();\r\n            }\r\n\r\n            if (!drawWrapper) {\r\n                return;\r\n            }\r\n\r\n            const effect = drawWrapper.effect!;\r\n\r\n            engine.enableEffect(drawWrapper);\r\n            if (!hardwareInstancedRendering) {\r\n                renderingMesh._bind(subMesh, effect, material.fillMode);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                effect.setFloat4(\r\n                    \"glowColor\",\r\n                    this._emissiveTextureAndColor.color.r,\r\n                    this._emissiveTextureAndColor.color.g,\r\n                    this._emissiveTextureAndColor.color.b,\r\n                    this._emissiveTextureAndColor.color.a\r\n                );\r\n            } else {\r\n                renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                const needAlphaTest = material.needAlphaTestingForMesh(effectiveMesh);\r\n\r\n                const diffuseTexture = material.getAlphaTestTexture();\r\n                const needAlphaBlendFromDiffuse =\r\n                    diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n                if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                    effect.setTexture(\"diffuseSampler\", diffuseTexture);\r\n                    const textureMatrix = diffuseTexture.getTextureMatrix();\r\n\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"diffuseMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                const opacityTexture = (material as any).opacityTexture;\r\n                if (opacityTexture) {\r\n                    effect.setTexture(\"opacitySampler\", opacityTexture);\r\n                    effect.setFloat(\"opacityIntensity\", opacityTexture.level);\r\n                    const textureMatrix = opacityTexture.getTextureMatrix();\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"opacityMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                // Glow emissive only\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\r\n                    effect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\r\n                }\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    const skeleton = renderingMesh.skeleton;\r\n\r\n                    if (skeleton.isUsingTextureForMatrices) {\r\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                        if (!boneTexture) {\r\n                            return;\r\n                        }\r\n\r\n                        effect.setTexture(\"boneSampler\", boneTexture);\r\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                    } else {\r\n                        effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                // Morph targets\r\n                BindMorphTargetParameters(renderingMesh, effect);\r\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                    renderingMesh.morphTargetManager._bind(effect);\r\n                }\r\n\r\n                // Alpha mode\r\n                if (enableAlphaMode) {\r\n                    engine.setAlphaMode(material.alphaMode);\r\n                }\r\n\r\n                // Intensity of effect\r\n                effect.setFloat(\"glowIntensity\", this.getEffectIntensity(renderingMesh));\r\n\r\n                // Clip planes\r\n                BindClipPlane(effect, material, scene);\r\n            }\r\n\r\n            // Draw\r\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                effect.setMatrix(\"world\", world)\r\n            );\r\n        } else {\r\n            // Need to reset refresh rate of the main map\r\n            this._objectRenderer.resetRefreshCounter();\r\n        }\r\n\r\n        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\r\n    }\r\n\r\n    /** @internal */\r\n    public _useMeshMaterial(_mesh: AbstractMesh): boolean {\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._generateIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Dispose the effect layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        for (const drawWrapper of this._mergeDrawWrapper) {\r\n            drawWrapper.dispose();\r\n        }\r\n        this._mergeDrawWrapper = [];\r\n\r\n        this._objectRenderer.dispose();\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderLayerObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n    }\r\n}\r\n", "import { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { Color4 } from \"../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { GetExponentOfTwo } from \"../Misc/tools.functions\";\r\nimport type { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { ThinEffectLayer } from \"./thinEffectLayer\";\r\nimport { UniqueIdGenerator } from \"core/Misc/uniqueIdGenerator\";\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure effect stability across devices. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation. Default: ALPHA_COMBINE\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_BYTE\r\n     */\r\n    mainTextureType: number;\r\n\r\n    /**\r\n     * Whether or not to generate a stencil buffer. Default: false\r\n     */\r\n    generateStencilBuffer: boolean;\r\n}\r\n\r\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or highlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\r\nexport abstract class EffectLayer {\r\n    private _effectLayerOptions: IEffectLayerOptions;\r\n    protected _mainTextureCreatedSize: ISize = { width: 0, height: 0 };\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: AbstractEngine;\r\n    protected _maxSize: number = 0;\r\n    protected _mainTextureDesiredSize: ISize = { width: 0, height: 0 };\r\n    protected _mainTexture: RenderTargetTexture;\r\n    protected get _shouldRender() {\r\n        return this._thinEffectLayer._shouldRender;\r\n    }\r\n    protected set _shouldRender(value) {\r\n        this._thinEffectLayer._shouldRender = value;\r\n    }\r\n    protected _postProcesses: PostProcess[] = [];\r\n    protected _textures: BaseTexture[] = [];\r\n    protected get _emissiveTextureAndColor(): { texture: Nullable<BaseTexture>; color: Color4 } {\r\n        return this._thinEffectLayer._emissiveTextureAndColor;\r\n    }\r\n    protected set _emissiveTextureAndColor(value) {\r\n        this._thinEffectLayer._emissiveTextureAndColor = value;\r\n    }\r\n    protected get _effectIntensity(): { [meshUniqueId: number]: number } {\r\n        return this._thinEffectLayer._effectIntensity;\r\n    }\r\n    protected set _effectIntensity(value) {\r\n        this._thinEffectLayer._effectIntensity = value;\r\n    }\r\n    protected readonly _thinEffectLayer: ThinEffectLayer;\r\n    private readonly _internalThinEffectLayer: boolean;\r\n\r\n    /**\r\n     * Force all the effect layers to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static get ForceGLSL() {\r\n        return ThinEffectLayer.ForceGLSL;\r\n    }\r\n\r\n    public static set ForceGLSL(value: boolean) {\r\n        ThinEffectLayer.ForceGLSL = value;\r\n    }\r\n\r\n    /**\r\n     * The unique id of the layer\r\n     */\r\n    public readonly uniqueId = UniqueIdGenerator.UniqueId;\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    @serialize()\r\n    public get name() {\r\n        return this._thinEffectLayer.name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._thinEffectLayer.name = value;\r\n    }\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    @serializeAsColor4()\r\n    public get neutralColor(): Color4 {\r\n        return this._thinEffectLayer.neutralColor;\r\n    }\r\n\r\n    public set neutralColor(value: Color4) {\r\n        this._thinEffectLayer.neutralColor = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\r\n    @serialize()\r\n    public get isEnabled(): boolean {\r\n        return this._thinEffectLayer.isEnabled;\r\n    }\r\n\r\n    public set isEnabled(value: boolean) {\r\n        this._thinEffectLayer.isEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\r\n    @serializeAsCameraReference()\r\n    public get camera(): Nullable<Camera> {\r\n        return this._thinEffectLayer.camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    @serialize()\r\n    public get renderingGroupId(): number {\r\n        return this._thinEffectLayer.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._thinEffectLayer.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    @serialize()\r\n    public get disableBoundingBoxesFromEffectLayer() {\r\n        return this._thinEffectLayer.disableBoundingBoxesFromEffectLayer;\r\n    }\r\n\r\n    public set disableBoundingBoxesFromEffectLayer(value: boolean) {\r\n        this._thinEffectLayer.disableBoundingBoxesFromEffectLayer = value;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderMainTextureObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * Gets the main texture where the effect is rendered\r\n     */\r\n    public get mainTexture() {\r\n        return this._mainTexture;\r\n    }\r\n\r\n    protected get _shaderLanguage(): ShaderLanguage {\r\n        return this._thinEffectLayer.shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * Gets the shader language used in this material.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._thinEffectLayer.shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"EffectLayerSceneComponent\");\r\n    };\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in the layer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._thinEffectLayer.setMaterialForRendering(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to get the effect intensity for\r\n     * @returns The intensity of the effect for the mesh\r\n     */\r\n    public getEffectIntensity(mesh: AbstractMesh) {\r\n        return this._thinEffectLayer.getEffectIntensity(mesh);\r\n    }\r\n\r\n    /**\r\n     * Sets the intensity of the effect for a specific mesh.\r\n     * @param mesh The mesh to set the effect intensity for\r\n     * @param intensity The intensity of the effect for the mesh\r\n     */\r\n    public setEffectIntensity(mesh: AbstractMesh, intensity: number): void {\r\n        this._thinEffectLayer.setEffectIntensity(mesh, intensity);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer and references it in the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     * @param thinEffectLayer The thin instance of the effect layer (optional)\r\n     */\r\n    constructor(\r\n        /** The Friendly of the effect in the scene */\r\n        name: string,\r\n        scene?: Scene,\r\n        forceGLSL = false,\r\n        thinEffectLayer?: ThinEffectLayer\r\n    ) {\r\n        this._internalThinEffectLayer = !thinEffectLayer;\r\n        if (!thinEffectLayer) {\r\n            thinEffectLayer = new ThinEffectLayer(name, scene, forceGLSL, false, this._importShadersAsync.bind(this));\r\n            thinEffectLayer.getEffectName = this.getEffectName.bind(this);\r\n            thinEffectLayer.isReady = this.isReady.bind(this);\r\n            thinEffectLayer._createMergeEffect = this._createMergeEffect.bind(this);\r\n            thinEffectLayer._createTextureAndPostProcesses = this._createTextureAndPostProcesses.bind(this);\r\n            thinEffectLayer._internalCompose = this._internalRender.bind(this);\r\n            thinEffectLayer._setEmissiveTextureAndColor = this._setEmissiveTextureAndColor.bind(this);\r\n            thinEffectLayer._numInternalDraws = this._numInternalDraws.bind(this);\r\n            thinEffectLayer._addCustomEffectDefines = this._addCustomEffectDefines.bind(this);\r\n            thinEffectLayer.hasMesh = this.hasMesh.bind(this);\r\n            thinEffectLayer.shouldRender = this.shouldRender.bind(this);\r\n            thinEffectLayer._shouldRenderMesh = this._shouldRenderMesh.bind(this);\r\n            thinEffectLayer._canRenderMesh = this._canRenderMesh.bind(this);\r\n            thinEffectLayer._useMeshMaterial = this._useMeshMaterial.bind(this);\r\n        }\r\n\r\n        this._thinEffectLayer = thinEffectLayer;\r\n        this.name = name;\r\n\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        EffectLayer._SceneComponentInitialization(this._scene);\r\n\r\n        this._engine = this._scene.getEngine();\r\n        this._maxSize = this._engine.getCaps().maxTextureSize;\r\n        this._scene.addEffectLayer(this);\r\n\r\n        this._thinEffectLayer.onDisposeObservable.add(() => {\r\n            this.onDisposeObservable.notifyObservers(this);\r\n        });\r\n\r\n        this._thinEffectLayer.onBeforeRenderLayerObservable.add(() => {\r\n            this.onBeforeRenderMainTextureObservable.notifyObservers(this);\r\n        });\r\n\r\n        this._thinEffectLayer.onBeforeComposeObservable.add(() => {\r\n            this.onBeforeComposeObservable.notifyObservers(this);\r\n        });\r\n\r\n        this._thinEffectLayer.onBeforeRenderMeshToEffect.add((mesh) => {\r\n            this.onBeforeRenderMeshToEffect.notifyObservers(mesh);\r\n        });\r\n\r\n        this._thinEffectLayer.onAfterRenderMeshToEffect.add((mesh) => {\r\n            this.onAfterRenderMeshToEffect.notifyObservers(mesh);\r\n        });\r\n\r\n        this._thinEffectLayer.onAfterComposeObservable.add(() => {\r\n            this.onAfterComposeObservable.notifyObservers(this);\r\n        });\r\n    }\r\n\r\n    protected get _shadersLoaded() {\r\n        return this._thinEffectLayer._shadersLoaded;\r\n    }\r\n\r\n    protected set _shadersLoaded(value: boolean) {\r\n        this._thinEffectLayer._shadersLoaded = value;\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public abstract getEffectName(): string;\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public abstract needStencil(): boolean;\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect containing the shader used to merge the effect on the  main canvas\r\n     */\r\n    protected abstract _createMergeEffect(): Effect;\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the effect layer.\r\n     */\r\n    protected abstract _createTextureAndPostProcesses(): void;\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderNum Index of the _internalRender call (0 for the first time _internalRender is called, 1 for the second time, etc. _internalRender is called the number of times returned by _numInternalDraws())\r\n     */\r\n    protected abstract _internalRender(effect: Effect, renderIndex: number): void;\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     */\r\n    public abstract _disposeMesh(mesh: Mesh): void;\r\n\r\n    /**\r\n     * Serializes this layer (Glow or Highlight for example)\r\n     * @returns a serialized layer object\r\n     */\r\n    public abstract serialize?(): any;\r\n\r\n    /**\r\n     * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\r\n     * @returns Number of times a mesh must be rendered in the layer\r\n     */\r\n    protected _numInternalDraws(): number {\r\n        return this._internalThinEffectLayer ? 1 : this._thinEffectLayer._numInternalDraws();\r\n    }\r\n\r\n    /**\r\n     * Initializes the effect layer with the required options.\r\n     * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n     */\r\n    protected _init(options: Partial<IEffectLayerOptions>): void {\r\n        // Adapt options\r\n        this._effectLayerOptions = {\r\n            mainTextureRatio: 0.5,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            generateStencilBuffer: false,\r\n            ...options,\r\n        };\r\n\r\n        this._setMainTextureSize();\r\n        this._thinEffectLayer._init(options);\r\n        this._createMainTexture();\r\n        this._createTextureAndPostProcesses();\r\n    }\r\n\r\n    /**\r\n     * Sets the main texture desired size which is the closest power of two\r\n     * of the engine canvas size.\r\n     */\r\n    private _setMainTextureSize(): void {\r\n        if (this._effectLayerOptions.mainTextureFixedSize) {\r\n            this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\r\n            this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\r\n        } else {\r\n            this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\r\n            this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\r\n\r\n            this._mainTextureDesiredSize.width = this._engine.needPOTTextures\r\n                ? GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize)\r\n                : this._mainTextureDesiredSize.width;\r\n            this._mainTextureDesiredSize.height = this._engine.needPOTTextures\r\n                ? GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize)\r\n                : this._mainTextureDesiredSize.height;\r\n        }\r\n\r\n        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\r\n        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\r\n    }\r\n\r\n    /**\r\n     * Creates the main texture for the effect layer.\r\n     */\r\n    protected _createMainTexture(): void {\r\n        this._mainTexture = new RenderTargetTexture(\r\n            \"EffectLayerMainRTT\",\r\n            {\r\n                width: this._mainTextureDesiredSize.width,\r\n                height: this._mainTextureDesiredSize.height,\r\n            },\r\n            this._scene,\r\n            {\r\n                type: this._effectLayerOptions.mainTextureType,\r\n                samplingMode: Texture.TRILINEAR_SAMPLINGMODE,\r\n                generateStencilBuffer: this._effectLayerOptions.generateStencilBuffer,\r\n                existingObjectRenderer: this._thinEffectLayer.objectRenderer,\r\n            }\r\n        );\r\n        this._mainTexture.activeCamera = this._effectLayerOptions.camera;\r\n        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.anisotropicFilteringLevel = 1;\r\n        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._mainTexture.renderParticles = false;\r\n        this._mainTexture.renderList = null;\r\n        this._mainTexture.ignoreCameraViewport = true;\r\n\r\n        this._mainTexture.onClearObservable.add((engine: AbstractEngine) => {\r\n            engine.clear(this.neutralColor, true, true, true);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        // Nothing to add by default.\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        return this._internalThinEffectLayer\r\n            ? this._thinEffectLayer._internalIsSubMeshReady(subMesh, useInstances, emissiveTexture)\r\n            : this._thinEffectLayer._isSubMeshReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    protected async _importShadersAsync(): Promise<void> {}\r\n\r\n    protected _arePostProcessAndMergeReady(): boolean {\r\n        return this._internalThinEffectLayer ? this._thinEffectLayer._internalIsLayerReady() : this._thinEffectLayer.isLayerReady();\r\n    }\r\n\r\n    /**\r\n     * Checks if the layer is ready to be used.\r\n     * @returns true if the layer is ready to be used\r\n     */\r\n    public isLayerReady(): boolean {\r\n        return this._arePostProcessAndMergeReady() && this._mainTexture.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     */\r\n    public render(): void {\r\n        if (!this._thinEffectLayer.compose()) {\r\n            return;\r\n        }\r\n\r\n        // Handle size changes.\r\n        this._setMainTextureSize();\r\n        if (\r\n            (this._mainTextureCreatedSize.width !== this._mainTextureDesiredSize.width || this._mainTextureCreatedSize.height !== this._mainTextureDesiredSize.height) &&\r\n            this._mainTextureDesiredSize.width !== 0 &&\r\n            this._mainTextureDesiredSize.height !== 0\r\n        ) {\r\n            // Recreate RTT and post processes on size change.\r\n            this.onSizeChangedObservable.notifyObservers(this);\r\n            this._disposeTextureAndPostProcesses();\r\n            this._createMainTexture();\r\n            this._createTextureAndPostProcesses();\r\n            this._mainTextureCreatedSize.width = this._mainTextureDesiredSize.width;\r\n            this._mainTextureCreatedSize.height = this._mainTextureDesiredSize.height;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        return this._internalThinEffectLayer ? this._thinEffectLayer._internalHasMesh(mesh) : this._thinEffectLayer.hasMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this._internalThinEffectLayer ? this._thinEffectLayer._internalShouldRender() : this._thinEffectLayer.shouldRender();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _shouldRenderMesh(mesh: AbstractMesh): boolean {\r\n        return this._internalThinEffectLayer ? true : this._thinEffectLayer._shouldRenderMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return this._internalThinEffectLayer ? this._thinEffectLayer._internalCanRenderMesh(mesh, material) : this._thinEffectLayer._canRenderMesh(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderEmissiveTextureForMesh(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     * @returns true if the mesh material should be use\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return this._internalThinEffectLayer ? false : this._thinEffectLayer._useMeshMaterial(mesh);\r\n    }\r\n\r\n    /**\r\n     * Rebuild the required buffers.\r\n     * @internal Internal use only.\r\n     */\r\n    public _rebuild(): void {\r\n        this._thinEffectLayer._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Dispose only the render target textures and post process.\r\n     */\r\n    private _disposeTextureAndPostProcesses(): void {\r\n        this._mainTexture.dispose();\r\n\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (this._postProcesses[i]) {\r\n                this._postProcesses[i].dispose();\r\n            }\r\n        }\r\n        this._postProcesses = [];\r\n\r\n        for (let i = 0; i < this._textures.length; i++) {\r\n            if (this._textures[i]) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        this._thinEffectLayer.dispose();\r\n\r\n        // Clean textures and post processes\r\n        this._disposeTextureAndPostProcesses();\r\n\r\n        // Remove from scene\r\n        this._scene.removeEffectLayer(this);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderMainTextureObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"EffectLayer\";\r\n    }\r\n\r\n    /**\r\n     * Creates an effect layer from parsed effect layer data\r\n     * @param parsedEffectLayer defines effect layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the effect layer information\r\n     * @returns a parsed effect Layer\r\n     */\r\n    public static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer {\r\n        const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["engine"]
}
