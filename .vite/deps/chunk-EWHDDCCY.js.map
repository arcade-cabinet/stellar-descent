{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/Materials/floatingOriginMatrixOverrides.ts"],
  "sourcesContent": ["import { Effect } from \"../Materials/effect\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { IMatrixLike, IVector3Like } from \"../Maths/math.like\";\r\nimport { InvertMatrixToRef, MultiplyMatricesToRef } from \"../Maths/ThinMaths/thinMath.matrix.functions\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { DeepImmutable } from \"../types\";\r\nimport { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\nconst TempFinalMat: Matrix = new Matrix();\r\nconst TempMat1: Matrix = new Matrix();\r\nconst TempMat2: Matrix = new Matrix();\r\n\r\n/**\r\n * When rendering, each scene will reset this to ensure the correct floating origin offset is when overriding the below functions\r\n */\r\nexport const FloatingOriginCurrentScene = {\r\n    getScene: () => undefined as Scene | undefined,\r\n    eyeAtCamera: true, // When true, we can assume viewMatrix translation is at origin. Otherwise, we must do full offset calculations\r\n};\r\n\r\nfunction OffsetWorldToRef(offset: IVector3Like, world: DeepImmutable<IMatrixLike>, ref: Matrix): DeepImmutable<IMatrixLike> {\r\n    const refArray = ref.asArray();\r\n    const worldArray = world.asArray();\r\n    for (let i = 0; i < 16; i++) {\r\n        refArray[i] = worldArray[i];\r\n    }\r\n    refArray[12] -= offset.x;\r\n    refArray[13] -= offset.y;\r\n    refArray[14] -= offset.z;\r\n    ref.markAsUpdated();\r\n    return ref;\r\n}\r\n\r\nfunction GetFullOffsetView(offset: IVector3Like, viewMatrix: DeepImmutable<IMatrixLike>, ref: IMatrixLike) {\r\n    InvertMatrixToRef(viewMatrix, TempMat1); // TempMat1 = light world matrix (inverse of view)\r\n    OffsetWorldToRef(offset, TempMat1, TempMat2); // TempMat2 = offset light world matrix\r\n    InvertMatrixToRef(TempMat2, ref); // TempMat1 = offset view matrix\r\n    return ref;\r\n}\r\n\r\nexport function OffsetViewToRef(offset: IVector3Like, view: DeepImmutable<IMatrixLike>, ref: Matrix): DeepImmutable<IMatrixLike> {\r\n    // When eye is not at camera, we cannot assume the translation of view matrix is at origin, so we perform full offset calculation\r\n    if (!FloatingOriginCurrentScene.eyeAtCamera) {\r\n        return GetFullOffsetView(offset, view, ref);\r\n    }\r\n    const refArray = ref.asArray();\r\n    const viewArray = view.asArray();\r\n    for (let i = 0; i < 16; i++) {\r\n        refArray[i] = viewArray[i];\r\n    }\r\n    refArray[12] = 0;\r\n    refArray[13] = 0;\r\n    refArray[14] = 0;\r\n    ref.markAsUpdated();\r\n    return ref;\r\n}\r\n\r\nfunction OffsetViewProjectionToRef(offset: IVector3Like, view: DeepImmutable<IMatrixLike>, projection: DeepImmutable<IMatrixLike>, ref: Matrix): DeepImmutable<IMatrixLike> {\r\n    MultiplyMatricesToRef(OffsetViewToRef(offset, view, ref), projection, ref);\r\n    return ref;\r\n}\r\n\r\nexport function OffsetClipPlaneToRef(offset: Vector3, plane: Plane, ref: Plane): Plane {\r\n    // Original clipplane is using equation normal.dot(p) + d = 0\r\n    // Assume we have p' = p - offset, that means normal.dot(p') + d' = 0\r\n    // So to get the offset plane,\r\n    // normal.dot(p' + offset) + d = 0\r\n    // normal.dot(p') + normal.dot(offset) + d = 0\r\n    // -d' + normal.dot(offset) + d = 0\r\n    // d' = d + normal.dot(offset)\r\n    ref.normal.copyFrom(plane.normal);\r\n    ref.d = plane.d + Vector3.Dot(plane.normal, offset);\r\n    return ref;\r\n}\r\n\r\nexport function GetOffsetTransformMatrices(\r\n    offset: IVector3Like,\r\n    viewMatrices: Array<Matrix>,\r\n    projectionMatrices: Array<Matrix>,\r\n    length: number,\r\n    resultArray: Float32Array\r\n): Float32Array {\r\n    for (let cascadeIndex = 0; cascadeIndex < length; ++cascadeIndex) {\r\n        GetFullOffsetViewProjectionToRef(offset, viewMatrices[cascadeIndex], projectionMatrices[cascadeIndex], TempMat1);\r\n        TempMat1.copyToArray(resultArray, cascadeIndex * 16);\r\n    }\r\n    return resultArray;\r\n}\r\n\r\nfunction OffsetWorldViewToRef(offset: IVector3Like, worldView: DeepImmutable<IMatrixLike>, view: DeepImmutable<IMatrixLike>, ref: Matrix): DeepImmutable<IMatrixLike> {\r\n    // ( world * view ) * inverse ( view ) = world\r\n    InvertMatrixToRef(view, TempMat1); // TempMat1 = inverseView\r\n    MultiplyMatricesToRef(worldView, TempMat1, TempMat2); // TempMat2 = world, TempMat1 can be reused\r\n\r\n    // ( offsetWorld * offsetView ) = offsetWorldView\r\n    OffsetWorldToRef(offset, TempMat2, TempMat1); // TempMat1 = offsetWorld\r\n    OffsetViewToRef(offset, view, TempMat2); // TempMat2 = offsetView\r\n    MultiplyMatricesToRef(TempMat1, TempMat2, ref);\r\n\r\n    return ref;\r\n}\r\n\r\nexport function GetFullOffsetViewProjectionToRef(\r\n    offset: IVector3Like,\r\n    viewMatrix: DeepImmutable<IMatrixLike>,\r\n    projectionMatrix: DeepImmutable<IMatrixLike>,\r\n    ref: IMatrixLike\r\n): DeepImmutable<IMatrixLike> {\r\n    GetFullOffsetView(offset, viewMatrix, TempMat2);\r\n    MultiplyMatricesToRef(TempMat2, projectionMatrix, ref);\r\n    return ref;\r\n}\r\n\r\nfunction OffsetWorldViewProjectionToRef(\r\n    offset: IVector3Like,\r\n    worldViewProjection: DeepImmutable<IMatrixLike>,\r\n    viewProjection: DeepImmutable<IMatrixLike>,\r\n    view: DeepImmutable<IMatrixLike>,\r\n    projection: DeepImmutable<IMatrixLike>,\r\n    ref: IMatrixLike\r\n): DeepImmutable<IMatrixLike> {\r\n    // ( world * view * projection ) * inverse(projection) * inverse(view) = world\r\n    // ( world * view * projection ) * inverse (view * projection) = world\r\n    InvertMatrixToRef(viewProjection, TempMat1); // TempMat1 = inverse (view * projection)\r\n    MultiplyMatricesToRef(worldViewProjection, TempMat1, TempMat2); // TempMat2 = world, TempMat1 can be reused\r\n\r\n    // ( offsetWorld * offsetViewProjection)  = offsetWorldViewProjection\r\n    OffsetWorldToRef(offset, TempMat2, TempMat1); // TempMat1 = offsetWorld\r\n    OffsetViewProjectionToRef(offset, view, projection, TempMat2); // TempMat2 = offsetViewProjection\r\n    MultiplyMatricesToRef(TempMat1, TempMat2, ref);\r\n\r\n    return ref;\r\n}\r\n\r\nfunction GetOffsetMatrix(uniformName: string, mat: IMatrixLike): IMatrixLike {\r\n    const scene = FloatingOriginCurrentScene.getScene();\r\n    // Early out for scenes that don't have floatingOriginMode enabled\r\n    // Effect.setMatrix will call pipelineContext.setMatrix. In WebGPU, this will in turn call ubo.updateMatrix. To avoid double offset, early out if mat is TempFinalMat\r\n    if (!scene || TempFinalMat === mat) {\r\n        return mat;\r\n    }\r\n    TempFinalMat.updateFlag = mat.updateFlag;\r\n    const offset = scene.floatingOriginOffset;\r\n    switch (uniformName) {\r\n        case \"world\":\r\n            return OffsetWorldToRef(offset, mat, TempFinalMat);\r\n        case \"view\":\r\n            return OffsetViewToRef(offset, mat, TempFinalMat);\r\n        case \"worldView\":\r\n            return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);\r\n        case \"viewProjection\":\r\n            return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);\r\n        case \"worldViewProjection\":\r\n            return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);\r\n        default:\r\n            // Node material blocks uniforms are formatted u_BlockName, with trailing numbers if there are multiple blocks of the same name\r\n            // Check u_ first so that we can early out for non-node material uniforms\r\n            if (uniformName.startsWith(\"u_\")) {\r\n                const lowercaseUniformName = uniformName.toLowerCase();\r\n                if (lowercaseUniformName.startsWith(\"u_worldviewprojection\")) {\r\n                    return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);\r\n                }\r\n                if (lowercaseUniformName.startsWith(\"u_viewprojection\")) {\r\n                    return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);\r\n                }\r\n                if (lowercaseUniformName.startsWith(\"u_worldview\")) {\r\n                    return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);\r\n                }\r\n                if (lowercaseUniformName.startsWith(\"u_world\")) {\r\n                    return OffsetWorldToRef(offset, mat, TempFinalMat);\r\n                }\r\n                if (lowercaseUniformName.startsWith(\"u_view\")) {\r\n                    return OffsetViewToRef(offset, mat, TempFinalMat);\r\n                }\r\n            }\r\n            return mat;\r\n    }\r\n}\r\n\r\n// ---- Overriding the prototypes of effect and uniformBuffer's setMatrix functions ----\r\nconst UniformBufferInternal = UniformBuffer as any;\r\nconst EffectInternal = Effect as any;\r\nconst OriginalUpdateMatrixForUniform = UniformBufferInternal.prototype._updateMatrixForUniform;\r\nconst OriginalSetMatrix = Effect.prototype.setMatrix;\r\n\r\nexport function ResetMatrixFunctions() {\r\n    Effect.prototype.setMatrix = OriginalSetMatrix;\r\n    EffectInternal._setMatrixOverride = undefined;\r\n    UniformBufferInternal.prototype._updateMatrixForUniform = OriginalUpdateMatrixForUniform;\r\n    UniformBufferInternal.prototype._updateMatrixForUniformOverride = undefined;\r\n}\r\n\r\nexport function OverrideMatrixFunctions() {\r\n    EffectInternal.prototype._setMatrixOverride = OriginalSetMatrix;\r\n    EffectInternal.prototype.setMatrix = function (uniformName: string, matrix: IMatrixLike) {\r\n        this._setMatrixOverride(uniformName, GetOffsetMatrix(uniformName, matrix));\r\n        return this;\r\n    };\r\n    UniformBufferInternal.prototype._updateMatrixForUniformOverride = OriginalUpdateMatrixForUniform;\r\n    UniformBufferInternal.prototype._updateMatrixForUniform = function (uniformName: string, matrix: IMatrixLike) {\r\n        this._updateMatrixForUniformOverride(uniformName, GetOffsetMatrix(uniformName, matrix));\r\n    };\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
