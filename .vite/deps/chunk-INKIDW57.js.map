{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/thinBlurPostProcess.ts", "../../node_modules/.pnpm/@babylonjs+core@8.49.1/dev/core/src/PostProcesses/blurPostProcess.ts"],
  "sourcesContent": ["import type { Nullable, AbstractEngine, EffectWrapperCreationOptions, Vector2, Effect } from \"core/index\";\r\nimport { EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Post process used to apply a blur effect\r\n */\r\nexport class ThinBlurPostProcess extends EffectWrapper {\r\n    /**\r\n     * The vertex shader url\r\n     */\r\n    public static readonly VertexUrl = \"kernelBlur\";\r\n\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"kernelBlur\";\r\n\r\n    /**\r\n     * The list of uniforms used by the effect\r\n     */\r\n    public static readonly Uniforms = [\"delta\", \"direction\"];\r\n\r\n    /**\r\n     * The list of samplers used by the effect\r\n     */\r\n    public static readonly Samplers = [\"circleOfConfusionSampler\"];\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/kernelBlur.fragment\"), import(\"../ShadersWGSL/kernelBlur.vertex\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/kernelBlur.fragment\"), import(\"../Shaders/kernelBlur.vertex\")]));\r\n        }\r\n    }\r\n\r\n    protected _kernel: number;\r\n    protected _idealKernel: number;\r\n    protected _packedFloat: boolean = false;\r\n    private _staticDefines: string = \"\";\r\n\r\n    /**\r\n     * Constructs a new blur post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param direction Direction in which to apply the blur\r\n     * @param kernel Kernel size of the blur\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, direction?: Vector2, kernel?: number, options?: EffectWrapperCreationOptions) {\r\n        const blockCompilationFinal = !!options?.blockCompilation;\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinBlurPostProcess.FragmentUrl,\r\n            uniforms: ThinBlurPostProcess.Uniforms,\r\n            samplers: ThinBlurPostProcess.Samplers,\r\n            vertexUrl: ThinBlurPostProcess.VertexUrl,\r\n            blockCompilation: true,\r\n        });\r\n\r\n        this._staticDefines = options ? (Array.isArray(options.defines) ? options.defines.join(\"\\n\") : options.defines || \"\") : \"\";\r\n\r\n        this.options.blockCompilation = blockCompilationFinal;\r\n\r\n        if (direction !== undefined) {\r\n            this.direction = direction;\r\n        }\r\n        if (kernel !== undefined) {\r\n            this.kernel = kernel;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Width of the texture to apply the blur on\r\n     */\r\n    public textureWidth: number = 0;\r\n\r\n    /**\r\n     * Height of the texture to apply the blur on\r\n     */\r\n    public textureHeight: number = 0;\r\n\r\n    /** The direction in which to blur the image. */\r\n    public direction: Vector2;\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    public set kernel(v: number) {\r\n        if (this._idealKernel === v) {\r\n            return;\r\n        }\r\n\r\n        v = Math.max(v, 1);\r\n        this._idealKernel = v;\r\n        this._kernel = this._nearestBestKernel(v);\r\n        if (!this.options.blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._idealKernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    public set packedFloat(v: boolean) {\r\n        if (this._packedFloat === v) {\r\n            return;\r\n        }\r\n        this._packedFloat = v;\r\n        if (!this.options.blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._packedFloat;\r\n    }\r\n\r\n    public override bind(noDefaultBindings = false) {\r\n        super.bind(noDefaultBindings);\r\n        this._drawWrapper.effect!.setFloat2(\"delta\", (1 / this.textureWidth) * this.direction.x, (1 / this.textureHeight) * this.direction.y);\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateParameters(onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void {\r\n        // Generate sampling offsets and weights\r\n        const n = this._kernel;\r\n        const centerIndex = (n - 1) / 2;\r\n\r\n        // Generate Gaussian sampling weights over kernel\r\n        let offsets = [];\r\n        let weights = [];\r\n        let totalWeight = 0;\r\n        for (let i = 0; i < n; i++) {\r\n            const u = i / (n - 1);\r\n            const w = this._gaussianWeight(u * 2.0 - 1);\r\n            offsets[i] = i - centerIndex;\r\n            weights[i] = w;\r\n            totalWeight += w;\r\n        }\r\n\r\n        // Normalize weights\r\n        for (let i = 0; i < weights.length; i++) {\r\n            weights[i] /= totalWeight;\r\n        }\r\n\r\n        // Optimize: combine samples to take advantage of hardware linear sampling\r\n        // Walk from left to center, combining pairs (symmetrically)\r\n        const linearSamplingWeights = [];\r\n        const linearSamplingOffsets = [];\r\n\r\n        const linearSamplingMap = [];\r\n\r\n        for (let i = 0; i <= centerIndex; i += 2) {\r\n            const j = Math.min(i + 1, Math.floor(centerIndex));\r\n\r\n            const singleCenterSample = i === j;\r\n\r\n            if (singleCenterSample) {\r\n                linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n            } else {\r\n                const sharedCell = j === centerIndex;\r\n\r\n                const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\r\n                const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\r\n\r\n                if (offsetLinear === 0) {\r\n                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n                    linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });\r\n                } else {\r\n                    linearSamplingMap.push({ o: offsetLinear, w: weightLinear });\r\n                    linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < linearSamplingMap.length; i++) {\r\n            linearSamplingOffsets[i] = linearSamplingMap[i].o;\r\n            linearSamplingWeights[i] = linearSamplingMap[i].w;\r\n        }\r\n\r\n        // Replace with optimized\r\n        offsets = linearSamplingOffsets;\r\n        weights = linearSamplingWeights;\r\n\r\n        // Generate shaders\r\n        const maxVaryingRows = this.options.engine.getCaps().maxVaryingVectors - (this.options.shaderLanguage === ShaderLanguage.WGSL ? 1 : 0); // Because of the additional builtins\r\n        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\r\n\r\n        let varyingCount = Math.min(offsets.length, freeVaryingVec2);\r\n\r\n        let defines = \"\";\r\n        defines += this._staticDefines;\r\n\r\n        // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\r\n        if (this._staticDefines.indexOf(\"DOF\") != -1) {\r\n            defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\n`;\r\n            varyingCount--;\r\n        }\r\n\r\n        for (let i = 0; i < varyingCount; i++) {\r\n            defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\n`;\r\n        }\r\n\r\n        let depCount = 0;\r\n        for (let i = freeVaryingVec2; i < offsets.length; i++) {\r\n            defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\n`;\r\n            defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\n`;\r\n            depCount++;\r\n        }\r\n\r\n        if (this.packedFloat) {\r\n            defines += `#define PACKEDFLOAT 1`;\r\n        }\r\n\r\n        this.options.blockCompilation = false;\r\n\r\n        this.updateEffect(\r\n            defines,\r\n            null,\r\n            null,\r\n            {\r\n                varyingCount: varyingCount,\r\n                depCount: depCount,\r\n            },\r\n            onCompiled,\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\r\n     * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\r\n     * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\r\n     * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\r\n     * The gaps between physical kernels are compensated for in the weighting of the samples\r\n     * @param idealKernel Ideal blur kernel.\r\n     * @returns Nearest best kernel.\r\n     */\r\n    protected _nearestBestKernel(idealKernel: number): number {\r\n        const v = Math.round(idealKernel);\r\n        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\r\n            if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\r\n                return Math.max(k, 3);\r\n            }\r\n        }\r\n        return Math.max(v, 3);\r\n    }\r\n\r\n    /**\r\n     * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\r\n     * @param x The point on the Gaussian distribution to sample.\r\n     * @returns the value of the Gaussian function at x.\r\n     */\r\n    protected _gaussianWeight(x: number): number {\r\n        //reference: Engines/ImageProcessingBlur.cpp #dcc760\r\n        // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\r\n        // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\r\n        // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\r\n        // truncated at around 1.3% of peak strength.\r\n\r\n        //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\r\n        const sigma = 1 / 3;\r\n        const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\r\n        const exponent = -((x * x) / (2.0 * sigma * sigma));\r\n        const weight = (1.0 / denominator) * Math.exp(exponent);\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n     * Generates a string that can be used as a floating point number in GLSL.\r\n     * @param x Value to print.\r\n     * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\r\n     * @returns GLSL float string.\r\n     */\r\n    protected _glslFloat(x: number, decimalFigures = 8) {\r\n        return x.toFixed(decimalFigures).replace(/0+$/, \"\");\r\n    }\r\n}\r\n", "import type { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize, serializeAsVector2 } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { ThinBlurPostProcess } from \"./thinBlurPostProcess\";\r\n\r\n/**\r\n * The Blur Post Process which blurs an image based on a kernel and direction.\r\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\r\n */\r\nexport class BlurPostProcess extends PostProcess {\r\n    /** The direction in which to blur the image. */\r\n    @serializeAsVector2()\r\n    public get direction() {\r\n        return this._effectWrapper.direction;\r\n    }\r\n\r\n    public set direction(value: Vector2) {\r\n        this._effectWrapper.direction = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    @serialize()\r\n    public set kernel(v: number) {\r\n        this._effectWrapper.kernel = v;\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._effectWrapper.kernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    @serialize()\r\n    public set packedFloat(v: boolean) {\r\n        this._effectWrapper.packedFloat = v;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._effectWrapper.packedFloat;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"BlurPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"BlurPostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinBlurPostProcess;\r\n\r\n    /**\r\n     * Creates a new instance BlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param direction The direction in which to blur the image.\r\n     * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param defines\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        direction: Vector2,\r\n        kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        defines = \"\",\r\n        blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        const blockCompilationFinal = typeof options === \"number\" ? blockCompilation : !!options.blockCompilation;\r\n        const localOptions = {\r\n            uniforms: ThinBlurPostProcess.Uniforms,\r\n            samplers: ThinBlurPostProcess.Samplers,\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            vertexUrl: ThinBlurPostProcess.VertexUrl,\r\n            indexParameters: { varyingCount: 0, depCount: 0 },\r\n            textureFormat,\r\n            defines,\r\n            ...(options as PostProcessOptions),\r\n            blockCompilation: true,\r\n        };\r\n\r\n        super(name, ThinBlurPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinBlurPostProcess(name, engine, undefined, undefined, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n\r\n        this._effectWrapper.options.blockCompilation = blockCompilationFinal;\r\n\r\n        this.direction = direction;\r\n        this.onApplyObservable.add(() => {\r\n            this._effectWrapper.textureWidth = this._outputTexture ? this._outputTexture.width : this.width;\r\n            this._effectWrapper.textureHeight = this._outputTexture ? this._outputTexture.height : this.height;\r\n        });\r\n\r\n        this.kernel = kernel;\r\n    }\r\n\r\n    public override updateEffect(\r\n        _defines: Nullable<string> = null,\r\n        _uniforms: Nullable<string[]> = null,\r\n        _samplers: Nullable<string[]> = null,\r\n        _indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void\r\n    ) {\r\n        this._effectWrapper._updateParameters(onCompiled, onError);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<BlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new BlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.direction,\r\n                    parsedPostProcess.kernel,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    undefined,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;AAQM,IAAO,sBAAP,MAAO,6BAA4B,cAAa;EAqB/B,eAAe,WAAoB,MAAoB;AACtE,QAAI,WAAW;AACX,WAAK,eAAe;AACpB,WAAK,KAAK,QAAQ,IAAI,CAAC,OAAO,mCAAuC,GAAA,OAAO,iCAAuC,CAAA,CAAA,CAAA;IACvH,OAAO;AACH,WAAK,KAAK,QAAQ,IAAI,CAAC,OAAO,mCAAmC,GAAA,OAAO,iCAAmC,CAAA,CAAA,CAAA;IAC/G;EACJ;;;;;;;;;EAeA,YAAY,MAAc,SAAmC,MAAM,WAAqB,QAAiB,SAAsC;AAC3I,UAAM,wBAAwB,CAAC,CAAC,SAAS;AACzC,UAAM;MACF,GAAG;MACH;MACA,QAAQ,UAAU,OAAO;MACzB,gBAAgB;MAChB,kBAAkB;MAClB,gBAAgB,qBAAoB;MACpC,UAAU,qBAAoB;MAC9B,UAAU,qBAAoB;MAC9B,WAAW,qBAAoB;MAC/B,kBAAkB;KACrB;AAxBK,SAAA,eAAwB;AAC1B,SAAA,iBAAyB;AAwC1B,SAAA,eAAuB;AAKvB,SAAA,gBAAwB;AApB3B,SAAK,iBAAiB,UAAW,MAAM,QAAQ,QAAQ,OAAO,IAAI,QAAQ,QAAQ,KAAK,IAAI,IAAI,QAAQ,WAAW,KAAM;AAExH,SAAK,QAAQ,mBAAmB;AAEhC,QAAI,cAAc,QAAW;AACzB,WAAK,YAAY;IACrB;AACA,QAAI,WAAW,QAAW;AACtB,WAAK,SAAS;IAClB;EACJ;;;;EAkBA,IAAW,OAAO,GAAS;AACvB,QAAI,KAAK,iBAAiB,GAAG;AACzB;IACJ;AAEA,QAAI,KAAK,IAAI,GAAG,CAAC;AACjB,SAAK,eAAe;AACpB,SAAK,UAAU,KAAK,mBAAmB,CAAC;AACxC,QAAI,CAAC,KAAK,QAAQ,kBAAkB;AAChC,WAAK,kBAAiB;IAC1B;EACJ;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK;EAChB;;;;EAKA,IAAW,YAAY,GAAU;AAC7B,QAAI,KAAK,iBAAiB,GAAG;AACzB;IACJ;AACA,SAAK,eAAe;AACpB,QAAI,CAAC,KAAK,QAAQ,kBAAkB;AAChC,WAAK,kBAAiB;IAC1B;EACJ;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK;EAChB;EAEgB,KAAK,oBAAoB,OAAK;AAC1C,UAAM,KAAK,iBAAiB;AAC5B,SAAK,aAAa,OAAQ,UAAU,SAAU,IAAI,KAAK,eAAgB,KAAK,UAAU,GAAI,IAAI,KAAK,gBAAiB,KAAK,UAAU,CAAC;EACxI;;EAGO,kBAAkB,YAAuC,SAAkD;AAE9G,UAAM,IAAI,KAAK;AACf,UAAM,eAAe,IAAI,KAAK;AAG9B,QAAI,UAAU,CAAA;AACd,QAAI,UAAU,CAAA;AACd,QAAI,cAAc;AAClB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,YAAM,IAAI,KAAK,IAAI;AACnB,YAAM,IAAI,KAAK,gBAAgB,IAAI,IAAM,CAAC;AAC1C,cAAQ,CAAC,IAAI,IAAI;AACjB,cAAQ,CAAC,IAAI;AACb,qBAAe;IACnB;AAGA,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,cAAQ,CAAC,KAAK;IAClB;AAIA,UAAM,wBAAwB,CAAA;AAC9B,UAAM,wBAAwB,CAAA;AAE9B,UAAM,oBAAoB,CAAA;AAE1B,aAAS,IAAI,GAAG,KAAK,aAAa,KAAK,GAAG;AACtC,YAAM,IAAI,KAAK,IAAI,IAAI,GAAG,KAAK,MAAM,WAAW,CAAC;AAEjD,YAAM,qBAAqB,MAAM;AAEjC,UAAI,oBAAoB;AACpB,0BAAkB,KAAK,EAAE,GAAG,QAAQ,CAAC,GAAG,GAAG,QAAQ,CAAC,EAAC,CAAE;MAC3D,OAAO;AACH,cAAM,aAAa,MAAM;AAEzB,cAAM,eAAe,QAAQ,CAAC,IAAI,QAAQ,CAAC,KAAK,aAAa,MAAM;AACnE,cAAM,eAAe,QAAQ,CAAC,IAAI,KAAK,IAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC;AAEjE,YAAI,iBAAiB,GAAG;AACpB,4BAAkB,KAAK,EAAE,GAAG,QAAQ,CAAC,GAAG,GAAG,QAAQ,CAAC,EAAC,CAAE;AACvD,4BAAkB,KAAK,EAAE,GAAG,QAAQ,IAAI,CAAC,GAAG,GAAG,QAAQ,IAAI,CAAC,EAAC,CAAE;QACnE,OAAO;AACH,4BAAkB,KAAK,EAAE,GAAG,cAAc,GAAG,aAAY,CAAE;AAC3D,4BAAkB,KAAK,EAAE,GAAG,CAAC,cAAc,GAAG,aAAY,CAAE;QAChE;MACJ;IACJ;AAEA,aAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,KAAK;AAC/C,4BAAsB,CAAC,IAAI,kBAAkB,CAAC,EAAE;AAChD,4BAAsB,CAAC,IAAI,kBAAkB,CAAC,EAAE;IACpD;AAGA,cAAU;AACV,cAAU;AAGV,UAAM,iBAAiB,KAAK,QAAQ,OAAO,QAAO,EAAG,qBAAqB,KAAK,QAAQ,mBAAc,IAA2B,IAAI;AACpI,UAAM,kBAAkB,KAAK,IAAI,gBAAgB,CAAC,IAAI;AAEtD,QAAI,eAAe,KAAK,IAAI,QAAQ,QAAQ,eAAe;AAE3D,QAAI,UAAU;AACd,eAAW,KAAK;AAGhB,QAAI,KAAK,eAAe,QAAQ,KAAK,KAAK,IAAI;AAC1C,iBAAW,yBAAyB,KAAK,WAAW,QAAQ,eAAe,CAAC,CAAC,CAAC;;AAC9E;IACJ;AAEA,aAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACnC,iBAAW,wBAAwB,CAAC,IAAI,KAAK,WAAW,QAAQ,CAAC,CAAC,CAAC;;AACnE,iBAAW,wBAAwB,CAAC,IAAI,KAAK,WAAW,QAAQ,CAAC,CAAC,CAAC;;IACvE;AAEA,QAAI,WAAW;AACf,aAAS,IAAI,iBAAiB,IAAI,QAAQ,QAAQ,KAAK;AACnD,iBAAW,4BAA4B,QAAQ,IAAI,KAAK,WAAW,QAAQ,CAAC,CAAC,CAAC;;AAC9E,iBAAW,4BAA4B,QAAQ,IAAI,KAAK,WAAW,QAAQ,CAAC,CAAC,CAAC;;AAC9E;IACJ;AAEA,QAAI,KAAK,aAAa;AAClB,iBAAW;IACf;AAEA,SAAK,QAAQ,mBAAmB;AAEhC,SAAK,aACD,SACA,MACA,MACA;MACI;MACA;OAEJ,YACA,OAAO;EAEf;;;;;;;;;;EAWU,mBAAmB,aAAmB;AAC5C,UAAM,IAAI,KAAK,MAAM,WAAW;AAChC,eAAW,KAAK,CAAC,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,CAAC,GAAG;AAC7C,UAAI,IAAI,MAAM,KAAK,KAAK,MAAM,IAAI,CAAC,IAAI,MAAM,KAAK,IAAI,GAAG;AACrD,eAAO,KAAK,IAAI,GAAG,CAAC;MACxB;IACJ;AACA,WAAO,KAAK,IAAI,GAAG,CAAC;EACxB;;;;;;EAOU,gBAAgB,GAAS;AAQ/B,UAAM,QAAQ,IAAI;AAClB,UAAM,cAAc,KAAK,KAAK,IAAM,KAAK,EAAE,IAAI;AAC/C,UAAM,WAAW,EAAG,IAAI,KAAM,IAAM,QAAQ;AAC5C,UAAM,SAAU,IAAM,cAAe,KAAK,IAAI,QAAQ;AACtD,WAAO;EACX;;;;;;;EAQU,WAAW,GAAW,iBAAiB,GAAC;AAC9C,WAAO,EAAE,QAAQ,cAAc,EAAE,QAAQ,OAAO,EAAE;EACtD;;AA1RuB,oBAAA,YAAY;AAKZ,oBAAA,cAAc;AAKd,oBAAA,WAAW,CAAC,SAAS,WAAW;AAKhC,oBAAA,WAAW,CAAC,0BAA0B;;;ACP3D,IAAO,kBAAP,MAAO,yBAAwB,YAAW;;EAG5C,IAAW,YAAS;AAChB,WAAO,KAAK,eAAe;EAC/B;EAEA,IAAW,UAAU,OAAc;AAC/B,SAAK,eAAe,YAAY;EACpC;;;;EAMA,IAAW,OAAO,GAAS;AACvB,SAAK,eAAe,SAAS;EACjC;;;;EAKA,IAAW,SAAM;AACb,WAAO,KAAK,eAAe;EAC/B;;;;EAMA,IAAW,YAAY,GAAU;AAC7B,SAAK,eAAe,cAAc;EACtC;;;;EAKA,IAAW,cAAW;AAClB,WAAO,KAAK,eAAe;EAC/B;;;;;EAMgB,eAAY;AACxB,WAAO;EACX;;;;;;;;;;;;;;;;EAmBA,YACI,MACA,WACA,QACA,SACA,SAA2B,MAC3B,eAAuB,QAAQ,uBAC/B,QACA,UACA,cAAc,GAAA,UAAU,IAAA,mBAAyB,OACjD,gBACA,GAAA;AAGA,UAAM,wBAAwB,OAAO,YAAY,WAAW,mBAAmB,CAAC,CAAC,QAAQ;AACzF,UAAM,eAAe;MACjB,UAAU,oBAAoB;MAC9B,UAAU,oBAAoB;MAC9B,MAAM,OAAO,YAAY,WAAW,UAAU;MAC9C;MACA;MACA;MACA;MACA;MACA,WAAW,oBAAoB;MAC/B,iBAAiB,EAAE,cAAc,GAAG,UAAU,EAAC;MAC/C;MACA;MACA,GAAI;MACJ,kBAAkB;;AAGtB,UAAM,MAAM,oBAAoB,aAAa;MACzC,eAAe,OAAO,YAAY,YAAY,CAAC,QAAQ,gBAAgB,IAAI,oBAAoB,MAAM,QAAQ,QAAW,QAAW,YAAY,IAAI;MACnJ,GAAG;KACN;AAED,SAAK,eAAe,QAAQ,mBAAmB;AAE/C,SAAK,YAAY;AACjB,SAAK,kBAAkB,IAAI,MAAK;AAC5B,WAAK,eAAe,eAAe,KAAK,iBAAiB,KAAK,eAAe,QAAQ,KAAK;AAC1F,WAAK,eAAe,gBAAgB,KAAK,iBAAiB,KAAK,eAAe,SAAS,KAAK;IAChG,CAAC;AAED,SAAK,SAAS;EAClB;EAEgB,aACZ,WAA6B,MAC7B,YAAgC,MAChC,YAAgC,MAChC,kBACA,YACA,SAAkD;AAElD,SAAK,eAAe,kBAAkB,YAAY,OAAO;EAC7D;;;;EAKO,OAAgB,OAAO,mBAAwB,cAAsB,OAAc,SAAe;AACrG,WAAO,oBAAoB,MACvB,MAAK;AACD,aAAO,IAAI,iBACP,kBAAkB,MAClB,kBAAkB,WAClB,kBAAkB,QAClB,kBAAkB,SAClB,cACA,kBAAkB,0BAClB,MAAM,UAAS,GACf,kBAAkB,UAClB,kBAAkB,aAClB,QACA,KAAK;IAEb,GACA,mBACA,OACA,OAAO;EAEf;;AAlJA,WAAA;EADC,mBAAkB;;AAanB,WAAA;EADC,UAAS;;AAgBV,WAAA;EADC,UAAS;;AA2Hd,cAAc,2BAA2B,eAAe;",
  "names": []
}
